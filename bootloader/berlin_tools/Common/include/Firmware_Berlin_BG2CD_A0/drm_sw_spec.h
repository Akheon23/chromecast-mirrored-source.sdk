/**********************************************************************************************************************
*	DO NOT EDIT! Automatically generated by "Interface Specification Compiler" ver-1.0
*			<ansi-c> :    drm_sw_spec.h
**********************************************************************************************************************/
#ifdef	_drm_sw_spec_h
#else
#define	_drm_sw_spec_h				"   drm_sw_spec_h >>>    "
#include	"ctypes.h"

#pragma	pack(4)

#ifdef	__cplusplus
	extern	"C"
	{
#endif



/**********************************************************************************************************************
*	INTERFACE: StreamHdr
*	@  FUNC
*		%unsigned  12  rdFunc  0
*						*  *
*						*  PC of the read function pointer
*		%unsigned  4  uStrmType
*						*  *
*						*  This field only valid for Debug purpose
*		%unsigned  12  wrFunc  0
*						*  *
*						*  PC of the write function pointer
*		%unsigned  4  algnFactor  0
*						*  *
*						*  If uStrmType == DSStreamIn type, the minimum pre-load buffer size is (1 << algnFactor)
*						*  if uStrmType == DSStreamOut type, the minimum output buffer size is (1 << algnFactor) except the forced flush or interleaved streams
*	@  INFO
*		%unsigned  16  datPtr  0
*						*  *
*						*  Stream type specific data field.
*						*  For uStrmType == DSStreamIn, this filed is the pointer of the data memory pool.
*						*  For uStrmType == DSStreamOut, This field is the pointer of DSOutputModule
*						*  For uStrmType == DTCMStream, this field is referring to the data block base.
*		%unsigned  16  ctrlPtr  0
*						*  *
*						*  the address of the DTCM FIFO Control FIFO
**********************************************************************************************************************/
#ifdef	h_StreamHdr
#else
#define	h_StreamHdr

#define	\
	AR_StreamHdr \
		2
#define	\
	AB_StreamHdr \
		3

typedef struct SIE_StreamHdr {

	#define	RA_StreamHdr_FUNC 			0x00000
	#define	w32StreamHdr_FUNC 			{										\
					UNSG32				uFUNC_rdFunc				 : 12;		\
					UNSG32				uFUNC_uStrmType				 :  4;		\
					UNSG32				uFUNC_wrFunc				 : 12;		\
					UNSG32				uFUNC_algnFactor			 :  4;		\
										}
	/* @'00000 */	union {	UNSG32		u32StreamHdr_FUNC;
								struct	w32StreamHdr_FUNC;
										};

	/* [11: 0] */	#define	  BA_StreamHdr_FUNC_rdFunc				 0x00000
	/* ---:--- */	#define	    bStreamHdr_FUNC_rdFunc				   12 /*bit*/
	/* ---:--- */	#define	LSb32StreamHdr_FUNC_rdFunc				    0 /*:11*/
	/* ---:--- */	#define	MSK32StreamHdr_FUNC_rdFunc				       0x00000FFF
	/* ---:--- */	#define	GET32StreamHdr_FUNC_rdFunc(r32)				 (((r32)>> 0)&0x0FFF)
	/* ---:--- */	#define	GET16StreamHdr_FUNC_rdFunc(r16)				 (((r16)>> 0)&0x0FFF)
	/* ---:--- */	#define	SET32StreamHdr_FUNC_rdFunc(r32,v)			do{(r32)&=~(0x0FFF<< 0);(r32)|=((v)&0x0FFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16StreamHdr_FUNC_rdFunc(r16,v)			do{(r16)&=~(0x0FFF<< 0);(r16)|=((v)&0x0FFF)<< 0;}while(0)

	/* [15:12] */	#define	  BA_StreamHdr_FUNC_uStrmType			 0x00001
	/* ---:--- */	#define	    bStreamHdr_FUNC_uStrmType			    4 /*bit*/
	/* ---:--- */	#define	LSb32StreamHdr_FUNC_uStrmType			   12 /*:15*/
	/* ---:--- */	#define	MSK32StreamHdr_FUNC_uStrmType			       0x0000F000
	/* ---:--- */	#define	GET32StreamHdr_FUNC_uStrmType(r32)			 (((r32)>>12)&0x000F)
	/* ---:--- */	#define	GET16StreamHdr_FUNC_uStrmType(r16)			 (((r16)>>12)&0x000F)
	/* ---:--- */	#define	SET32StreamHdr_FUNC_uStrmType(r32,v)		do{(r32)&=~(0x000F<<12);(r32)|=((v)&0x000F)<<12;}while(0)
	/* ---:--- */	#define	SET16StreamHdr_FUNC_uStrmType(r16,v)		do{(r16)&=~(0x000F<<12);(r16)|=((v)&0x000F)<<12;}while(0)

	/* [27:16] */	#define	  BA_StreamHdr_FUNC_wrFunc				 0x00002
	/* ---:--- */	#define	    bStreamHdr_FUNC_wrFunc				   12 /*bit*/
	/* ---:--- */	#define	LSb32StreamHdr_FUNC_wrFunc				   16 /*:27*/
	/* ---:--- */	#define	MSK32StreamHdr_FUNC_wrFunc				       0x0FFF0000
	/* ---:--- */	#define	GET32StreamHdr_FUNC_wrFunc(r32)				 (((r32)>>16)&0x0FFF)
	/* ---:--- */	#define	GET16StreamHdr_FUNC_wrFunc(r16)				 (((r16)>> 0)&0x0FFF)
	/* ---:--- */	#define	SET32StreamHdr_FUNC_wrFunc(r32,v)			do{(r32)&=~(0x0FFF<<16);(r32)|=((v)&0x0FFF)<<16;}while(0)
	/* ---:--- */	#define	SET16StreamHdr_FUNC_wrFunc(r16,v)			do{(r16)&=~(0x0FFF<< 0);(r16)|=((v)&0x0FFF)<< 0;}while(0)

	/* [31:28] */	#define	  BA_StreamHdr_FUNC_algnFactor			 0x00003
	/* ---:--- */	#define	    bStreamHdr_FUNC_algnFactor			    4 /*bit*/
	/* ---:--- */	#define	LSb32StreamHdr_FUNC_algnFactor			   28 /*:31*/
	/* ---:--- */	#define	MSK32StreamHdr_FUNC_algnFactor			       0xF0000000
	/* ---:--- */	#define	GET32StreamHdr_FUNC_algnFactor(r32)			 (((r32)>>28)&0x000F)
	/* ---:--- */	#define	GET16StreamHdr_FUNC_algnFactor(r16)			 (((r16)>>12)&0x000F)
	/* ---:--- */	#define	SET32StreamHdr_FUNC_algnFactor(r32,v)		do{(r32)&=~(0x000F<<28);(r32)|=((v)&0x000F)<<28;}while(0)
	/* ---:--- */	#define	SET16StreamHdr_FUNC_algnFactor(r16,v)		do{(r16)&=~(0x000F<<12);(r16)|=((v)&0x000F)<<12;}while(0)

	#define	RA_StreamHdr_INFO 			0x00004
	#define	w32StreamHdr_INFO 			{										\
					UNSG32				uINFO_datPtr				 : 16;		\
					UNSG32				uINFO_ctrlPtr				 : 16;		\
										}
	/* @'00004 */	union {	UNSG32		u32StreamHdr_INFO;
								struct	w32StreamHdr_INFO;
										};

	/* [15: 0] */	#define	  BA_StreamHdr_INFO_datPtr				 0x00004
	/* ---:--- */	#define	    bStreamHdr_INFO_datPtr				   16 /*bit*/
	/* ---:--- */	#define	LSb32StreamHdr_INFO_datPtr				    0 /*:15*/
	/* ---:--- */	#define	MSK32StreamHdr_INFO_datPtr				       0x0000FFFF
	/* ---:--- */	#define	GET32StreamHdr_INFO_datPtr(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16StreamHdr_INFO_datPtr(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32StreamHdr_INFO_datPtr(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16StreamHdr_INFO_datPtr(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_StreamHdr_INFO_ctrlPtr				 0x00006
	/* ---:--- */	#define	    bStreamHdr_INFO_ctrlPtr				   16 /*bit*/
	/* ---:--- */	#define	LSb32StreamHdr_INFO_ctrlPtr				   16 /*:31*/
	/* ---:--- */	#define	MSK32StreamHdr_INFO_ctrlPtr				       0xFFFF0000
	/* ---:--- */	#define	GET32StreamHdr_INFO_ctrlPtr(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16StreamHdr_INFO_ctrlPtr(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32StreamHdr_INFO_ctrlPtr(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16StreamHdr_INFO_ctrlPtr(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_StreamHdr;

	#define	dftStreamHdr_FUNC 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32StreamHdr_FUNC;
										} T32StreamHdr_FUNC;
	#define	dftStreamHdr_INFO 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32StreamHdr_INFO;
										} T32StreamHdr_INFO;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	StreamHdr_drvrd (SIE_StreamHdr *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	StreamHdr_drvwr (SIE_StreamHdr *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	StreamHdr_reset (SIE_StreamHdr *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	StreamHdr_check(p,pie,ps8name,hfpErrLOG)		StreamHdr_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	StreamHdr_print(p,    ps8name,hfpErrLOG)		StreamHdr_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	StreamHdr_cmp   (SIE_StreamHdr *p, SIE_StreamHdr *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	StreamHdr_import(SIE_StreamHdr *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	StreamHdr_export(SIE_StreamHdr *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: StreamHdr
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: HBOADDR
*	@
*		%unsigned  16  uAddr  0
**********************************************************************************************************************/
#ifdef	h_HBOADDR
#else
#define	h_HBOADDR

#define	\
	AR_HBOADDR \
		1
#define	\
	AB_HBOADDR \
		2

typedef struct SIE_HBOADDR {

	#define	RA_HBOADDR_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32HBOADDR_D0th_ 			{										\
					UNSG32				u_uAddr						 : 16;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32HBOADDR_D0th_;

	/* [15: 0] */	#define	  BA_HBOADDR_uAddr						 0x00000
	/* ---:--- */	#define	    bHBOADDR_uAddr						   16 /*bit*/
	/* ---:--- */	#define	LSb32HBOADDR_uAddr						    0 /*:15*/
	/* ---:--- */	#define	MSK32HBOADDR_uAddr						       0x0000FFFF
	/* ---:--- */	#define	GET32HBOADDR_uAddr(r32)						 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16HBOADDR_uAddr(r16)						 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32HBOADDR_uAddr(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16HBOADDR_uAddr(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_HBOADDR;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	HBOADDR_drvrd (SIE_HBOADDR *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	HBOADDR_drvwr (SIE_HBOADDR *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	HBOADDR_reset (SIE_HBOADDR *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	HBOADDR_check(p,pie,ps8name,hfpErrLOG)		HBOADDR_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	HBOADDR_print(p,    ps8name,hfpErrLOG)		HBOADDR_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	HBOADDR_cmp   (SIE_HBOADDR *p, SIE_HBOADDR *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	HBOADDR_import(SIE_HBOADDR *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	HBOADDR_export(SIE_HBOADDR *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: HBOADDR
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UINT32
*	@  V32
*		%unsigned  16  uV16L  0
*		%unsigned  16  uV16H  0
**********************************************************************************************************************/
#ifdef	h_UINT32
#else
#define	h_UINT32

#define	\
	AR_UINT32 \
		1
#define	\
	AB_UINT32 \
		2

typedef struct SIE_UINT32 {

	#define	RA_UINT32_V32 				0x00000
	#define	w32UINT32_V32 				{										\
					UNSG32				uV32_uV16L					 : 16;		\
					UNSG32				uV32_uV16H					 : 16;		\
										}
	/* @'00000 */	union {	UNSG32		u32UINT32_V32;
								struct	w32UINT32_V32;
										};

	/* [15: 0] */	#define	  BA_UINT32_V32_uV16L					 0x00000
	/* ---:--- */	#define	    bUINT32_V32_uV16L					   16 /*bit*/
	/* ---:--- */	#define	LSb32UINT32_V32_uV16L					    0 /*:15*/
	/* ---:--- */	#define	MSK32UINT32_V32_uV16L					       0x0000FFFF
	/* ---:--- */	#define	GET32UINT32_V32_uV16L(r32)					 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16UINT32_V32_uV16L(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32UINT32_V32_uV16L(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16UINT32_V32_uV16L(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_UINT32_V32_uV16H					 0x00002
	/* ---:--- */	#define	    bUINT32_V32_uV16H					   16 /*bit*/
	/* ---:--- */	#define	LSb32UINT32_V32_uV16H					   16 /*:31*/
	/* ---:--- */	#define	MSK32UINT32_V32_uV16H					       0xFFFF0000
	/* ---:--- */	#define	GET32UINT32_V32_uV16H(r32)					 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16UINT32_V32_uV16H(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32UINT32_V32_uV16H(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16UINT32_V32_uV16H(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_UINT32;

	#define	dftUINT32_V32 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32UINT32_V32;
										} T32UINT32_V32;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UINT32_drvrd (SIE_UINT32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UINT32_drvwr (SIE_UINT32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UINT32_reset (SIE_UINT32 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UINT32_check(p,pie,ps8name,hfpErrLOG)		UINT32_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UINT32_print(p,    ps8name,hfpErrLOG)		UINT32_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UINT32_cmp   (SIE_UINT32 *p, SIE_UINT32 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UINT32_import(SIE_UINT32 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UINT32_export(SIE_UINT32 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UINT32
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UINT64
*		$UINT32  v32  REG  [2]
**********************************************************************************************************************/
#ifdef	h_UINT64
#else
#define	h_UINT64

#define	\
	AR_UINT64 \
		2
#define	\
	AB_UINT64 \
		3

typedef struct SIE_UINT64 {

	#define	RA_UINT64_v32 				0x00000
	/* @'00000 */	SIE_UINT32 					ie_v32				 [2];
					#define	 arr_UINT64_v32 						  2

} SIE_UINT64;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UINT64_drvrd (SIE_UINT64 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UINT64_drvwr (SIE_UINT64 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UINT64_reset (SIE_UINT64 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UINT64_check(p,pie,ps8name,hfpErrLOG)		UINT64_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UINT64_print(p,    ps8name,hfpErrLOG)		UINT64_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UINT64_cmp   (SIE_UINT64 *p, SIE_UINT64 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UINT64_import(SIE_UINT64 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UINT64_export(SIE_UINT64 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UINT64
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UINT128
*		$UINT32  v32  REG  [4]
**********************************************************************************************************************/
#ifdef	h_UINT128
#else
#define	h_UINT128

#define	\
	AR_UINT128 \
		4
#define	\
	AB_UINT128 \
		4

typedef struct SIE_UINT128 {

	#define	RA_UINT128_v32 				0x00000
	/* @'00000 */	SIE_UINT32 					ie_v32				 [4];
					#define	 arr_UINT128_v32 						  4

} SIE_UINT128;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UINT128_drvrd (SIE_UINT128 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UINT128_drvwr (SIE_UINT128 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UINT128_reset (SIE_UINT128 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UINT128_check(p,pie,ps8name,hfpErrLOG)		UINT128_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UINT128_print(p,    ps8name,hfpErrLOG)		UINT128_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UINT128_cmp   (SIE_UINT128 *p, SIE_UINT128 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UINT128_import(SIE_UINT128 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UINT128_export(SIE_UINT128 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UINT128
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UINT1024
*		$UINT128  v128  REG  [8]
**********************************************************************************************************************/
#ifdef	h_UINT1024
#else
#define	h_UINT1024

#define	\
	AR_UINT1024 \
		32
#define	\
	AB_UINT1024 \
		7

typedef struct SIE_UINT1024 {

	#define	RA_UINT1024_v128 			0x00000
	/* @'00000 */	SIE_UINT128 				ie_v128				 [8];
					#define	 arr_UINT1024_v128 						  8

} SIE_UINT1024;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UINT1024_drvrd (SIE_UINT1024 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UINT1024_drvwr (SIE_UINT1024 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UINT1024_reset (SIE_UINT1024 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UINT1024_check(p,pie,ps8name,hfpErrLOG)		UINT1024_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UINT1024_print(p,    ps8name,hfpErrLOG)		UINT1024_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UINT1024_cmp   (SIE_UINT1024 *p, SIE_UINT1024 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UINT1024_import(SIE_UINT1024 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UINT1024_export(SIE_UINT1024 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UINT1024
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: FIGOSYSLIB
*	@
*			:  INVALID_BIU_PTR  0xFFFF
*						*  *
*						*  Invalid BIU pointer
*			:  INVALID_FIGOEVENT_FLAG  0xFF
*			:  MAX_BLK_NUM  16
*						*  *
*						*  Maxim block number
*			:  MAX_DS_CMD_ID  0x100
*						*  *
*						*  Maxim data streamer command ID
*			:  FIFODIR_INPUT  0
*						*  *
*						*  Input FIFO from DDR to DTCM
*			:  FIFODIR_OUTPUT  1
*						*  *
*						*  Output FIFO from DTCM to DDR
*			:  DS_CMDFIFO_IDX  0
*						*  *
*						*  Data streamer command FIFO index
*			:  STRMTYPE_DTCM  1
*						*  *
*						*  DTCM stream type
*			:  STRMTYPE_DSIN  2
*						*  *
*						*  DRAM to SRAM input stream type
*			:  STRMTYPE_DSOUT  3
*						*  *
*						*  SRAM to DTCM output stream type
*			:  MAX_CTRL_SIZE  56
*						*  *
*						*  Maximum control information size
*			:  INVALID_DS_BASE  0xffffffff
*						*  *
*						*  Invalid data streamer base address
*	@
*		%unsigned  32  dummy
**********************************************************************************************************************/
#ifdef	h_FIGOSYSLIB
#else
#define	h_FIGOSYSLIB

#define	\
	AR_FIGOSYSLIB \
		1
#define	\
	AB_FIGOSYSLIB \
		2

	#define	FIGOSYSLIB_INVALID_BIU_PTR 	0xFFFF
	#define	FIGOSYSLIB_INVALID_FIGOEVENT_FLAG 0xFF
	#define	FIGOSYSLIB_MAX_BLK_NUM 		0x10
	#define	FIGOSYSLIB_MAX_DS_CMD_ID 	0x100
	#define	FIGOSYSLIB_FIFODIR_INPUT 	0x0
	#define	FIGOSYSLIB_FIFODIR_OUTPUT 	0x1
	#define	FIGOSYSLIB_DS_CMDFIFO_IDX 	0x0
	#define	FIGOSYSLIB_STRMTYPE_DTCM 	0x1
	#define	FIGOSYSLIB_STRMTYPE_DSIN 	0x2
	#define	FIGOSYSLIB_STRMTYPE_DSOUT 	0x3
	#define	FIGOSYSLIB_MAX_CTRL_SIZE 	0x38
	#define	FIGOSYSLIB_INVALID_DS_BASE 	0xFFFFFFFF

typedef struct SIE_FIGOSYSLIB {

	#define	RA_FIGOSYSLIB_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32FIGOSYSLIB_D0th_ 		{										\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32FIGOSYSLIB_D0th_;

	/* [31: 0] */	#define	  BA_FIGOSYSLIB_dummy					 0x00000
	/* ---:--- */	#define	    bFIGOSYSLIB_dummy					   32 /*bit*/
	/* ---:--- */	#define	LSb32FIGOSYSLIB_dummy					    0 /*:31*/
	/* ---:--- */	#define	MSK32FIGOSYSLIB_dummy					       0xFFFFFFFF
	/* ---:--- */	#define	GET32FIGOSYSLIB_dummy(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16FIGOSYSLIB_dummy(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32FIGOSYSLIB_dummy(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16FIGOSYSLIB_dummy(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_FIGOSYSLIB;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	FIGOSYSLIB_drvrd (SIE_FIGOSYSLIB *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	FIGOSYSLIB_drvwr (SIE_FIGOSYSLIB *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	FIGOSYSLIB_reset (SIE_FIGOSYSLIB *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	FIGOSYSLIB_check(p,pie,ps8name,hfpErrLOG)		FIGOSYSLIB_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	FIGOSYSLIB_print(p,    ps8name,hfpErrLOG)		FIGOSYSLIB_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	FIGOSYSLIB_cmp   (SIE_FIGOSYSLIB *p, SIE_FIGOSYSLIB *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	FIGOSYSLIB_import(SIE_FIGOSYSLIB *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	FIGOSYSLIB_export(SIE_FIGOSYSLIB *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: FIGOSYSLIB
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: FIGOCtrl
*	@  HDR
*		%unsigned  8  uFlag
*		%unsigned  8  SourceId
*		%unsigned  8  OutBufId
*		%unsigned  8  cmdSize
*						*  *
*						*  Total command size
*		%unsigned  32  uSyncPoint
*						*  *
*						*  32 bits offset of the stream where the control information should be affective, 0xFFFFFFFF means immediate commands
*			:  IM_SYNCP  0xFFFFFFFF
**********************************************************************************************************************/
#ifdef	h_FIGOCtrl
#else
#define	h_FIGOCtrl

#define	\
	AR_FIGOCtrl \
		2
#define	\
	AB_FIGOCtrl \
		3

typedef struct SIE_FIGOCtrl {

	#define	RA_FIGOCtrl_HDR 			0x00000
	#define	w32FIGOCtrl_HDR 			{										\
					UNSG32				uHDR_uFlag					 :  8;		\
					UNSG32				uHDR_SourceId				 :  8;		\
					UNSG32				uHDR_OutBufId				 :  8;		\
					UNSG32				uHDR_cmdSize				 :  8;		\
										}
	/* @'00000 */	union {	UNSG32		u32FIGOCtrl_HDR;
								struct	w32FIGOCtrl_HDR;
										};

	/* [ 7: 0] */	#define	  BA_FIGOCtrl_HDR_uFlag					 0x00000
	/* ---:--- */	#define	    bFIGOCtrl_HDR_uFlag					    8 /*bit*/
	/* ---:--- */	#define	LSb32FIGOCtrl_HDR_uFlag					    0 /*: 7*/
	/* ---:--- */	#define	MSK32FIGOCtrl_HDR_uFlag					       0x000000FF
	/* ---:--- */	#define	GET32FIGOCtrl_HDR_uFlag(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16FIGOCtrl_HDR_uFlag(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32FIGOCtrl_HDR_uFlag(r32,v)				do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16FIGOCtrl_HDR_uFlag(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_FIGOCtrl_HDR_SourceId				 0x00001
	/* ---:--- */	#define	    bFIGOCtrl_HDR_SourceId				    8 /*bit*/
	/* ---:--- */	#define	LSb32FIGOCtrl_HDR_SourceId				    8 /*:15*/
	/* ---:--- */	#define	MSK32FIGOCtrl_HDR_SourceId				       0x0000FF00
	/* ---:--- */	#define	GET32FIGOCtrl_HDR_SourceId(r32)				 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16FIGOCtrl_HDR_SourceId(r16)				 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32FIGOCtrl_HDR_SourceId(r32,v)			do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16FIGOCtrl_HDR_SourceId(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [23:16] */	#define	  BA_FIGOCtrl_HDR_OutBufId				 0x00002
	/* ---:--- */	#define	    bFIGOCtrl_HDR_OutBufId				    8 /*bit*/
	/* ---:--- */	#define	LSb32FIGOCtrl_HDR_OutBufId				   16 /*:23*/
	/* ---:--- */	#define	MSK32FIGOCtrl_HDR_OutBufId				       0x00FF0000
	/* ---:--- */	#define	GET32FIGOCtrl_HDR_OutBufId(r32)				 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16FIGOCtrl_HDR_OutBufId(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32FIGOCtrl_HDR_OutBufId(r32,v)			do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16FIGOCtrl_HDR_OutBufId(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_FIGOCtrl_HDR_cmdSize				 0x00003
	/* ---:--- */	#define	    bFIGOCtrl_HDR_cmdSize				    8 /*bit*/
	/* ---:--- */	#define	LSb32FIGOCtrl_HDR_cmdSize				   24 /*:31*/
	/* ---:--- */	#define	MSK32FIGOCtrl_HDR_cmdSize				       0xFF000000
	/* ---:--- */	#define	GET32FIGOCtrl_HDR_cmdSize(r32)				 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16FIGOCtrl_HDR_cmdSize(r16)				 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32FIGOCtrl_HDR_cmdSize(r32,v)			do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16FIGOCtrl_HDR_cmdSize(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_FIGOCtrl_HDR1 			0x00004
	#define	w32FIGOCtrl_HDR1 			{										\
					UNSG32				uHDR_uSyncPoint				 : 32;		\
										}
	/* @'00004 */	union {	UNSG32		u32FIGOCtrl_HDR1;
								struct	w32FIGOCtrl_HDR1;
										};

	/* [31: 0] */	#define	  BA_FIGOCtrl_HDR_uSyncPoint			 0x00004
	/* ---:--- */	#define	    bFIGOCtrl_HDR_uSyncPoint			   32 /*bit*/
	/* ---:--- */	#define	LSb32FIGOCtrl_HDR_uSyncPoint			    0 /*:31*/
	/* ---:--- */	#define	MSK32FIGOCtrl_HDR_uSyncPoint			       0xFFFFFFFF
	/* ---:--- */	#define	GET32FIGOCtrl_HDR_uSyncPoint(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16FIGOCtrl_HDR_uSyncPoint(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32FIGOCtrl_HDR_uSyncPoint(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16FIGOCtrl_HDR_uSyncPoint(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)
					#define	     FIGOCtrl_HDR_uSyncPoint_IM_SYNCP			0xFFFFFFFF

} SIE_FIGOCtrl;

	#define	dftFIGOCtrl_HDR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32FIGOCtrl_HDR;
										} T32FIGOCtrl_HDR;
	#define	dftFIGOCtrl_HDR1 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32FIGOCtrl_HDR1;
										} T32FIGOCtrl_HDR1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	FIGOCtrl_drvrd (SIE_FIGOCtrl *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	FIGOCtrl_drvwr (SIE_FIGOCtrl *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	FIGOCtrl_reset (SIE_FIGOCtrl *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	FIGOCtrl_check(p,pie,ps8name,hfpErrLOG)		FIGOCtrl_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	FIGOCtrl_print(p,    ps8name,hfpErrLOG)		FIGOCtrl_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	FIGOCtrl_cmp   (SIE_FIGOCtrl *p, SIE_FIGOCtrl *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	FIGOCtrl_import(SIE_FIGOCtrl *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	FIGOCtrl_export(SIE_FIGOCtrl *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: FIGOCtrl
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: FIGOEvent
*	@  CTRLINFO
*		$UINT32  pbData  REG  [14]
*	@  PTRINFO
*		%unsigned  32  nFifoOffset  0
*						*  *
*						*  For non command event, this field indicates the current read or wirte offset. For command event, this field is unused
*		%unsigned  16  uDSFifo32PtrAddr
*						*  *
*						*  Application specific event
*		%unsigned  1  uEnFlag
*		%unsigned  15  Reserved
**********************************************************************************************************************/
#ifdef	h_FIGOEvent
#else
#define	h_FIGOEvent

#define	\
	AR_FIGOEvent \
		16
#define	\
	AB_FIGOEvent \
		6

typedef struct SIE_FIGOEvent {

	#define	RA_FIGOEvent_CTRLINFO 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_pbData			 [14];
					#define	 arr_FIGOEvent_pbData 					  14

	#define	RA_FIGOEvent_PTRINFO 		0x00038
	#define	w32FIGOEvent_PTRINFO 		{										\
					UNSG32				uPTRINFO_nFifoOffset		 : 32;		\
										}
	/* @'00038 */	union {	UNSG32		u32FIGOEvent_PTRINFO;
								struct	w32FIGOEvent_PTRINFO;
										};

	/* [31: 0] */	#define	  BA_FIGOEvent_PTRINFO_nFifoOffset		 0x00038
	/* ---:--- */	#define	    bFIGOEvent_PTRINFO_nFifoOffset		   32 /*bit*/
	/* ---:--- */	#define	LSb32FIGOEvent_PTRINFO_nFifoOffset		    0 /*:31*/
	/* ---:--- */	#define	MSK32FIGOEvent_PTRINFO_nFifoOffset		       0xFFFFFFFF
	/* ---:--- */	#define	GET32FIGOEvent_PTRINFO_nFifoOffset(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16FIGOEvent_PTRINFO_nFifoOffset(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32FIGOEvent_PTRINFO_nFifoOffset(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16FIGOEvent_PTRINFO_nFifoOffset(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_FIGOEvent_PTRINFO1 		0x0003C
	#define	w32FIGOEvent_PTRINFO1 		{										\
					UNSG32				uPTRINFO_uDSFifo32PtrAddr	 : 16;		\
					UNSG32				uPTRINFO_uEnFlag			 :  1;		\
					UNSG32				uPTRINFO_Reserved			 : 15;		\
										}
	/* @'0003C */	union {	UNSG32		u32FIGOEvent_PTRINFO1;
								struct	w32FIGOEvent_PTRINFO1;
										};

	/* [15: 0] */	#define	  BA_FIGOEvent_PTRINFO_uDSFifo32PtrAddr	 0x0003C
	/* ---:--- */	#define	    bFIGOEvent_PTRINFO_uDSFifo32PtrAddr	   16 /*bit*/
	/* ---:--- */	#define	LSb32FIGOEvent_PTRINFO_uDSFifo32PtrAddr	    0 /*:15*/
	/* ---:--- */	#define	MSK32FIGOEvent_PTRINFO_uDSFifo32PtrAddr	       0x0000FFFF
	/* ---:--- */	#define	GET32FIGOEvent_PTRINFO_uDSFifo32PtrAddr(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16FIGOEvent_PTRINFO_uDSFifo32PtrAddr(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32FIGOEvent_PTRINFO_uDSFifo32PtrAddr(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16FIGOEvent_PTRINFO_uDSFifo32PtrAddr(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [16:16] */	#define	  BA_FIGOEvent_PTRINFO_uEnFlag			 0x0003E
	/* ---:--- */	#define	    bFIGOEvent_PTRINFO_uEnFlag			    1 /*bit*/
	/* ---:--- */	#define	LSb32FIGOEvent_PTRINFO_uEnFlag			   16 /*:16*/
	/* ---:--- */	#define	MSK32FIGOEvent_PTRINFO_uEnFlag			       0x00010000
	/* ---:--- */	#define	GET32FIGOEvent_PTRINFO_uEnFlag(r32)			 (((r32)>>16)&0x0001)
	/* ---:--- */	#define	GET16FIGOEvent_PTRINFO_uEnFlag(r16)			 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32FIGOEvent_PTRINFO_uEnFlag(r32,v)		do{(r32)&=~(0x0001<<16);(r32)|=((v)&0x0001)<<16;}while(0)
	/* ---:--- */	#define	SET16FIGOEvent_PTRINFO_uEnFlag(r16,v)		do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [31:17] */	#define	  BA_FIGOEvent_PTRINFO_Reserved			 0x0003E
	/* ---:--- */	#define	    bFIGOEvent_PTRINFO_Reserved			   15 /*bit*/
	/* ---:--- */	#define	LSb32FIGOEvent_PTRINFO_Reserved			   17 /*:31*/
	/* ---:--- */	#define	MSK32FIGOEvent_PTRINFO_Reserved			       0xFFFE0000
	/* ---:--- */	#define	GET32FIGOEvent_PTRINFO_Reserved(r32)		 (((r32)>>17)&0x7FFF)
	/* ---:--- */	#define	GET16FIGOEvent_PTRINFO_Reserved(r16)		 (((r16)>> 1)&0x7FFF)
	/* ---:--- */	#define	SET32FIGOEvent_PTRINFO_Reserved(r32,v)		do{(r32)&=~(0x7FFF<<17);(r32)|=((v)&0x7FFF)<<17;}while(0)
	/* ---:--- */	#define	SET16FIGOEvent_PTRINFO_Reserved(r16,v)		do{(r16)&=~(0x7FFF<< 1);(r16)|=((v)&0x7FFF)<< 1;}while(0)

} SIE_FIGOEvent;

	#define	dftFIGOEvent_PTRINFO 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32FIGOEvent_PTRINFO;
										} T32FIGOEvent_PTRINFO;
	#define	dftFIGOEvent_PTRINFO1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32FIGOEvent_PTRINFO1;
										} T32FIGOEvent_PTRINFO1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	FIGOEvent_drvrd (SIE_FIGOEvent *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	FIGOEvent_drvwr (SIE_FIGOEvent *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	FIGOEvent_reset (SIE_FIGOEvent *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	FIGOEvent_check(p,pie,ps8name,hfpErrLOG)		FIGOEvent_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	FIGOEvent_print(p,    ps8name,hfpErrLOG)		FIGOEvent_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	FIGOEvent_cmp   (SIE_FIGOEvent *p, SIE_FIGOEvent *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	FIGOEvent_import(SIE_FIGOEvent *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	FIGOEvent_export(SIE_FIGOEvent *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: FIGOEvent
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DTCMFifo
*	@
*		%unsigned  16  nRdOff  0
*						*  *
*						*  Current read offset
*		%unsigned  16  pbBase  0
*						*  *
*						*  DTCM FIFO base address
*	@
*		%unsigned  16  nWrOff  0
*						*  *
*						*  Current write offset
*		%unsigned  16  nMaxSize  0
*						*  *
*						*  MAX size of DTCM FIFO in bytes
**********************************************************************************************************************/
#ifdef	h_DTCMFifo
#else
#define	h_DTCMFifo

#define	\
	AR_DTCMFifo \
		2
#define	\
	AB_DTCMFifo \
		3

typedef struct SIE_DTCMFifo {

	#define	RA_DTCMFifo_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32DTCMFifo_D0th_ 			{										\
					UNSG32				u_nRdOff					 : 16;		\
					UNSG32				u_pbBase					 : 16;		\
										}
	/* @'00000 */				struct	w32DTCMFifo_D0th_;

	/* [15: 0] */	#define	  BA_DTCMFifo_nRdOff					 0x00000
	/* ---:--- */	#define	    bDTCMFifo_nRdOff					   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMFifo_nRdOff					    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMFifo_nRdOff					       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMFifo_nRdOff(r32)					 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMFifo_nRdOff(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMFifo_nRdOff(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMFifo_nRdOff(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMFifo_pbBase					 0x00002
	/* ---:--- */	#define	    bDTCMFifo_pbBase					   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMFifo_pbBase					   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMFifo_pbBase					       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMFifo_pbBase(r32)					 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMFifo_pbBase(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMFifo_pbBase(r32,v)					do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMFifo_pbBase(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMFifo_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DTCMFifo_D1th_ 			{										\
					UNSG32				u_nWrOff					 : 16;		\
					UNSG32				u_nMaxSize					 : 16;		\
										}
	/* @'00004 */				struct	w32DTCMFifo_D1th_;

	/* [15: 0] */	#define	  BA_DTCMFifo_nWrOff					 0x00004
	/* ---:--- */	#define	    bDTCMFifo_nWrOff					   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMFifo_nWrOff					    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMFifo_nWrOff					       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMFifo_nWrOff(r32)					 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMFifo_nWrOff(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMFifo_nWrOff(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMFifo_nWrOff(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMFifo_nMaxSize					 0x00006
	/* ---:--- */	#define	    bDTCMFifo_nMaxSize					   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMFifo_nMaxSize					   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMFifo_nMaxSize					       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMFifo_nMaxSize(r32)					 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMFifo_nMaxSize(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMFifo_nMaxSize(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMFifo_nMaxSize(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_DTCMFifo;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DTCMFifo_drvrd (SIE_DTCMFifo *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DTCMFifo_drvwr (SIE_DTCMFifo *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DTCMFifo_reset (SIE_DTCMFifo *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DTCMFifo_check(p,pie,ps8name,hfpErrLOG)		DTCMFifo_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DTCMFifo_print(p,    ps8name,hfpErrLOG)		DTCMFifo_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DTCMFifo_cmp   (SIE_DTCMFifo *p, SIE_DTCMFifo *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DTCMFifo_import(SIE_DTCMFifo *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DTCMFifo_export(SIE_DTCMFifo *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DTCMFifo
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSFifo32
*	@
*		%unsigned  32  nRdOff  0
*						*  *
*						*  Current FIFO read offset from the base address of the FIFO
*	@
*		%unsigned  32  pbBase  0
*						*  *
*						*  32-bits address of the FIFO buffer base in DDR
*	@
*		%unsigned  32  nWrOff  0
*						*  *
*						*  Current FIFO write offset from the base address of the FIFO
*	@
*		%unsigned  32  nMaxSize  0
*						*  *
*						*  MAX size of DS FIFO in bytes
**********************************************************************************************************************/
#ifdef	h_DSFifo32
#else
#define	h_DSFifo32

#define	\
	AR_DSFifo32 \
		4
#define	\
	AB_DSFifo32 \
		4

typedef struct SIE_DSFifo32 {

	#define	RA_DSFifo32_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32DSFifo32_D0th_ 			{										\
					UNSG32				u_nRdOff					 : 32;		\
										}
	/* @'00000 */				struct	w32DSFifo32_D0th_;

	/* [31: 0] */	#define	  BA_DSFifo32_nRdOff					 0x00000
	/* ---:--- */	#define	    bDSFifo32_nRdOff					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo32_nRdOff					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo32_nRdOff					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo32_nRdOff(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo32_nRdOff(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo32_nRdOff(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo32_nRdOff(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DSFifo32_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DSFifo32_D1th_ 			{										\
					UNSG32				u_pbBase					 : 32;		\
										}
	/* @'00004 */				struct	w32DSFifo32_D1th_;

	/* [31: 0] */	#define	  BA_DSFifo32_pbBase					 0x00004
	/* ---:--- */	#define	    bDSFifo32_pbBase					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo32_pbBase					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo32_pbBase					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo32_pbBase(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo32_pbBase(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo32_pbBase(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo32_pbBase(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DSFifo32_D2th_ 			ISC_USE_ONLY	0x00008
	#define	w32DSFifo32_D2th_ 			{										\
					UNSG32				u_nWrOff					 : 32;		\
										}
	/* @'00008 */				struct	w32DSFifo32_D2th_;

	/* [31: 0] */	#define	  BA_DSFifo32_nWrOff					 0x00008
	/* ---:--- */	#define	    bDSFifo32_nWrOff					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo32_nWrOff					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo32_nWrOff					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo32_nWrOff(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo32_nWrOff(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo32_nWrOff(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo32_nWrOff(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DSFifo32_D3th_ 			ISC_USE_ONLY	0x0000C
	#define	w32DSFifo32_D3th_ 			{										\
					UNSG32				u_nMaxSize					 : 32;		\
										}
	/* @'0000C */				struct	w32DSFifo32_D3th_;

	/* [31: 0] */	#define	  BA_DSFifo32_nMaxSize					 0x0000C
	/* ---:--- */	#define	    bDSFifo32_nMaxSize					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo32_nMaxSize					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo32_nMaxSize					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo32_nMaxSize(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo32_nMaxSize(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo32_nMaxSize(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo32_nMaxSize(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DSFifo32;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSFifo32_drvrd (SIE_DSFifo32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSFifo32_drvwr (SIE_DSFifo32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSFifo32_reset (SIE_DSFifo32 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSFifo32_check(p,pie,ps8name,hfpErrLOG)		DSFifo32_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSFifo32_print(p,    ps8name,hfpErrLOG)		DSFifo32_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSFifo32_cmp   (SIE_DSFifo32 *p, SIE_DSFifo32 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSFifo32_import(SIE_DSFifo32 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSFifo32_export(SIE_DSFifo32 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSFifo32
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DTCMBlk
*	@  HDR
*		%unsigned  1  isDSFinished  0
*						*  *
*		%unsigned  15  nReserved  0
*		%unsigned  16  uBackDSID  0
*						*  *
*		%unsigned  16  addrHdr  0
*						*  *
*						*  Address to the block header
*		%unsigned  16  hdrSize  0
*						*  *
*						*  Size of the block header
*	@  DAT
*		$DTCMFifo  dtcmFifo  0
*						*  *
*						*  Bytes of data available in the current data block
**********************************************************************************************************************/
#ifdef	h_DTCMBlk
#else
#define	h_DTCMBlk

#define	\
	AR_DTCMBlk \
		4
#define	\
	AB_DTCMBlk \
		4

typedef struct SIE_DTCMBlk {

	#define	RA_DTCMBlk_HDR 				0x00000
	#define	w32DTCMBlk_HDR 				{										\
					UNSG32				uHDR_isDSFinished			 :  1;		\
					UNSG32				uHDR_nReserved				 : 15;		\
					UNSG32				uHDR_uBackDSID				 : 16;		\
										}
	/* @'00000 */	union {	UNSG32		u32DTCMBlk_HDR;
								struct	w32DTCMBlk_HDR;
										};

	/* [ 0: 0] */	#define	  BA_DTCMBlk_HDR_isDSFinished			 0x00000
	/* ---:--- */	#define	    bDTCMBlk_HDR_isDSFinished			    1 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlk_HDR_isDSFinished			    0 /*: 0*/
	/* ---:--- */	#define	MSK32DTCMBlk_HDR_isDSFinished			       0x00000001
	/* ---:--- */	#define	GET32DTCMBlk_HDR_isDSFinished(r32)			 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16DTCMBlk_HDR_isDSFinished(r16)			 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32DTCMBlk_HDR_isDSFinished(r32,v)		do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlk_HDR_isDSFinished(r16,v)		do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [15: 1] */	#define	  BA_DTCMBlk_HDR_nReserved				 0x00000
	/* ---:--- */	#define	    bDTCMBlk_HDR_nReserved				   15 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlk_HDR_nReserved				    1 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlk_HDR_nReserved				       0x0000FFFE
	/* ---:--- */	#define	GET32DTCMBlk_HDR_nReserved(r32)				 (((r32)>> 1)&0x7FFF)
	/* ---:--- */	#define	GET16DTCMBlk_HDR_nReserved(r16)				 (((r16)>> 1)&0x7FFF)
	/* ---:--- */	#define	SET32DTCMBlk_HDR_nReserved(r32,v)			do{(r32)&=~(0x7FFF<< 1);(r32)|=((v)&0x7FFF)<< 1;}while(0)
	/* ---:--- */	#define	SET16DTCMBlk_HDR_nReserved(r16,v)			do{(r16)&=~(0x7FFF<< 1);(r16)|=((v)&0x7FFF)<< 1;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlk_HDR_uBackDSID				 0x00002
	/* ---:--- */	#define	    bDTCMBlk_HDR_uBackDSID				   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlk_HDR_uBackDSID				   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlk_HDR_uBackDSID				       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlk_HDR_uBackDSID(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlk_HDR_uBackDSID(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlk_HDR_uBackDSID(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlk_HDR_uBackDSID(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlk_HDR1 			0x00004
	#define	w32DTCMBlk_HDR1 			{										\
					UNSG32				uHDR_addrHdr				 : 16;		\
					UNSG32				uHDR_hdrSize				 : 16;		\
										}
	/* @'00004 */	union {	UNSG32		u32DTCMBlk_HDR1;
								struct	w32DTCMBlk_HDR1;
										};

	/* [15: 0] */	#define	  BA_DTCMBlk_HDR_addrHdr				 0x00004
	/* ---:--- */	#define	    bDTCMBlk_HDR_addrHdr				   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlk_HDR_addrHdr				    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlk_HDR_addrHdr				       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlk_HDR_addrHdr(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlk_HDR_addrHdr(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlk_HDR_addrHdr(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlk_HDR_addrHdr(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlk_HDR_hdrSize				 0x00006
	/* ---:--- */	#define	    bDTCMBlk_HDR_hdrSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlk_HDR_hdrSize				   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlk_HDR_hdrSize				       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlk_HDR_hdrSize(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlk_HDR_hdrSize(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlk_HDR_hdrSize(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlk_HDR_hdrSize(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlk_DAT 				0x00008
	/* @'00008 */	SIE_DTCMFifo 				ie_dtcmFifo;

} SIE_DTCMBlk;

	#define	dftDTCMBlk_HDR 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlk_HDR;
										} T32DTCMBlk_HDR;
	#define	dftDTCMBlk_HDR1 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlk_HDR1;
										} T32DTCMBlk_HDR1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DTCMBlk_drvrd (SIE_DTCMBlk *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DTCMBlk_drvwr (SIE_DTCMBlk *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DTCMBlk_reset (SIE_DTCMBlk *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DTCMBlk_check(p,pie,ps8name,hfpErrLOG)		DTCMBlk_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DTCMBlk_print(p,    ps8name,hfpErrLOG)		DTCMBlk_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DTCMBlk_cmp   (SIE_DTCMBlk *p, SIE_DTCMBlk *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DTCMBlk_import(SIE_DTCMBlk *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DTCMBlk_export(SIE_DTCMBlk *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DTCMBlk
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DTCMBlkQ
*	@  HDR
*		%unsigned  16  nRdOff  0
*						*  *
*						*  Offset of the block to be read
*		%unsigned  16  nWrOff  0
*						*  *
*						*  Offset of the block to be written
*		%unsigned  16  nTotalSize
*						*  *
*						*  Total bytes of data buffering in this block queue
*		%unsigned  16  nMaxSize
*						*  *
*						*  Total bytes of data can be held in the memory
*	@  LIST
*		%unsigned  16  blkPtrList  REG  [16]
*						*  *
*						*  Block pointer
**********************************************************************************************************************/
#ifdef	h_DTCMBlkQ
#else
#define	h_DTCMBlkQ

#define	\
	AR_DTCMBlkQ \
		10
#define	\
	AB_DTCMBlkQ \
		6

typedef struct SIE_DTCMBlkQ {

	#define	RA_DTCMBlkQ_HDR 			0x00000
	#define	w32DTCMBlkQ_HDR 			{										\
					UNSG32				uHDR_nRdOff					 : 16;		\
					UNSG32				uHDR_nWrOff					 : 16;		\
										}
	/* @'00000 */	union {	UNSG32		u32DTCMBlkQ_HDR;
								struct	w32DTCMBlkQ_HDR;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_HDR_nRdOff				 0x00000
	/* ---:--- */	#define	    bDTCMBlkQ_HDR_nRdOff				   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_HDR_nRdOff				    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_HDR_nRdOff				       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_HDR_nRdOff(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_HDR_nRdOff(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_HDR_nRdOff(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_HDR_nRdOff(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_HDR_nWrOff				 0x00002
	/* ---:--- */	#define	    bDTCMBlkQ_HDR_nWrOff				   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_HDR_nWrOff				   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_HDR_nWrOff				       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_HDR_nWrOff(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_HDR_nWrOff(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_HDR_nWrOff(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_HDR_nWrOff(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_HDR1 			0x00004
	#define	w32DTCMBlkQ_HDR1 			{										\
					UNSG32				uHDR_nTotalSize				 : 16;		\
					UNSG32				uHDR_nMaxSize				 : 16;		\
										}
	/* @'00004 */	union {	UNSG32		u32DTCMBlkQ_HDR1;
								struct	w32DTCMBlkQ_HDR1;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_HDR_nTotalSize			 0x00004
	/* ---:--- */	#define	    bDTCMBlkQ_HDR_nTotalSize			   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_HDR_nTotalSize			    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_HDR_nTotalSize			       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_HDR_nTotalSize(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_HDR_nTotalSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_HDR_nTotalSize(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_HDR_nTotalSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_HDR_nMaxSize				 0x00006
	/* ---:--- */	#define	    bDTCMBlkQ_HDR_nMaxSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_HDR_nMaxSize				   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_HDR_nMaxSize				       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_HDR_nMaxSize(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_HDR_nMaxSize(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_HDR_nMaxSize(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_HDR_nMaxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_LIST 			0x00008
	#define	w32DTCMBlkQ_LIST 			{										\
					UNSG32				uLIST_blkPtrList_0i			 : 16;		\
					UNSG32				uLIST_blkPtrList_1i			 : 16;		\
										}
	/* @'00008 */	union {	UNSG32		u32DTCMBlkQ_LIST;
								struct	w32DTCMBlkQ_LIST;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_0i		 0x00008
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_0i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_0i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_0i		       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_0i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_0i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_0i(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_0i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_1i		 0x0000A
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_1i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_1i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_1i		       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_1i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_1i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_1i(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_1i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_LIST1 			0x0000C
	#define	w32DTCMBlkQ_LIST1 			{										\
					UNSG32				uLIST_blkPtrList_2i			 : 16;		\
					UNSG32				uLIST_blkPtrList_3i			 : 16;		\
										}
	/* @'0000C */	union {	UNSG32		u32DTCMBlkQ_LIST1;
								struct	w32DTCMBlkQ_LIST1;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_2i		 0x0000C
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_2i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_2i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_2i		       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_2i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_2i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_2i(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_2i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_3i		 0x0000E
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_3i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_3i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_3i		       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_3i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_3i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_3i(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_3i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_LIST2 			0x00010
	#define	w32DTCMBlkQ_LIST2 			{										\
					UNSG32				uLIST_blkPtrList_4i			 : 16;		\
					UNSG32				uLIST_blkPtrList_5i			 : 16;		\
										}
	/* @'00010 */	union {	UNSG32		u32DTCMBlkQ_LIST2;
								struct	w32DTCMBlkQ_LIST2;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_4i		 0x00010
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_4i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_4i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_4i		       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_4i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_4i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_4i(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_4i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_5i		 0x00012
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_5i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_5i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_5i		       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_5i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_5i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_5i(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_5i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_LIST3 			0x00014
	#define	w32DTCMBlkQ_LIST3 			{										\
					UNSG32				uLIST_blkPtrList_6i			 : 16;		\
					UNSG32				uLIST_blkPtrList_7i			 : 16;		\
										}
	/* @'00014 */	union {	UNSG32		u32DTCMBlkQ_LIST3;
								struct	w32DTCMBlkQ_LIST3;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_6i		 0x00014
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_6i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_6i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_6i		       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_6i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_6i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_6i(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_6i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_7i		 0x00016
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_7i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_7i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_7i		       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_7i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_7i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_7i(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_7i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_LIST4 			0x00018
	#define	w32DTCMBlkQ_LIST4 			{										\
					UNSG32				uLIST_blkPtrList_8i			 : 16;		\
					UNSG32				uLIST_blkPtrList_9i			 : 16;		\
										}
	/* @'00018 */	union {	UNSG32		u32DTCMBlkQ_LIST4;
								struct	w32DTCMBlkQ_LIST4;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_8i		 0x00018
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_8i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_8i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_8i		       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_8i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_8i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_8i(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_8i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_9i		 0x0001A
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_9i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_9i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_9i		       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_9i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_9i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_9i(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_9i(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_LIST5 			0x0001C
	#define	w32DTCMBlkQ_LIST5 			{										\
					UNSG32				uLIST_blkPtrList_10i		 : 16;		\
					UNSG32				uLIST_blkPtrList_11i		 : 16;		\
										}
	/* @'0001C */	union {	UNSG32		u32DTCMBlkQ_LIST5;
								struct	w32DTCMBlkQ_LIST5;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_10i		 0x0001C
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_10i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_10i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_10i		       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_10i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_10i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_10i(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_10i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_11i		 0x0001E
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_11i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_11i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_11i		       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_11i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_11i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_11i(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_11i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_LIST6 			0x00020
	#define	w32DTCMBlkQ_LIST6 			{										\
					UNSG32				uLIST_blkPtrList_12i		 : 16;		\
					UNSG32				uLIST_blkPtrList_13i		 : 16;		\
										}
	/* @'00020 */	union {	UNSG32		u32DTCMBlkQ_LIST6;
								struct	w32DTCMBlkQ_LIST6;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_12i		 0x00020
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_12i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_12i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_12i		       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_12i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_12i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_12i(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_12i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_13i		 0x00022
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_13i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_13i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_13i		       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_13i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_13i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_13i(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_13i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMBlkQ_LIST7 			0x00024
	#define	w32DTCMBlkQ_LIST7 			{										\
					UNSG32				uLIST_blkPtrList_14i		 : 16;		\
					UNSG32				uLIST_blkPtrList_15i		 : 16;		\
										}
	/* @'00024 */	union {	UNSG32		u32DTCMBlkQ_LIST7;
								struct	w32DTCMBlkQ_LIST7;
										};

	/* [15: 0] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_14i		 0x00024
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_14i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_14i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_14i		       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_14i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_14i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_14i(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_14i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMBlkQ_LIST_blkPtrList_15i		 0x00026
	/* ---:--- */	#define	    bDTCMBlkQ_LIST_blkPtrList_15i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMBlkQ_LIST_blkPtrList_15i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMBlkQ_LIST_blkPtrList_15i		       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMBlkQ_LIST_blkPtrList_15i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMBlkQ_LIST_blkPtrList_15i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMBlkQ_LIST_blkPtrList_15i(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMBlkQ_LIST_blkPtrList_15i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_DTCMBlkQ;

	#define	dftDTCMBlkQ_HDR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_HDR;
										} T32DTCMBlkQ_HDR;
	#define	dftDTCMBlkQ_HDR1 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_HDR1;
										} T32DTCMBlkQ_HDR1;
	#define	dftDTCMBlkQ_LIST 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_LIST;
										} T32DTCMBlkQ_LIST;
	#define	dftDTCMBlkQ_LIST1 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_LIST1;
										} T32DTCMBlkQ_LIST1;
	#define	dftDTCMBlkQ_LIST2 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_LIST2;
										} T32DTCMBlkQ_LIST2;
	#define	dftDTCMBlkQ_LIST3 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_LIST3;
										} T32DTCMBlkQ_LIST3;
	#define	dftDTCMBlkQ_LIST4 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_LIST4;
										} T32DTCMBlkQ_LIST4;
	#define	dftDTCMBlkQ_LIST5 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_LIST5;
										} T32DTCMBlkQ_LIST5;
	#define	dftDTCMBlkQ_LIST6 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_LIST6;
										} T32DTCMBlkQ_LIST6;
	#define	dftDTCMBlkQ_LIST7 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DTCMBlkQ_LIST7;
										} T32DTCMBlkQ_LIST7;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DTCMBlkQ_drvrd (SIE_DTCMBlkQ *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DTCMBlkQ_drvwr (SIE_DTCMBlkQ *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DTCMBlkQ_reset (SIE_DTCMBlkQ *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DTCMBlkQ_check(p,pie,ps8name,hfpErrLOG)		DTCMBlkQ_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DTCMBlkQ_print(p,    ps8name,hfpErrLOG)		DTCMBlkQ_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DTCMBlkQ_cmp   (SIE_DTCMBlkQ *p, SIE_DTCMBlkQ *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DTCMBlkQ_import(SIE_DTCMBlkQ *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DTCMBlkQ_export(SIE_DTCMBlkQ *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DTCMBlkQ
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DTCMBlkPool
*	@  PTR
*		$DTCMBlkQ  blkQ
*	@  DAT
*		$DTCMBlk  blkList  REG  [16]
*						*  *
*						*  Block list
**********************************************************************************************************************/
#ifdef	h_DTCMBlkPool
#else
#define	h_DTCMBlkPool

#define	\
	AR_DTCMBlkPool \
		74
#define	\
	AB_DTCMBlkPool \
		9

typedef struct SIE_DTCMBlkPool {

	#define	RA_DTCMBlkPool_PTR 			0x00000
	/* @'00000 */	SIE_DTCMBlkQ 				ie_blkQ;

	#define	RA_DTCMBlkPool_DAT 			0x00028
	/* @'00028 */	SIE_DTCMBlk 				ie_blkList			 [16];
					#define	 arr_DTCMBlkPool_blkList 				  16

} SIE_DTCMBlkPool;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DTCMBlkPool_drvrd (SIE_DTCMBlkPool *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DTCMBlkPool_drvwr (SIE_DTCMBlkPool *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DTCMBlkPool_reset (SIE_DTCMBlkPool *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DTCMBlkPool_check(p,pie,ps8name,hfpErrLOG)		DTCMBlkPool_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DTCMBlkPool_print(p,    ps8name,hfpErrLOG)		DTCMBlkPool_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DTCMBlkPool_cmp   (SIE_DTCMBlkPool *p, SIE_DTCMBlkPool *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DTCMBlkPool_import(SIE_DTCMBlkPool *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DTCMBlkPool_export(SIE_DTCMBlkPool *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DTCMBlkPool
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: IOCtrlFlag
*	@  IOCTRL
*		%unsigned  1  datFlag  0
*						*  *
*						*  1 : Read/Write Data
*						*  0: Read/Write Control
*		%unsigned  3  opFlag
*			:  PEAK_OP  0
*						*  *
*						*  Copy content without moving pointers
*			:  SEEK_OP  1
*						*  *
*						*  Move pointers without copy data
*			:  CLEAR_OP  2
*						*  *
*						*  Clear all of the pending data and without copying
*			:  APPEND_OP  3
*						*  *
*						*  Append the data into the stream
*			:  FLUSH_OP  4
*						*  *
*						*  Append the data into the stream and flush all the pending data
**********************************************************************************************************************/
#ifdef	h_IOCtrlFlag
#else
#define	h_IOCtrlFlag

#define	\
	AR_IOCtrlFlag \
		1
#define	\
	AB_IOCtrlFlag \
		2

typedef struct SIE_IOCtrlFlag {

	#define	RA_IOCtrlFlag_IOCTRL 		0x00000
	#define	w32IOCtrlFlag_IOCTRL 		{										\
					UNSG32				uIOCTRL_datFlag				 :  1;		\
					UNSG32				uIOCTRL_opFlag				 :  3;		\
					UNSG32				_x00000	: 28;							\
										}
	/* @'00000 */	union {	UNSG32		u32IOCtrlFlag_IOCTRL;
								struct	w32IOCtrlFlag_IOCTRL;
										};

	/* [ 0: 0] */	#define	  BA_IOCtrlFlag_IOCTRL_datFlag			 0x00000
	/* ---:--- */	#define	    bIOCtrlFlag_IOCTRL_datFlag			    1 /*bit*/
	/* ---:--- */	#define	LSb32IOCtrlFlag_IOCTRL_datFlag			    0 /*: 0*/
	/* ---:--- */	#define	MSK32IOCtrlFlag_IOCTRL_datFlag			       0x00000001
	/* ---:--- */	#define	GET32IOCtrlFlag_IOCTRL_datFlag(r32)			 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16IOCtrlFlag_IOCTRL_datFlag(r16)			 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32IOCtrlFlag_IOCTRL_datFlag(r32,v)		do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16IOCtrlFlag_IOCTRL_datFlag(r16,v)		do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [ 3: 1] */	#define	  BA_IOCtrlFlag_IOCTRL_opFlag			 0x00000
	/* ---:--- */	#define	    bIOCtrlFlag_IOCTRL_opFlag			    3 /*bit*/
	/* ---:--- */	#define	LSb32IOCtrlFlag_IOCTRL_opFlag			    1 /*: 3*/
	/* ---:--- */	#define	MSK32IOCtrlFlag_IOCTRL_opFlag			       0x0000000E
	/* ---:--- */	#define	GET32IOCtrlFlag_IOCTRL_opFlag(r32)			 (((r32)>> 1)&0x0007)
	/* ---:--- */	#define	GET16IOCtrlFlag_IOCTRL_opFlag(r16)			 (((r16)>> 1)&0x0007)
	/* ---:--- */	#define	SET32IOCtrlFlag_IOCTRL_opFlag(r32,v)		do{(r32)&=~(0x0007<< 1);(r32)|=((v)&0x0007)<< 1;}while(0)
	/* ---:--- */	#define	SET16IOCtrlFlag_IOCTRL_opFlag(r16,v)		do{(r16)&=~(0x0007<< 1);(r16)|=((v)&0x0007)<< 1;}while(0)
					#define	     IOCtrlFlag_IOCTRL_opFlag_PEAK_OP			0x0
					#define	     IOCtrlFlag_IOCTRL_opFlag_SEEK_OP			0x1
					#define	     IOCtrlFlag_IOCTRL_opFlag_CLEAR_OP			0x2
					#define	     IOCtrlFlag_IOCTRL_opFlag_APPEND_OP			0x3
					#define	     IOCtrlFlag_IOCTRL_opFlag_FLUSH_OP			0x4

} SIE_IOCtrlFlag;

	#define	dftIOCtrlFlag_IOCTRL 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32IOCtrlFlag_IOCTRL;
										} T32IOCtrlFlag_IOCTRL;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	IOCtrlFlag_drvrd (SIE_IOCtrlFlag *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	IOCtrlFlag_drvwr (SIE_IOCtrlFlag *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	IOCtrlFlag_reset (SIE_IOCtrlFlag *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	IOCtrlFlag_check(p,pie,ps8name,hfpErrLOG)		IOCtrlFlag_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	IOCtrlFlag_print(p,    ps8name,hfpErrLOG)		IOCtrlFlag_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	IOCtrlFlag_cmp   (SIE_IOCtrlFlag *p, SIE_IOCtrlFlag *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	IOCtrlFlag_import(SIE_IOCtrlFlag *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	IOCtrlFlag_export(SIE_IOCtrlFlag *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: IOCtrlFlag
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSStreamIn
*	@  HDR
*		$StreamHdr  hdr
*	@  FIFOPTR
*		$DSFifo32  dsFifo
*						*  *
*						*  Fifo pointer information
*	@  DATBLKQ
*		$DTCMBlkQ  blkQ
*						*  *
*						*  Preloaded data block
*	@  CTRLFIFO
*		$DTCMFifo  ctrlFIFoIn
*						*  *
*						*  Input control information
**********************************************************************************************************************/
#ifdef	h_DSStreamIn
#else
#define	h_DSStreamIn

#define	\
	AR_DSStreamIn \
		18
#define	\
	AB_DSStreamIn \
		7

typedef struct SIE_DSStreamIn {

	#define	RA_DSStreamIn_HDR 			0x00000
	/* @'00000 */	SIE_StreamHdr 				ie_hdr;

	#define	RA_DSStreamIn_FIFOPTR 		0x00008
	/* @'00008 */	SIE_DSFifo32 				ie_dsFifo;

	#define	RA_DSStreamIn_DATBLKQ 		0x00018
	/* @'00018 */	SIE_DTCMBlkQ 				ie_blkQ;

	#define	RA_DSStreamIn_CTRLFIFO 		0x00040
	/* @'00040 */	SIE_DTCMFifo 				ie_ctrlFIFoIn;

} SIE_DSStreamIn;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSStreamIn_drvrd (SIE_DSStreamIn *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSStreamIn_drvwr (SIE_DSStreamIn *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSStreamIn_reset (SIE_DSStreamIn *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSStreamIn_check(p,pie,ps8name,hfpErrLOG)		DSStreamIn_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSStreamIn_print(p,    ps8name,hfpErrLOG)		DSStreamIn_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSStreamIn_cmp   (SIE_DSStreamIn *p, SIE_DSStreamIn *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSStreamIn_import(SIE_DSStreamIn *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSStreamIn_export(SIE_DSStreamIn *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSStreamIn
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSStreamOut
*	@  HDR
*		$StreamHdr  hdr  0
*						*  *
*						*  The pointer to the memory block pool
*	@  FIFOPTR
*		$DSFifo32  dsFifo  0
*						*  *
*						*  Fifo pointer information
**********************************************************************************************************************/
#ifdef	h_DSStreamOut
#else
#define	h_DSStreamOut

#define	\
	AR_DSStreamOut \
		6
#define	\
	AB_DSStreamOut \
		5

typedef struct SIE_DSStreamOut {

	#define	RA_DSStreamOut_HDR 			0x00000
	/* @'00000 */	SIE_StreamHdr 				ie_hdr;

	#define	RA_DSStreamOut_FIFOPTR 		0x00008
	/* @'00008 */	SIE_DSFifo32 				ie_dsFifo;

} SIE_DSStreamOut;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSStreamOut_drvrd (SIE_DSStreamOut *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSStreamOut_drvwr (SIE_DSStreamOut *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSStreamOut_reset (SIE_DSStreamOut *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSStreamOut_check(p,pie,ps8name,hfpErrLOG)		DSStreamOut_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSStreamOut_print(p,    ps8name,hfpErrLOG)		DSStreamOut_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSStreamOut_cmp   (SIE_DSStreamOut *p, SIE_DSStreamOut *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSStreamOut_import(SIE_DSStreamOut *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSStreamOut_export(SIE_DSStreamOut *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSStreamOut
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSStreamOutModule
*	@  HDR
*		%unsigned  16  datBlkPool  0
*						*  *
*						*  The pointer to the memory block pool
*		%unsigned  16  lastDatBlkPtr  0
*						*  *
*						*  The pointer to the current block
*		%unsigned  16  lastDSOutOwner
*						*  *
*						*  The pointer to the current data streamer output FIFO owner
*		%unsigned  16  Reserved
*	@  EV
*		$DSFifo32  evDSFifoOut  0
*						*  *
*						*  The output event FIFO
**********************************************************************************************************************/
#ifdef	h_DSStreamOutModule
#else
#define	h_DSStreamOutModule

#define	\
	AR_DSStreamOutModule \
		6
#define	\
	AB_DSStreamOutModule \
		5

typedef struct SIE_DSStreamOutModule {

	#define	RA_DSStreamOutModule_HDR 	0x00000
	#define	w32DSStreamOutModule_HDR 	{										\
					UNSG32				uHDR_datBlkPool				 : 16;		\
					UNSG32				uHDR_lastDatBlkPtr			 : 16;		\
										}
	/* @'00000 */	union {	UNSG32		u32DSStreamOutModule_HDR;
								struct	w32DSStreamOutModule_HDR;
										};

	/* [15: 0] */	#define	  BA_DSStreamOutModule_HDR_datBlkPool	 0x00000
	/* ---:--- */	#define	    bDSStreamOutModule_HDR_datBlkPool	   16 /*bit*/
	/* ---:--- */	#define	LSb32DSStreamOutModule_HDR_datBlkPool	    0 /*:15*/
	/* ---:--- */	#define	MSK32DSStreamOutModule_HDR_datBlkPool	       0x0000FFFF
	/* ---:--- */	#define	GET32DSStreamOutModule_HDR_datBlkPool(r32)	 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DSStreamOutModule_HDR_datBlkPool(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSStreamOutModule_HDR_datBlkPool(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSStreamOutModule_HDR_datBlkPool(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DSStreamOutModule_HDR_lastDatBlkPtr 0x00002
	/* ---:--- */	#define	    bDSStreamOutModule_HDR_lastDatBlkPtr   16 /*bit*/
	/* ---:--- */	#define	LSb32DSStreamOutModule_HDR_lastDatBlkPtr   16 /*:31*/
	/* ---:--- */	#define	MSK32DSStreamOutModule_HDR_lastDatBlkPtr       0xFFFF0000
	/* ---:--- */	#define	GET32DSStreamOutModule_HDR_lastDatBlkPtr(r32) (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DSStreamOutModule_HDR_lastDatBlkPtr(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSStreamOutModule_HDR_lastDatBlkPtr(r32,v)do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DSStreamOutModule_HDR_lastDatBlkPtr(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DSStreamOutModule_HDR1 	0x00004
	#define	w32DSStreamOutModule_HDR1 	{										\
					UNSG32				uHDR_lastDSOutOwner			 : 16;		\
					UNSG32				uHDR_Reserved				 : 16;		\
										}
	/* @'00004 */	union {	UNSG32		u32DSStreamOutModule_HDR1;
								struct	w32DSStreamOutModule_HDR1;
										};

	/* [15: 0] */	#define	  BA_DSStreamOutModule_HDR_lastDSOutOwner 0x00004
	/* ---:--- */	#define	    bDSStreamOutModule_HDR_lastDSOutOwner   16 /*bit*/
	/* ---:--- */	#define	LSb32DSStreamOutModule_HDR_lastDSOutOwner    0 /*:15*/
	/* ---:--- */	#define	MSK32DSStreamOutModule_HDR_lastDSOutOwner       0x0000FFFF
	/* ---:--- */	#define	GET32DSStreamOutModule_HDR_lastDSOutOwner(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DSStreamOutModule_HDR_lastDSOutOwner(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSStreamOutModule_HDR_lastDSOutOwner(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSStreamOutModule_HDR_lastDSOutOwner(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DSStreamOutModule_HDR_Reserved		 0x00006
	/* ---:--- */	#define	    bDSStreamOutModule_HDR_Reserved		   16 /*bit*/
	/* ---:--- */	#define	LSb32DSStreamOutModule_HDR_Reserved		   16 /*:31*/
	/* ---:--- */	#define	MSK32DSStreamOutModule_HDR_Reserved		       0xFFFF0000
	/* ---:--- */	#define	GET32DSStreamOutModule_HDR_Reserved(r32)	 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DSStreamOutModule_HDR_Reserved(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSStreamOutModule_HDR_Reserved(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DSStreamOutModule_HDR_Reserved(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DSStreamOutModule_EV 	0x00008
	/* @'00008 */	SIE_DSFifo32 				ie_evDSFifoOut;

} SIE_DSStreamOutModule;

	#define	dftDSStreamOutModule_HDR 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DSStreamOutModule_HDR;
										} T32DSStreamOutModule_HDR;
	#define	dftDSStreamOutModule_HDR1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DSStreamOutModule_HDR1;
										} T32DSStreamOutModule_HDR1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSStreamOutModule_drvrd (SIE_DSStreamOutModule *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSStreamOutModule_drvwr (SIE_DSStreamOutModule *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSStreamOutModule_reset (SIE_DSStreamOutModule *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSStreamOutModule_check(p,pie,ps8name,hfpErrLOG)		DSStreamOutModule_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSStreamOutModule_print(p,    ps8name,hfpErrLOG)		DSStreamOutModule_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSStreamOutModule_cmp   (SIE_DSStreamOutModule *p, SIE_DSStreamOutModule *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSStreamOutModule_import(SIE_DSStreamOutModule *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSStreamOutModule_export(SIE_DSStreamOutModule *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSStreamOutModule
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSOutBlkReserved
*	@
*		$FIGOEvent  figoEvent  REG
*	@
*		$UINT32  dsFifoPtr  REG  [4]
*						*  *
*						*  The pointer to the current block
**********************************************************************************************************************/
#ifdef	h_DSOutBlkReserved
#else
#define	h_DSOutBlkReserved

#define	\
	AR_DSOutBlkReserved \
		20
#define	\
	AB_DSOutBlkReserved \
		7

typedef struct SIE_DSOutBlkReserved {

	#define	RA_DSOutBlkReserved_figoEvent 0x00000
	/* @'00000 */	SIE_FIGOEvent 				ie_figoEvent;

	#define	RA_DSOutBlkReserved_dsFifoPtr 0x00040
	/* @'00040 */	SIE_UINT32 					ie_dsFifoPtr		 [4];
					#define	 arr_DSOutBlkReserved_dsFifoPtr 		  4

} SIE_DSOutBlkReserved;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSOutBlkReserved_drvrd (SIE_DSOutBlkReserved *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSOutBlkReserved_drvwr (SIE_DSOutBlkReserved *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSOutBlkReserved_reset (SIE_DSOutBlkReserved *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSOutBlkReserved_check(p,pie,ps8name,hfpErrLOG)		DSOutBlkReserved_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSOutBlkReserved_print(p,    ps8name,hfpErrLOG)		DSOutBlkReserved_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSOutBlkReserved_cmp   (SIE_DSOutBlkReserved *p, SIE_DSOutBlkReserved *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSOutBlkReserved_import(SIE_DSOutBlkReserved *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSOutBlkReserved_export(SIE_DSOutBlkReserved *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSOutBlkReserved
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DTCMStream
*	@  HDR
*		$StreamHdr  hdr  0
*	@  DAT
*		$DTCMFifo  datFifo  CTRL
*		$DTCMFifo  ctrlFifo  0
**********************************************************************************************************************/
#ifdef	h_DTCMStream
#else
#define	h_DTCMStream

#define	\
	AR_DTCMStream \
		6
#define	\
	AB_DTCMStream \
		5

typedef struct SIE_DTCMStream {

	#define	RA_DTCMStream_HDR 			0x00000
	/* @'00000 */	SIE_StreamHdr 				ie_hdr;

	#define	RA_DTCMStream_DAT 			0x00008
	/* @'00008 */	SIE_DTCMFifo 				ie_datFifo;

	#define	RA_DTCMStream_ctrlFifo 		0x00010
	/* @'00010 */	SIE_DTCMFifo 				ie_ctrlFifo;

} SIE_DTCMStream;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DTCMStream_drvrd (SIE_DTCMStream *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DTCMStream_drvwr (SIE_DTCMStream *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DTCMStream_reset (SIE_DTCMStream *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DTCMStream_check(p,pie,ps8name,hfpErrLOG)		DTCMStream_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DTCMStream_print(p,    ps8name,hfpErrLOG)		DTCMStream_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DTCMStream_cmp   (SIE_DTCMStream *p, SIE_DTCMStream *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DTCMStream_import(SIE_DTCMStream *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DTCMStream_export(SIE_DTCMStream *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DTCMStream
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSBlkRetEntry
*	@  DAT
*		%unsigned  16  puAddr  0
*		%unsigned  16  uValue
*		%unsigned  16  nDSCmdID
*		%unsigned  16  nReserved
**********************************************************************************************************************/
#ifdef	h_DSBlkRetEntry
#else
#define	h_DSBlkRetEntry

#define	\
	AR_DSBlkRetEntry \
		2
#define	\
	AB_DSBlkRetEntry \
		3

typedef struct SIE_DSBlkRetEntry {

	#define	RA_DSBlkRetEntry_DAT 		0x00000
	#define	w32DSBlkRetEntry_DAT 		{										\
					UNSG32				uDAT_puAddr					 : 16;		\
					UNSG32				uDAT_uValue					 : 16;		\
										}
	/* @'00000 */	union {	UNSG32		u32DSBlkRetEntry_DAT;
								struct	w32DSBlkRetEntry_DAT;
										};

	/* [15: 0] */	#define	  BA_DSBlkRetEntry_DAT_puAddr			 0x00000
	/* ---:--- */	#define	    bDSBlkRetEntry_DAT_puAddr			   16 /*bit*/
	/* ---:--- */	#define	LSb32DSBlkRetEntry_DAT_puAddr			    0 /*:15*/
	/* ---:--- */	#define	MSK32DSBlkRetEntry_DAT_puAddr			       0x0000FFFF
	/* ---:--- */	#define	GET32DSBlkRetEntry_DAT_puAddr(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DSBlkRetEntry_DAT_puAddr(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSBlkRetEntry_DAT_puAddr(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSBlkRetEntry_DAT_puAddr(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DSBlkRetEntry_DAT_uValue			 0x00002
	/* ---:--- */	#define	    bDSBlkRetEntry_DAT_uValue			   16 /*bit*/
	/* ---:--- */	#define	LSb32DSBlkRetEntry_DAT_uValue			   16 /*:31*/
	/* ---:--- */	#define	MSK32DSBlkRetEntry_DAT_uValue			       0xFFFF0000
	/* ---:--- */	#define	GET32DSBlkRetEntry_DAT_uValue(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DSBlkRetEntry_DAT_uValue(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSBlkRetEntry_DAT_uValue(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DSBlkRetEntry_DAT_uValue(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DSBlkRetEntry_DAT1 		0x00004
	#define	w32DSBlkRetEntry_DAT1 		{										\
					UNSG32				uDAT_nDSCmdID				 : 16;		\
					UNSG32				uDAT_nReserved				 : 16;		\
										}
	/* @'00004 */	union {	UNSG32		u32DSBlkRetEntry_DAT1;
								struct	w32DSBlkRetEntry_DAT1;
										};

	/* [15: 0] */	#define	  BA_DSBlkRetEntry_DAT_nDSCmdID			 0x00004
	/* ---:--- */	#define	    bDSBlkRetEntry_DAT_nDSCmdID			   16 /*bit*/
	/* ---:--- */	#define	LSb32DSBlkRetEntry_DAT_nDSCmdID			    0 /*:15*/
	/* ---:--- */	#define	MSK32DSBlkRetEntry_DAT_nDSCmdID			       0x0000FFFF
	/* ---:--- */	#define	GET32DSBlkRetEntry_DAT_nDSCmdID(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DSBlkRetEntry_DAT_nDSCmdID(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSBlkRetEntry_DAT_nDSCmdID(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSBlkRetEntry_DAT_nDSCmdID(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DSBlkRetEntry_DAT_nReserved		 0x00006
	/* ---:--- */	#define	    bDSBlkRetEntry_DAT_nReserved		   16 /*bit*/
	/* ---:--- */	#define	LSb32DSBlkRetEntry_DAT_nReserved		   16 /*:31*/
	/* ---:--- */	#define	MSK32DSBlkRetEntry_DAT_nReserved		       0xFFFF0000
	/* ---:--- */	#define	GET32DSBlkRetEntry_DAT_nReserved(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DSBlkRetEntry_DAT_nReserved(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSBlkRetEntry_DAT_nReserved(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DSBlkRetEntry_DAT_nReserved(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_DSBlkRetEntry;

	#define	dftDSBlkRetEntry_DAT 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DSBlkRetEntry_DAT;
										} T32DSBlkRetEntry_DAT;
	#define	dftDSBlkRetEntry_DAT1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DSBlkRetEntry_DAT1;
										} T32DSBlkRetEntry_DAT1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSBlkRetEntry_drvrd (SIE_DSBlkRetEntry *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSBlkRetEntry_drvwr (SIE_DSBlkRetEntry *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSBlkRetEntry_reset (SIE_DSBlkRetEntry *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSBlkRetEntry_check(p,pie,ps8name,hfpErrLOG)		DSBlkRetEntry_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSBlkRetEntry_print(p,    ps8name,hfpErrLOG)		DSBlkRetEntry_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSBlkRetEntry_cmp   (SIE_DSBlkRetEntry *p, SIE_DSBlkRetEntry *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSBlkRetEntry_import(SIE_DSBlkRetEntry *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSBlkRetEntry_export(SIE_DSBlkRetEntry *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSBlkRetEntry
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSBlkRetQ
*	@  HDR
*		%unsigned  16  nRdOffset  REG
*		%unsigned  16  nWrOffset
*		%unsigned  32  nReserved32
*	@  DAT
*		$DSBlkRetEntry  entryList  REG  [16]
**********************************************************************************************************************/
#ifdef	h_DSBlkRetQ
#else
#define	h_DSBlkRetQ

#define	\
	AR_DSBlkRetQ \
		34
#define	\
	AB_DSBlkRetQ \
		8

typedef struct SIE_DSBlkRetQ {

	#define	RA_DSBlkRetQ_HDR 			0x00000
	#define	w32DSBlkRetQ_HDR 			{										\
					UNSG32				uHDR_nRdOffset				 : 16;		\
					UNSG32				uHDR_nWrOffset				 : 16;		\
										}
	/* @'00000 */	union {	UNSG32		u32DSBlkRetQ_HDR;
								struct	w32DSBlkRetQ_HDR;
										};

	/* [15: 0] */	#define	  BA_DSBlkRetQ_HDR_nRdOffset			 0x00000
	/* ---:--- */	#define	    bDSBlkRetQ_HDR_nRdOffset			   16 /*bit*/
	/* ---:--- */	#define	LSb32DSBlkRetQ_HDR_nRdOffset			    0 /*:15*/
	/* ---:--- */	#define	MSK32DSBlkRetQ_HDR_nRdOffset			       0x0000FFFF
	/* ---:--- */	#define	GET32DSBlkRetQ_HDR_nRdOffset(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DSBlkRetQ_HDR_nRdOffset(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSBlkRetQ_HDR_nRdOffset(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSBlkRetQ_HDR_nRdOffset(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DSBlkRetQ_HDR_nWrOffset			 0x00002
	/* ---:--- */	#define	    bDSBlkRetQ_HDR_nWrOffset			   16 /*bit*/
	/* ---:--- */	#define	LSb32DSBlkRetQ_HDR_nWrOffset			   16 /*:31*/
	/* ---:--- */	#define	MSK32DSBlkRetQ_HDR_nWrOffset			       0xFFFF0000
	/* ---:--- */	#define	GET32DSBlkRetQ_HDR_nWrOffset(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DSBlkRetQ_HDR_nWrOffset(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSBlkRetQ_HDR_nWrOffset(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DSBlkRetQ_HDR_nWrOffset(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DSBlkRetQ_HDR1 			0x00004
	#define	w32DSBlkRetQ_HDR1 			{										\
					UNSG32				uHDR_nReserved32			 : 32;		\
										}
	/* @'00004 */	union {	UNSG32		u32DSBlkRetQ_HDR1;
								struct	w32DSBlkRetQ_HDR1;
										};

	/* [31: 0] */	#define	  BA_DSBlkRetQ_HDR_nReserved32			 0x00004
	/* ---:--- */	#define	    bDSBlkRetQ_HDR_nReserved32			   32 /*bit*/
	/* ---:--- */	#define	LSb32DSBlkRetQ_HDR_nReserved32			    0 /*:31*/
	/* ---:--- */	#define	MSK32DSBlkRetQ_HDR_nReserved32			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSBlkRetQ_HDR_nReserved32(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSBlkRetQ_HDR_nReserved32(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSBlkRetQ_HDR_nReserved32(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSBlkRetQ_HDR_nReserved32(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DSBlkRetQ_DAT 			0x00008
	/* @'00008 */	SIE_DSBlkRetEntry 			ie_entryList		 [16];
					#define	 arr_DSBlkRetQ_entryList 				  16

} SIE_DSBlkRetQ;

	#define	dftDSBlkRetQ_HDR 			0x0000CCCC
			typedef	union {	UNSG32		u32;
								struct	w32DSBlkRetQ_HDR;
										} T32DSBlkRetQ_HDR;
	#define	dftDSBlkRetQ_HDR1 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DSBlkRetQ_HDR1;
										} T32DSBlkRetQ_HDR1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSBlkRetQ_drvrd (SIE_DSBlkRetQ *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSBlkRetQ_drvwr (SIE_DSBlkRetQ *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSBlkRetQ_reset (SIE_DSBlkRetQ *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSBlkRetQ_check(p,pie,ps8name,hfpErrLOG)		DSBlkRetQ_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSBlkRetQ_print(p,    ps8name,hfpErrLOG)		DSBlkRetQ_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSBlkRetQ_cmp   (SIE_DSBlkRetQ *p, SIE_DSBlkRetQ *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSBlkRetQ_import(SIE_DSBlkRetQ *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSBlkRetQ_export(SIE_DSBlkRetQ *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSBlkRetQ
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: StallCmd
*	@  CMD
*		%unsigned  16  cmdTag  0
*			:  RUN  1
*			:  STALL  2
*			:  JUMPTOROM  0
*	@  RSP
*		%unsigned  16  rspTag  0
**********************************************************************************************************************/
#ifdef	h_StallCmd
#else
#define	h_StallCmd

#define	\
	AR_StallCmd \
		2
#define	\
	AB_StallCmd \
		3

typedef struct SIE_StallCmd {

	#define	RA_StallCmd_CMD 			0x00000
	#define	w32StallCmd_CMD 			{										\
					UNSG32				uCMD_cmdTag					 : 16;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */	union {	UNSG32		u32StallCmd_CMD;
								struct	w32StallCmd_CMD;
										};

	/* [15: 0] */	#define	  BA_StallCmd_CMD_cmdTag				 0x00000
	/* ---:--- */	#define	    bStallCmd_CMD_cmdTag				   16 /*bit*/
	/* ---:--- */	#define	LSb32StallCmd_CMD_cmdTag				    0 /*:15*/
	/* ---:--- */	#define	MSK32StallCmd_CMD_cmdTag				       0x0000FFFF
	/* ---:--- */	#define	GET32StallCmd_CMD_cmdTag(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16StallCmd_CMD_cmdTag(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32StallCmd_CMD_cmdTag(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16StallCmd_CMD_cmdTag(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)
					#define	     StallCmd_CMD_cmdTag_RUN					0x1
					#define	     StallCmd_CMD_cmdTag_STALL					0x2
					#define	     StallCmd_CMD_cmdTag_JUMPTOROM				0x0

	#define	RA_StallCmd_RSP 			0x00004
	#define	w32StallCmd_RSP 			{										\
					UNSG32				uRSP_rspTag					 : 16;		\
					UNSG32				_x00004	: 16;							\
										}
	/* @'00004 */	union {	UNSG32		u32StallCmd_RSP;
								struct	w32StallCmd_RSP;
										};

	/* [15: 0] */	#define	  BA_StallCmd_RSP_rspTag				 0x00004
	/* ---:--- */	#define	    bStallCmd_RSP_rspTag				   16 /*bit*/
	/* ---:--- */	#define	LSb32StallCmd_RSP_rspTag				    0 /*:15*/
	/* ---:--- */	#define	MSK32StallCmd_RSP_rspTag				       0x0000FFFF
	/* ---:--- */	#define	GET32StallCmd_RSP_rspTag(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16StallCmd_RSP_rspTag(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32StallCmd_RSP_rspTag(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16StallCmd_RSP_rspTag(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_StallCmd;

	#define	dftStallCmd_CMD 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32StallCmd_CMD;
										} T32StallCmd_CMD;
	#define	dftStallCmd_RSP 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32StallCmd_RSP;
										} T32StallCmd_RSP;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	StallCmd_drvrd (SIE_StallCmd *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	StallCmd_drvwr (SIE_StallCmd *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	StallCmd_reset (SIE_StallCmd *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	StallCmd_check(p,pie,ps8name,hfpErrLOG)		StallCmd_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	StallCmd_print(p,    ps8name,hfpErrLOG)		StallCmd_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	StallCmd_cmp   (SIE_StallCmd *p, SIE_StallCmd *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	StallCmd_import(SIE_StallCmd *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	StallCmd_export(SIE_StallCmd *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: StallCmd
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: LocalArea
*	@
*		%unsigned  16  uDsCmdIdRet  REG
*						*  *Data streamer retired command ID
*	@
*		%unsigned  32  nDSBase  REG
*	@
*		%unsigned  16  uNextDsCmdId  REG
*						*  *Next data streamer command ID
*	@  BRKCFG
*		%unsigned  1  uDisableBreakPoint  REG
*						*  *
*		$StallCmd  stallCmd  REG
*						*  *
*	@  DSRETQ
*		$DSBlkRetQ  retQ  REG
*	@  REGDUMP
*		$UINT64  regDumpArea  REG  [32]
*						*  *
*						*  Registers Dumping Area for debug purpose
*	@  IMGBASE
*		%unsigned  32  uDDRImgBase  REG
*						*  *
*						*  32 DDR Base of the shadow image
*		%unsigned  32  uReserved  REG
*						*  *
*						*  Reserved bits
*	@
*		$DTCMFifo  hboFifoList  REG  [16]
*						*  *
*						*  HBO Fifo Pointer Information
**********************************************************************************************************************/
#ifdef	h_LocalArea
#else
#define	h_LocalArea

#define	\
	AR_LocalArea \
		138
#define	\
	AB_LocalArea \
		10

typedef struct SIE_LocalArea {

	#define	RA_LocalArea_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32LocalArea_D0th_ 			{										\
					UNSG32				u_uDsCmdIdRet				 : 16;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32LocalArea_D0th_;

	/* [15: 0] */	#define	  BA_LocalArea_uDsCmdIdRet				 0x00000
	/* ---:--- */	#define	    bLocalArea_uDsCmdIdRet				   16 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_uDsCmdIdRet				    0 /*:15*/
	/* ---:--- */	#define	MSK32LocalArea_uDsCmdIdRet				       0x0000FFFF
	/* ---:--- */	#define	GET32LocalArea_uDsCmdIdRet(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16LocalArea_uDsCmdIdRet(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32LocalArea_uDsCmdIdRet(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_uDsCmdIdRet(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_LocalArea_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32LocalArea_D1th_ 			{										\
					UNSG32				u_nDSBase					 : 32;		\
										}
	/* @'00004 */				struct	w32LocalArea_D1th_;

	/* [31: 0] */	#define	  BA_LocalArea_nDSBase					 0x00004
	/* ---:--- */	#define	    bLocalArea_nDSBase					   32 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_nDSBase					    0 /*:31*/
	/* ---:--- */	#define	MSK32LocalArea_nDSBase					       0xFFFFFFFF
	/* ---:--- */	#define	GET32LocalArea_nDSBase(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LocalArea_nDSBase(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LocalArea_nDSBase(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_nDSBase(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LocalArea_D2th_ 			ISC_USE_ONLY	0x00008
	#define	w32LocalArea_D2th_ 			{										\
					UNSG32				u_uNextDsCmdId				 : 16;		\
					UNSG32				_x00008	: 16;							\
										}
	/* @'00008 */				struct	w32LocalArea_D2th_;

	/* [15: 0] */	#define	  BA_LocalArea_uNextDsCmdId				 0x00008
	/* ---:--- */	#define	    bLocalArea_uNextDsCmdId				   16 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_uNextDsCmdId				    0 /*:15*/
	/* ---:--- */	#define	MSK32LocalArea_uNextDsCmdId				       0x0000FFFF
	/* ---:--- */	#define	GET32LocalArea_uNextDsCmdId(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16LocalArea_uNextDsCmdId(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32LocalArea_uNextDsCmdId(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_uNextDsCmdId(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_LocalArea_BRKCFG 		0x0000C
	#define	w32LocalArea_BRKCFG 		{										\
					UNSG32				uBRKCFG_uDisableBreakPoint	 :  1;		\
					UNSG32				_x0000C	: 31;							\
										}
	/* @'0000C */	union {	UNSG32		u32LocalArea_BRKCFG;
								struct	w32LocalArea_BRKCFG;
										};

	/* [ 0: 0] */	#define	  BA_LocalArea_BRKCFG_uDisableBreakPoint 0x0000C
	/* ---:--- */	#define	    bLocalArea_BRKCFG_uDisableBreakPoint    1 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_BRKCFG_uDisableBreakPoint    0 /*: 0*/
	/* ---:--- */	#define	MSK32LocalArea_BRKCFG_uDisableBreakPoint       0x00000001
	/* ---:--- */	#define	GET32LocalArea_BRKCFG_uDisableBreakPoint(r32) (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16LocalArea_BRKCFG_uDisableBreakPoint(r16) (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32LocalArea_BRKCFG_uDisableBreakPoint(r32,v)do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_BRKCFG_uDisableBreakPoint(r16,v)do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	#define	RA_LocalArea_stallCmd 		0x00010
	/* @'00010 */	SIE_StallCmd 				ie_stallCmd;

	#define	RA_LocalArea_DSRETQ 		0x00018
	/* @'00018 */	SIE_DSBlkRetQ 				ie_retQ;

	#define	RA_LocalArea_REGDUMP 		0x000A0
	/* @'000A0 */	SIE_UINT64 					ie_regDumpArea		 [32];
					#define	 arr_LocalArea_regDumpArea 				  32

	#define	RA_LocalArea_IMGBASE 		0x001A0
	#define	w32LocalArea_IMGBASE 		{										\
					UNSG32				uIMGBASE_uDDRImgBase		 : 32;		\
										}
	/* @'001A0 */	union {	UNSG32		u32LocalArea_IMGBASE;
								struct	w32LocalArea_IMGBASE;
										};

	/* [31: 0] */	#define	  BA_LocalArea_IMGBASE_uDDRImgBase		 0x001A0
	/* ---:--- */	#define	    bLocalArea_IMGBASE_uDDRImgBase		   32 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_IMGBASE_uDDRImgBase		    0 /*:31*/
	/* ---:--- */	#define	MSK32LocalArea_IMGBASE_uDDRImgBase		       0xFFFFFFFF
	/* ---:--- */	#define	GET32LocalArea_IMGBASE_uDDRImgBase(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LocalArea_IMGBASE_uDDRImgBase(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LocalArea_IMGBASE_uDDRImgBase(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_IMGBASE_uDDRImgBase(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LocalArea_IMGBASE1 		0x001A4
	#define	w32LocalArea_IMGBASE1 		{										\
					UNSG32				uIMGBASE_uReserved			 : 32;		\
										}
	/* @'001A4 */	union {	UNSG32		u32LocalArea_IMGBASE1;
								struct	w32LocalArea_IMGBASE1;
										};

	/* [31: 0] */	#define	  BA_LocalArea_IMGBASE_uReserved		 0x001A4
	/* ---:--- */	#define	    bLocalArea_IMGBASE_uReserved		   32 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_IMGBASE_uReserved		    0 /*:31*/
	/* ---:--- */	#define	MSK32LocalArea_IMGBASE_uReserved		       0xFFFFFFFF
	/* ---:--- */	#define	GET32LocalArea_IMGBASE_uReserved(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LocalArea_IMGBASE_uReserved(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LocalArea_IMGBASE_uReserved(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_IMGBASE_uReserved(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LocalArea_hboFifoList 	0x001A8
	/* @'001A8 */	SIE_DTCMFifo 				ie_hboFifoList		 [16];
					#define	 arr_LocalArea_hboFifoList 				  16

} SIE_LocalArea;

	#define	dftLocalArea_BRKCFG 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LocalArea_BRKCFG;
										} T32LocalArea_BRKCFG;
	#define	dftLocalArea_IMGBASE 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LocalArea_IMGBASE;
										} T32LocalArea_IMGBASE;
	#define	dftLocalArea_IMGBASE1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LocalArea_IMGBASE1;
										} T32LocalArea_IMGBASE1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	LocalArea_drvrd (SIE_LocalArea *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	LocalArea_drvwr (SIE_LocalArea *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	LocalArea_reset (SIE_LocalArea *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	LocalArea_check(p,pie,ps8name,hfpErrLOG)		LocalArea_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	LocalArea_print(p,    ps8name,hfpErrLOG)		LocalArea_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	LocalArea_cmp   (SIE_LocalArea *p, SIE_LocalArea *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	LocalArea_import(SIE_LocalArea *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	LocalArea_export(SIE_LocalArea *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: LocalArea
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: LACryptoCmdCnt
*	@  Local
*		%unsigned  32  uLocalCmdCnt  0
*		%unsigned  32  pad0  0
*	@  RegSyn
*		%unsigned  32  uCryptoEngineUpdateCnt  0
*		%unsigned  32  pad1  0
**********************************************************************************************************************/
#ifdef	h_LACryptoCmdCnt
#else
#define	h_LACryptoCmdCnt

#define	\
	AR_LACryptoCmdCnt \
		4
#define	\
	AB_LACryptoCmdCnt \
		4

typedef struct SIE_LACryptoCmdCnt {

	#define	RA_LACryptoCmdCnt_Local 	0x00000
	#define	w32LACryptoCmdCnt_Local 	{										\
					UNSG32				uLocal_uLocalCmdCnt			 : 32;		\
										}
	/* @'00000 */	union {	UNSG32		u32LACryptoCmdCnt_Local;
								struct	w32LACryptoCmdCnt_Local;
										};

	/* [31: 0] */	#define	  BA_LACryptoCmdCnt_Local_uLocalCmdCnt	 0x00000
	/* ---:--- */	#define	    bLACryptoCmdCnt_Local_uLocalCmdCnt	   32 /*bit*/
	/* ---:--- */	#define	LSb32LACryptoCmdCnt_Local_uLocalCmdCnt	    0 /*:31*/
	/* ---:--- */	#define	MSK32LACryptoCmdCnt_Local_uLocalCmdCnt	       0xFFFFFFFF
	/* ---:--- */	#define	GET32LACryptoCmdCnt_Local_uLocalCmdCnt(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LACryptoCmdCnt_Local_uLocalCmdCnt(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LACryptoCmdCnt_Local_uLocalCmdCnt(r32,v)do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LACryptoCmdCnt_Local_uLocalCmdCnt(r16,v)do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LACryptoCmdCnt_Local1 	0x00004
	#define	w32LACryptoCmdCnt_Local1 	{										\
					UNSG32				uLocal_pad0					 : 32;		\
										}
	/* @'00004 */	union {	UNSG32		u32LACryptoCmdCnt_Local1;
								struct	w32LACryptoCmdCnt_Local1;
										};

	/* [31: 0] */	#define	  BA_LACryptoCmdCnt_Local_pad0			 0x00004
	/* ---:--- */	#define	    bLACryptoCmdCnt_Local_pad0			   32 /*bit*/
	/* ---:--- */	#define	LSb32LACryptoCmdCnt_Local_pad0			    0 /*:31*/
	/* ---:--- */	#define	MSK32LACryptoCmdCnt_Local_pad0			       0xFFFFFFFF
	/* ---:--- */	#define	GET32LACryptoCmdCnt_Local_pad0(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LACryptoCmdCnt_Local_pad0(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LACryptoCmdCnt_Local_pad0(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LACryptoCmdCnt_Local_pad0(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LACryptoCmdCnt_RegSyn 	0x00008
	#define	w32LACryptoCmdCnt_RegSyn 	{										\
					UNSG32				uRegSyn_uCryptoEngineUpdateCnt : 32;		\
										}
	/* @'00008 */	union {	UNSG32		u32LACryptoCmdCnt_RegSyn;
								struct	w32LACryptoCmdCnt_RegSyn;
										};

	/* [31: 0] */	#define	  BA_LACryptoCmdCnt_RegSyn_uCryptoEngineUpdateCnt 0x00008
	/* ---:--- */	#define	    bLACryptoCmdCnt_RegSyn_uCryptoEngineUpdateCnt   32 /*bit*/
	/* ---:--- */	#define	LSb32LACryptoCmdCnt_RegSyn_uCryptoEngineUpdateCnt    0 /*:31*/
	/* ---:--- */	#define	MSK32LACryptoCmdCnt_RegSyn_uCryptoEngineUpdateCnt       0xFFFFFFFF
	/* ---:--- */	#define	GET32LACryptoCmdCnt_RegSyn_uCryptoEngineUpdateCnt(r32) (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LACryptoCmdCnt_RegSyn_uCryptoEngineUpdateCnt(r16) (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LACryptoCmdCnt_RegSyn_uCryptoEngineUpdateCnt(r32,v)do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LACryptoCmdCnt_RegSyn_uCryptoEngineUpdateCnt(r16,v)do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LACryptoCmdCnt_RegSyn1 	0x0000C
	#define	w32LACryptoCmdCnt_RegSyn1 	{										\
					UNSG32				uRegSyn_pad1				 : 32;		\
										}
	/* @'0000C */	union {	UNSG32		u32LACryptoCmdCnt_RegSyn1;
								struct	w32LACryptoCmdCnt_RegSyn1;
										};

	/* [31: 0] */	#define	  BA_LACryptoCmdCnt_RegSyn_pad1			 0x0000C
	/* ---:--- */	#define	    bLACryptoCmdCnt_RegSyn_pad1			   32 /*bit*/
	/* ---:--- */	#define	LSb32LACryptoCmdCnt_RegSyn_pad1			    0 /*:31*/
	/* ---:--- */	#define	MSK32LACryptoCmdCnt_RegSyn_pad1			       0xFFFFFFFF
	/* ---:--- */	#define	GET32LACryptoCmdCnt_RegSyn_pad1(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LACryptoCmdCnt_RegSyn_pad1(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LACryptoCmdCnt_RegSyn_pad1(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LACryptoCmdCnt_RegSyn_pad1(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_LACryptoCmdCnt;

	#define	dftLACryptoCmdCnt_Local 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LACryptoCmdCnt_Local;
										} T32LACryptoCmdCnt_Local;
	#define	dftLACryptoCmdCnt_Local1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LACryptoCmdCnt_Local1;
										} T32LACryptoCmdCnt_Local1;
	#define	dftLACryptoCmdCnt_RegSyn 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LACryptoCmdCnt_RegSyn;
										} T32LACryptoCmdCnt_RegSyn;
	#define	dftLACryptoCmdCnt_RegSyn1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LACryptoCmdCnt_RegSyn1;
										} T32LACryptoCmdCnt_RegSyn1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	LACryptoCmdCnt_drvrd (SIE_LACryptoCmdCnt *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	LACryptoCmdCnt_drvwr (SIE_LACryptoCmdCnt *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	LACryptoCmdCnt_reset (SIE_LACryptoCmdCnt *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	LACryptoCmdCnt_check(p,pie,ps8name,hfpErrLOG)		LACryptoCmdCnt_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	LACryptoCmdCnt_print(p,    ps8name,hfpErrLOG)		LACryptoCmdCnt_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	LACryptoCmdCnt_cmp   (SIE_LACryptoCmdCnt *p, SIE_LACryptoCmdCnt *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	LACryptoCmdCnt_import(SIE_LACryptoCmdCnt *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	LACryptoCmdCnt_export(SIE_LACryptoCmdCnt *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: LACryptoCmdCnt
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: LocalArea_Ext
*	@
*		%unsigned  16  uDsCmdIdRet  REG
*						*  *Data streamer retired command ID
*	@
*		%unsigned  32  nDSBase  REG
*	@
*		%unsigned  16  uNextDsCmdId  REG
*						*  *Next data streamer command ID
*	@  BRKCFG
*		%unsigned  1  uDisableBreakPoint  REG
*						*  *
*		$StallCmd  stallCmd  REG
*						*  *
*	@  DSRETQ
*		$DSBlkRetQ  retQ  REG
*	@  REGDUMP
*		$UINT64  regDumpArea  REG  [32]
*						*  *
*						*  Registers Dumping Area for debug purpose
*	@  IMGBASE
*		%unsigned  32  uDDRImgBase  REG
*						*  *
*						*  32 DDR Base of the shadow image
*		%unsigned  32  uReserved  REG
*						*  *
*						*  Reserved bits
*	@
*		$DTCMFifo  hboFifoList  REG  [24]
*						*  *
*						*  HBO Fifo Pointer Information
*	@  CryEngine
*		$LACryptoCmdCnt  CryptoRtn  REG  [3]
*						*  *
*						*  CMD count for crypto engine
**********************************************************************************************************************/
#ifdef	h_LocalArea_Ext
#else
#define	h_LocalArea_Ext

#define	\
	AR_LocalArea_Ext \
		166
#define	\
	AB_LocalArea_Ext \
		10

typedef struct SIE_LocalArea_Ext {

	#define	RA_LocalArea_Ext_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32LocalArea_Ext_D0th_ 		{										\
					UNSG32				u_uDsCmdIdRet				 : 16;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32LocalArea_Ext_D0th_;

	/* [15: 0] */	#define	  BA_LocalArea_Ext_uDsCmdIdRet			 0x00000
	/* ---:--- */	#define	    bLocalArea_Ext_uDsCmdIdRet			   16 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_Ext_uDsCmdIdRet			    0 /*:15*/
	/* ---:--- */	#define	MSK32LocalArea_Ext_uDsCmdIdRet			       0x0000FFFF
	/* ---:--- */	#define	GET32LocalArea_Ext_uDsCmdIdRet(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16LocalArea_Ext_uDsCmdIdRet(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32LocalArea_Ext_uDsCmdIdRet(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_Ext_uDsCmdIdRet(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_LocalArea_Ext_D1th_ 		ISC_USE_ONLY	0x00004
	#define	w32LocalArea_Ext_D1th_ 		{										\
					UNSG32				u_nDSBase					 : 32;		\
										}
	/* @'00004 */				struct	w32LocalArea_Ext_D1th_;

	/* [31: 0] */	#define	  BA_LocalArea_Ext_nDSBase				 0x00004
	/* ---:--- */	#define	    bLocalArea_Ext_nDSBase				   32 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_Ext_nDSBase				    0 /*:31*/
	/* ---:--- */	#define	MSK32LocalArea_Ext_nDSBase				       0xFFFFFFFF
	/* ---:--- */	#define	GET32LocalArea_Ext_nDSBase(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LocalArea_Ext_nDSBase(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LocalArea_Ext_nDSBase(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_Ext_nDSBase(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LocalArea_Ext_D2th_ 		ISC_USE_ONLY	0x00008
	#define	w32LocalArea_Ext_D2th_ 		{										\
					UNSG32				u_uNextDsCmdId				 : 16;		\
					UNSG32				_x00008	: 16;							\
										}
	/* @'00008 */				struct	w32LocalArea_Ext_D2th_;

	/* [15: 0] */	#define	  BA_LocalArea_Ext_uNextDsCmdId			 0x00008
	/* ---:--- */	#define	    bLocalArea_Ext_uNextDsCmdId			   16 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_Ext_uNextDsCmdId			    0 /*:15*/
	/* ---:--- */	#define	MSK32LocalArea_Ext_uNextDsCmdId			       0x0000FFFF
	/* ---:--- */	#define	GET32LocalArea_Ext_uNextDsCmdId(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16LocalArea_Ext_uNextDsCmdId(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32LocalArea_Ext_uNextDsCmdId(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_Ext_uNextDsCmdId(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_LocalArea_Ext_BRKCFG 	0x0000C
	#define	w32LocalArea_Ext_BRKCFG 	{										\
					UNSG32				uBRKCFG_uDisableBreakPoint	 :  1;		\
					UNSG32				_x0000C	: 31;							\
										}
	/* @'0000C */	union {	UNSG32		u32LocalArea_Ext_BRKCFG;
								struct	w32LocalArea_Ext_BRKCFG;
										};

	/* [ 0: 0] */	#define	  BA_LocalArea_Ext_BRKCFG_uDisableBreakPoint 0x0000C
	/* ---:--- */	#define	    bLocalArea_Ext_BRKCFG_uDisableBreakPoint    1 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_Ext_BRKCFG_uDisableBreakPoint    0 /*: 0*/
	/* ---:--- */	#define	MSK32LocalArea_Ext_BRKCFG_uDisableBreakPoint       0x00000001
	/* ---:--- */	#define	GET32LocalArea_Ext_BRKCFG_uDisableBreakPoint(r32) (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16LocalArea_Ext_BRKCFG_uDisableBreakPoint(r16) (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32LocalArea_Ext_BRKCFG_uDisableBreakPoint(r32,v)do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_Ext_BRKCFG_uDisableBreakPoint(r16,v)do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	#define	RA_LocalArea_Ext_stallCmd 	0x00010
	/* @'00010 */	SIE_StallCmd 				ie_stallCmd;

	#define	RA_LocalArea_Ext_DSRETQ 	0x00018
	/* @'00018 */	SIE_DSBlkRetQ 				ie_retQ;

	#define	RA_LocalArea_Ext_REGDUMP 	0x000A0
	/* @'000A0 */	SIE_UINT64 					ie_regDumpArea		 [32];
					#define	 arr_LocalArea_Ext_regDumpArea 			  32

	#define	RA_LocalArea_Ext_IMGBASE 	0x001A0
	#define	w32LocalArea_Ext_IMGBASE 	{										\
					UNSG32				uIMGBASE_uDDRImgBase		 : 32;		\
										}
	/* @'001A0 */	union {	UNSG32		u32LocalArea_Ext_IMGBASE;
								struct	w32LocalArea_Ext_IMGBASE;
										};

	/* [31: 0] */	#define	  BA_LocalArea_Ext_IMGBASE_uDDRImgBase	 0x001A0
	/* ---:--- */	#define	    bLocalArea_Ext_IMGBASE_uDDRImgBase	   32 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_Ext_IMGBASE_uDDRImgBase	    0 /*:31*/
	/* ---:--- */	#define	MSK32LocalArea_Ext_IMGBASE_uDDRImgBase	       0xFFFFFFFF
	/* ---:--- */	#define	GET32LocalArea_Ext_IMGBASE_uDDRImgBase(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LocalArea_Ext_IMGBASE_uDDRImgBase(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LocalArea_Ext_IMGBASE_uDDRImgBase(r32,v)do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_Ext_IMGBASE_uDDRImgBase(r16,v)do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LocalArea_Ext_IMGBASE1 	0x001A4
	#define	w32LocalArea_Ext_IMGBASE1 	{										\
					UNSG32				uIMGBASE_uReserved			 : 32;		\
										}
	/* @'001A4 */	union {	UNSG32		u32LocalArea_Ext_IMGBASE1;
								struct	w32LocalArea_Ext_IMGBASE1;
										};

	/* [31: 0] */	#define	  BA_LocalArea_Ext_IMGBASE_uReserved	 0x001A4
	/* ---:--- */	#define	    bLocalArea_Ext_IMGBASE_uReserved	   32 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_Ext_IMGBASE_uReserved	    0 /*:31*/
	/* ---:--- */	#define	MSK32LocalArea_Ext_IMGBASE_uReserved	       0xFFFFFFFF
	/* ---:--- */	#define	GET32LocalArea_Ext_IMGBASE_uReserved(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16LocalArea_Ext_IMGBASE_uReserved(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32LocalArea_Ext_IMGBASE_uReserved(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_Ext_IMGBASE_uReserved(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_LocalArea_Ext_hboFifoList 0x001A8
	/* @'001A8 */	SIE_DTCMFifo 				ie_hboFifoList		 [24];
					#define	 arr_LocalArea_Ext_hboFifoList 			  24

	#define	RA_LocalArea_Ext_CryEngine 	0x00268
	/* @'00268 */	SIE_LACryptoCmdCnt 			ie_CryptoRtn		 [3];
					#define	 arr_LocalArea_Ext_CryptoRtn 			  3

} SIE_LocalArea_Ext;

	#define	dftLocalArea_Ext_BRKCFG 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LocalArea_Ext_BRKCFG;
										} T32LocalArea_Ext_BRKCFG;
	#define	dftLocalArea_Ext_IMGBASE 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LocalArea_Ext_IMGBASE;
										} T32LocalArea_Ext_IMGBASE;
	#define	dftLocalArea_Ext_IMGBASE1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32LocalArea_Ext_IMGBASE1;
										} T32LocalArea_Ext_IMGBASE1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	LocalArea_Ext_drvrd (SIE_LocalArea_Ext *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	LocalArea_Ext_drvwr (SIE_LocalArea_Ext *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	LocalArea_Ext_reset (SIE_LocalArea_Ext *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	LocalArea_Ext_check(p,pie,ps8name,hfpErrLOG)		LocalArea_Ext_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	LocalArea_Ext_print(p,    ps8name,hfpErrLOG)		LocalArea_Ext_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	LocalArea_Ext_cmp   (SIE_LocalArea_Ext *p, SIE_LocalArea_Ext *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	LocalArea_Ext_import(SIE_LocalArea_Ext *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	LocalArea_Ext_export(SIE_LocalArea_Ext *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: LocalArea_Ext
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: OTP_PRV_KEY
*	@
*		$UINT128  rsaPubKey  REG  [4]
*						*  *
*						*  512 bits RSA Public Key Data.
*	@
*		$UINT128  rsaMod  REG  [8]
*						*  *
*						*  1024 bits RSA Modulus Data
**********************************************************************************************************************/
#ifdef	h_OTP_PRV_KEY
#else
#define	h_OTP_PRV_KEY

#define	\
	AR_OTP_PRV_KEY \
		48
#define	\
	AB_OTP_PRV_KEY \
		8

typedef struct SIE_OTP_PRV_KEY {

	#define	RA_OTP_PRV_KEY_rsaPubKey 	0x00000
	/* @'00000 */	SIE_UINT128 				ie_rsaPubKey		 [4];
					#define	 arr_OTP_PRV_KEY_rsaPubKey 				  4

	#define	RA_OTP_PRV_KEY_rsaMod 		0x00040
	/* @'00040 */	SIE_UINT128 				ie_rsaMod			 [8];
					#define	 arr_OTP_PRV_KEY_rsaMod 				  8

} SIE_OTP_PRV_KEY;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	OTP_PRV_KEY_drvrd (SIE_OTP_PRV_KEY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	OTP_PRV_KEY_drvwr (SIE_OTP_PRV_KEY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	OTP_PRV_KEY_reset (SIE_OTP_PRV_KEY *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	OTP_PRV_KEY_check(p,pie,ps8name,hfpErrLOG)		OTP_PRV_KEY_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	OTP_PRV_KEY_print(p,    ps8name,hfpErrLOG)		OTP_PRV_KEY_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	OTP_PRV_KEY_cmp   (SIE_OTP_PRV_KEY *p, SIE_OTP_PRV_KEY *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	OTP_PRV_KEY_import(SIE_OTP_PRV_KEY *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	OTP_PRV_KEY_export(SIE_OTP_PRV_KEY *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: OTP_PRV_KEY
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: OTP_CRC32
*	@
*		%unsigned  32  prvkCrc32
*						*  *
*						*  CRC32 value of Private Key Data region
*	@
*		%unsigned  32  rkekCrc32
*						*  *
*						*  CRC32 value of RKEK Key Data region
*	@
*		%unsigned  32  aeskCrc32
*						*  *
*						*  CRC32 value of AES Key Data region
*	@
*		%unsigned  32  reserved
**********************************************************************************************************************/
#ifdef	h_OTP_CRC32
#else
#define	h_OTP_CRC32

#define	\
	AR_OTP_CRC32 \
		4
#define	\
	AB_OTP_CRC32 \
		4

typedef struct SIE_OTP_CRC32 {

	#define	RA_OTP_CRC32_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32OTP_CRC32_D0th_ 			{										\
					UNSG32				u_prvkCrc32					 : 32;		\
										}
	/* @'00000 */				struct	w32OTP_CRC32_D0th_;

	/* [31: 0] */	#define	  BA_OTP_CRC32_prvkCrc32				 0x00000
	/* ---:--- */	#define	    bOTP_CRC32_prvkCrc32				   32 /*bit*/
	/* ---:--- */	#define	LSb32OTP_CRC32_prvkCrc32				    0 /*:31*/
	/* ---:--- */	#define	MSK32OTP_CRC32_prvkCrc32				       0xFFFFFFFF
	/* ---:--- */	#define	GET32OTP_CRC32_prvkCrc32(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16OTP_CRC32_prvkCrc32(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32OTP_CRC32_prvkCrc32(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_CRC32_prvkCrc32(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_OTP_CRC32_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32OTP_CRC32_D1th_ 			{										\
					UNSG32				u_rkekCrc32					 : 32;		\
										}
	/* @'00004 */				struct	w32OTP_CRC32_D1th_;

	/* [31: 0] */	#define	  BA_OTP_CRC32_rkekCrc32				 0x00004
	/* ---:--- */	#define	    bOTP_CRC32_rkekCrc32				   32 /*bit*/
	/* ---:--- */	#define	LSb32OTP_CRC32_rkekCrc32				    0 /*:31*/
	/* ---:--- */	#define	MSK32OTP_CRC32_rkekCrc32				       0xFFFFFFFF
	/* ---:--- */	#define	GET32OTP_CRC32_rkekCrc32(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16OTP_CRC32_rkekCrc32(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32OTP_CRC32_rkekCrc32(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_CRC32_rkekCrc32(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_OTP_CRC32_D2th_ 			ISC_USE_ONLY	0x00008
	#define	w32OTP_CRC32_D2th_ 			{										\
					UNSG32				u_aeskCrc32					 : 32;		\
										}
	/* @'00008 */				struct	w32OTP_CRC32_D2th_;

	/* [31: 0] */	#define	  BA_OTP_CRC32_aeskCrc32				 0x00008
	/* ---:--- */	#define	    bOTP_CRC32_aeskCrc32				   32 /*bit*/
	/* ---:--- */	#define	LSb32OTP_CRC32_aeskCrc32				    0 /*:31*/
	/* ---:--- */	#define	MSK32OTP_CRC32_aeskCrc32				       0xFFFFFFFF
	/* ---:--- */	#define	GET32OTP_CRC32_aeskCrc32(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16OTP_CRC32_aeskCrc32(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32OTP_CRC32_aeskCrc32(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_CRC32_aeskCrc32(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_OTP_CRC32_D3th_ 			ISC_USE_ONLY	0x0000C
	#define	w32OTP_CRC32_D3th_ 			{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'0000C */				struct	w32OTP_CRC32_D3th_;

	/* [31: 0] */	#define	  BA_OTP_CRC32_reserved					 0x0000C
	/* ---:--- */	#define	    bOTP_CRC32_reserved					   32 /*bit*/
	/* ---:--- */	#define	LSb32OTP_CRC32_reserved					    0 /*:31*/
	/* ---:--- */	#define	MSK32OTP_CRC32_reserved					       0xFFFFFFFF
	/* ---:--- */	#define	GET32OTP_CRC32_reserved(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16OTP_CRC32_reserved(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32OTP_CRC32_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_CRC32_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_OTP_CRC32;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	OTP_CRC32_drvrd (SIE_OTP_CRC32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	OTP_CRC32_drvwr (SIE_OTP_CRC32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	OTP_CRC32_reset (SIE_OTP_CRC32 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	OTP_CRC32_check(p,pie,ps8name,hfpErrLOG)		OTP_CRC32_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	OTP_CRC32_print(p,    ps8name,hfpErrLOG)		OTP_CRC32_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	OTP_CRC32_cmp   (SIE_OTP_CRC32 *p, SIE_OTP_CRC32 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	OTP_CRC32_import(SIE_OTP_CRC32 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	OTP_CRC32_export(SIE_OTP_CRC32 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: OTP_CRC32
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: BG2_OTP_CRC32
*	@
*		%unsigned  32  signkCrc32
*						*  *
*						*  CRC32 value of Private Key Data region
*	@
*		%unsigned  32  rkekCrc32
*						*  *
*						*  CRC32 value of RKEK Key Data region
*	@
*		%unsigned  32  aeskCrc32
*						*  *
*						*  CRC32 value of AES Key Data region
*	@
*		%unsigned  32  mdkCrc32
*						*  *
*						*  CRC32 value of MDK Key Data region
**********************************************************************************************************************/
#ifdef	h_BG2_OTP_CRC32
#else
#define	h_BG2_OTP_CRC32

#define	\
	AR_BG2_OTP_CRC32 \
		4
#define	\
	AB_BG2_OTP_CRC32 \
		4

typedef struct SIE_BG2_OTP_CRC32 {

	#define	RA_BG2_OTP_CRC32_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32BG2_OTP_CRC32_D0th_ 		{										\
					UNSG32				u_signkCrc32				 : 32;		\
										}
	/* @'00000 */				struct	w32BG2_OTP_CRC32_D0th_;

	/* [31: 0] */	#define	  BA_BG2_OTP_CRC32_signkCrc32			 0x00000
	/* ---:--- */	#define	    bBG2_OTP_CRC32_signkCrc32			   32 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_CRC32_signkCrc32			    0 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_CRC32_signkCrc32			       0xFFFFFFFF
	/* ---:--- */	#define	GET32BG2_OTP_CRC32_signkCrc32(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_CRC32_signkCrc32(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_CRC32_signkCrc32(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_CRC32_signkCrc32(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_BG2_OTP_CRC32_D1th_ 		ISC_USE_ONLY	0x00004
	#define	w32BG2_OTP_CRC32_D1th_ 		{										\
					UNSG32				u_rkekCrc32					 : 32;		\
										}
	/* @'00004 */				struct	w32BG2_OTP_CRC32_D1th_;

	/* [31: 0] */	#define	  BA_BG2_OTP_CRC32_rkekCrc32			 0x00004
	/* ---:--- */	#define	    bBG2_OTP_CRC32_rkekCrc32			   32 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_CRC32_rkekCrc32			    0 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_CRC32_rkekCrc32			       0xFFFFFFFF
	/* ---:--- */	#define	GET32BG2_OTP_CRC32_rkekCrc32(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_CRC32_rkekCrc32(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_CRC32_rkekCrc32(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_CRC32_rkekCrc32(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_BG2_OTP_CRC32_D2th_ 		ISC_USE_ONLY	0x00008
	#define	w32BG2_OTP_CRC32_D2th_ 		{										\
					UNSG32				u_aeskCrc32					 : 32;		\
										}
	/* @'00008 */				struct	w32BG2_OTP_CRC32_D2th_;

	/* [31: 0] */	#define	  BA_BG2_OTP_CRC32_aeskCrc32			 0x00008
	/* ---:--- */	#define	    bBG2_OTP_CRC32_aeskCrc32			   32 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_CRC32_aeskCrc32			    0 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_CRC32_aeskCrc32			       0xFFFFFFFF
	/* ---:--- */	#define	GET32BG2_OTP_CRC32_aeskCrc32(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_CRC32_aeskCrc32(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_CRC32_aeskCrc32(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_CRC32_aeskCrc32(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_BG2_OTP_CRC32_D3th_ 		ISC_USE_ONLY	0x0000C
	#define	w32BG2_OTP_CRC32_D3th_ 		{										\
					UNSG32				u_mdkCrc32					 : 32;		\
										}
	/* @'0000C */				struct	w32BG2_OTP_CRC32_D3th_;

	/* [31: 0] */	#define	  BA_BG2_OTP_CRC32_mdkCrc32				 0x0000C
	/* ---:--- */	#define	    bBG2_OTP_CRC32_mdkCrc32				   32 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_CRC32_mdkCrc32				    0 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_CRC32_mdkCrc32				       0xFFFFFFFF
	/* ---:--- */	#define	GET32BG2_OTP_CRC32_mdkCrc32(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_CRC32_mdkCrc32(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_CRC32_mdkCrc32(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_CRC32_mdkCrc32(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_BG2_OTP_CRC32;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	BG2_OTP_CRC32_drvrd (SIE_BG2_OTP_CRC32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	BG2_OTP_CRC32_drvwr (SIE_BG2_OTP_CRC32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	BG2_OTP_CRC32_reset (SIE_BG2_OTP_CRC32 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	BG2_OTP_CRC32_check(p,pie,ps8name,hfpErrLOG)		BG2_OTP_CRC32_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	BG2_OTP_CRC32_print(p,    ps8name,hfpErrLOG)		BG2_OTP_CRC32_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	BG2_OTP_CRC32_cmp   (SIE_BG2_OTP_CRC32 *p, SIE_BG2_OTP_CRC32 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	BG2_OTP_CRC32_import(SIE_BG2_OTP_CRC32 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	BG2_OTP_CRC32_export(SIE_BG2_OTP_CRC32 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: BG2_OTP_CRC32
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: BG2_OTP_DAT
*	@  SIGNK_START
*		$UINT128  signkDatHamming  REG  [2]
*						*  *
*						*  Signature key information hamming code
*	@  SIGNK_INFO
*		%unsigned  16  signkInfoHamming
*						*  *
*						*  Information header hamming code
*		%unsigned  8  crc32Val0
*		%unsigned  8  crc32Val1
*		%unsigned  8  crc32Val2
*		%unsigned  8  crc32Val3
*						*  *
*						*  CRC32 value of Private Key and configuration information
*		%unsigned  8  otpKeyEnable
*						*  *
*						*  Mask for OTP and ROM Key enable/disable
*						*  00: Disable OTP Key,
*						*       Enable ROM Key
*						*  01: Enable OTP Key
*						*      Enable ROM Key
*						*  10: Disable OTP Key
*						*      Disable ROM Key
*						*  11: Enable OTP Key
*						*      Disable ROM Key
*		%unsigned  8  reserved
*						*  *
*						*  Reserved area
*	@  SIGNK_DAT
*		$UINT128  signkDat  REG  [12]
*						*  *
*						*  SHA-1 Value for SIGNK's PUB+MOD
*	@  RKEK_START
*		$UINT64  rkekDatHamming
*						*  *
*						*  rkek key information hamming code
*	@  RKEK_INFO
*		%unsigned  16  rkekInfoHamming
*						*  *
*						*  Information header hamming code
*		%unsigned  8  crc32Val0
*		%unsigned  8  crc32Val1
*		%unsigned  8  crc32Val2
*		%unsigned  8  crc32Val3
*						*  *
*						*  CRC32 value of RKEK Key and configuration information
*		%unsigned  16  reserved
*						*  *
*						*  Reserved area
*	@  RKEK_DAT
*		$UINT64  rkekDat  REG  [2]
*						*  *
*						*  RKEK Key Data
*	@  MDK_START
*		$UINT64  mdkDatHamming
*						*  *
*						*  MDK key information hamming code
*	@  MDK_INFO
*		%unsigned  16  mdkinfoHamming
*						*  *
*						*  Information header hamming code
*		%unsigned  8  crc32Val0
*		%unsigned  8  crc32Val1
*		%unsigned  8  crc32Val2
*		%unsigned  8  crc32Val3
*						*  *
*						*  CRC32 value of MDK Key and configuration information
*		%unsigned  16  mdkVersion
*						*  *
*						*  MDK Version ID
*	@  MDK_DAT
*		$UINT64  mdkDat  REG  [2]
*						*  *
*						*  MDK Key Data
*	@  CHIP_ID
*		$UINT64  chipID
*						*  *
*						*  Unqiue chip ID
*	@  USER_INFO
*		$UINT64  userInfo
*						*  *
*						*  Customizable area which indicates the products ID and reversion ID
*	@  BIND_INFO
*		$UINT64  bindinfo
*						*  *
*						*  Binding info of the platform which indicates the chip features
*	@  AESK_START
*		$UINT64  aeskDatHamming
*						*  *
*						*  AES key information hamming code
*	@  AESK_INFO
*		%unsigned  16  aeskInfoHamming
*						*  *
*						*  Information header hamming code
*		%unsigned  8  crc32Val0
*		%unsigned  8  crc32Val1
*		%unsigned  8  crc32Val2
*		%unsigned  8  crc32Val3
*						*  *
*						*  CRC32 value of AESK Key and configuration information
*		%unsigned  16  reserved
*						*  *
*						*  Reserved area
*	@  AESK_DAT
*		$UINT64  aeskDat  REG  [2]
*						*  *
*						*  AES Key Data
*	@  CHIP_INFO
*		$UINT64  chipinfo
*						*  *
*						*  Chip related parameters
*	@
*		$UINT64  reserved  REG  [19]
*						*  *
*						*  41 reserved entries for customer
**********************************************************************************************************************/
#ifdef	h_BG2_OTP_DAT
#else
#define	h_BG2_OTP_DAT

#define	\
	AR_BG2_OTP_DAT \
		128
#define	\
	AB_BG2_OTP_DAT \
		9

typedef struct SIE_BG2_OTP_DAT {

	#define	RA_BG2_OTP_DAT_SIGNK_START 	0x00000
	/* @'00000 */	SIE_UINT128 				ie_signkDatHamming	 [2];
					#define	 arr_BG2_OTP_DAT_signkDatHamming 		  2

	#define	RA_BG2_OTP_DAT_SIGNK_INFO 	0x00020
	#define	w32BG2_OTP_DAT_SIGNK_INFO 	{										\
					UNSG32				uSIGNK_INFO_signkInfoHamming : 16;		\
					UNSG32				uSIGNK_INFO_crc32Val0		 :  8;		\
					UNSG32				uSIGNK_INFO_crc32Val1		 :  8;		\
										}
	/* @'00020 */	union {	UNSG32		u32BG2_OTP_DAT_SIGNK_INFO;
								struct	w32BG2_OTP_DAT_SIGNK_INFO;
										};

	/* [15: 0] */	#define	  BA_BG2_OTP_DAT_SIGNK_INFO_signkInfoHamming 0x00020
	/* ---:--- */	#define	    bBG2_OTP_DAT_SIGNK_INFO_signkInfoHamming   16 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_SIGNK_INFO_signkInfoHamming    0 /*:15*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_SIGNK_INFO_signkInfoHamming       0x0000FFFF
	/* ---:--- */	#define	GET32BG2_OTP_DAT_SIGNK_INFO_signkInfoHamming(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_SIGNK_INFO_signkInfoHamming(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_SIGNK_INFO_signkInfoHamming(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_SIGNK_INFO_signkInfoHamming(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_BG2_OTP_DAT_SIGNK_INFO_crc32Val0	 0x00022
	/* ---:--- */	#define	    bBG2_OTP_DAT_SIGNK_INFO_crc32Val0	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_SIGNK_INFO_crc32Val0	   16 /*:23*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_SIGNK_INFO_crc32Val0	       0x00FF0000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_SIGNK_INFO_crc32Val0(r32)	 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_SIGNK_INFO_crc32Val0(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_SIGNK_INFO_crc32Val0(r32,v)do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_SIGNK_INFO_crc32Val0(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_BG2_OTP_DAT_SIGNK_INFO_crc32Val1	 0x00023
	/* ---:--- */	#define	    bBG2_OTP_DAT_SIGNK_INFO_crc32Val1	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_SIGNK_INFO_crc32Val1	   24 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_SIGNK_INFO_crc32Val1	       0xFF000000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_SIGNK_INFO_crc32Val1(r32)	 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_SIGNK_INFO_crc32Val1(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_SIGNK_INFO_crc32Val1(r32,v)do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_SIGNK_INFO_crc32Val1(r16,v)do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_BG2_OTP_DAT_SIGNK_INFO1 	0x00024
	#define	w32BG2_OTP_DAT_SIGNK_INFO1 	{										\
					UNSG32				uSIGNK_INFO_crc32Val2		 :  8;		\
					UNSG32				uSIGNK_INFO_crc32Val3		 :  8;		\
					UNSG32				uSIGNK_INFO_otpKeyEnable	 :  8;		\
					UNSG32				uSIGNK_INFO_reserved		 :  8;		\
										}
	/* @'00024 */	union {	UNSG32		u32BG2_OTP_DAT_SIGNK_INFO1;
								struct	w32BG2_OTP_DAT_SIGNK_INFO1;
										};

	/* [ 7: 0] */	#define	  BA_BG2_OTP_DAT_SIGNK_INFO_crc32Val2	 0x00024
	/* ---:--- */	#define	    bBG2_OTP_DAT_SIGNK_INFO_crc32Val2	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_SIGNK_INFO_crc32Val2	    0 /*: 7*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_SIGNK_INFO_crc32Val2	       0x000000FF
	/* ---:--- */	#define	GET32BG2_OTP_DAT_SIGNK_INFO_crc32Val2(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_SIGNK_INFO_crc32Val2(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_SIGNK_INFO_crc32Val2(r32,v)do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_SIGNK_INFO_crc32Val2(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_BG2_OTP_DAT_SIGNK_INFO_crc32Val3	 0x00025
	/* ---:--- */	#define	    bBG2_OTP_DAT_SIGNK_INFO_crc32Val3	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_SIGNK_INFO_crc32Val3	    8 /*:15*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_SIGNK_INFO_crc32Val3	       0x0000FF00
	/* ---:--- */	#define	GET32BG2_OTP_DAT_SIGNK_INFO_crc32Val3(r32)	 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_SIGNK_INFO_crc32Val3(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_SIGNK_INFO_crc32Val3(r32,v)do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_SIGNK_INFO_crc32Val3(r16,v)do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [23:16] */	#define	  BA_BG2_OTP_DAT_SIGNK_INFO_otpKeyEnable 0x00026
	/* ---:--- */	#define	    bBG2_OTP_DAT_SIGNK_INFO_otpKeyEnable    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_SIGNK_INFO_otpKeyEnable   16 /*:23*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_SIGNK_INFO_otpKeyEnable       0x00FF0000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_SIGNK_INFO_otpKeyEnable(r32) (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_SIGNK_INFO_otpKeyEnable(r16) (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_SIGNK_INFO_otpKeyEnable(r32,v)do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_SIGNK_INFO_otpKeyEnable(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_BG2_OTP_DAT_SIGNK_INFO_reserved	 0x00027
	/* ---:--- */	#define	    bBG2_OTP_DAT_SIGNK_INFO_reserved	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_SIGNK_INFO_reserved	   24 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_SIGNK_INFO_reserved	       0xFF000000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_SIGNK_INFO_reserved(r32)	 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_SIGNK_INFO_reserved(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_SIGNK_INFO_reserved(r32,v)	do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_SIGNK_INFO_reserved(r16,v)	do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_BG2_OTP_DAT_SIGNK_DAT 	0x00028
	/* @'00028 */	SIE_UINT128 				ie_signkDat			 [12];
					#define	 arr_BG2_OTP_DAT_signkDat 				  12

	#define	RA_BG2_OTP_DAT_RKEK_START 	0x000E8
	/* @'000E8 */	SIE_UINT64 					ie_rkekDatHamming;

	#define	RA_BG2_OTP_DAT_RKEK_INFO 	0x000F0
	#define	w32BG2_OTP_DAT_RKEK_INFO 	{										\
					UNSG32				uRKEK_INFO_rkekInfoHamming	 : 16;		\
					UNSG32				uRKEK_INFO_crc32Val0		 :  8;		\
					UNSG32				uRKEK_INFO_crc32Val1		 :  8;		\
										}
	/* @'000F0 */	union {	UNSG32		u32BG2_OTP_DAT_RKEK_INFO;
								struct	w32BG2_OTP_DAT_RKEK_INFO;
										};

	/* [15: 0] */	#define	  BA_BG2_OTP_DAT_RKEK_INFO_rkekInfoHamming 0x000F0
	/* ---:--- */	#define	    bBG2_OTP_DAT_RKEK_INFO_rkekInfoHamming   16 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_RKEK_INFO_rkekInfoHamming    0 /*:15*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_RKEK_INFO_rkekInfoHamming       0x0000FFFF
	/* ---:--- */	#define	GET32BG2_OTP_DAT_RKEK_INFO_rkekInfoHamming(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_RKEK_INFO_rkekInfoHamming(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_RKEK_INFO_rkekInfoHamming(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_RKEK_INFO_rkekInfoHamming(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_BG2_OTP_DAT_RKEK_INFO_crc32Val0	 0x000F2
	/* ---:--- */	#define	    bBG2_OTP_DAT_RKEK_INFO_crc32Val0	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_RKEK_INFO_crc32Val0	   16 /*:23*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_RKEK_INFO_crc32Val0	       0x00FF0000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_RKEK_INFO_crc32Val0(r32)	 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_RKEK_INFO_crc32Val0(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_RKEK_INFO_crc32Val0(r32,v)	do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_RKEK_INFO_crc32Val0(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_BG2_OTP_DAT_RKEK_INFO_crc32Val1	 0x000F3
	/* ---:--- */	#define	    bBG2_OTP_DAT_RKEK_INFO_crc32Val1	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_RKEK_INFO_crc32Val1	   24 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_RKEK_INFO_crc32Val1	       0xFF000000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_RKEK_INFO_crc32Val1(r32)	 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_RKEK_INFO_crc32Val1(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_RKEK_INFO_crc32Val1(r32,v)	do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_RKEK_INFO_crc32Val1(r16,v)	do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_BG2_OTP_DAT_RKEK_INFO1 	0x000F4
	#define	w32BG2_OTP_DAT_RKEK_INFO1 	{										\
					UNSG32				uRKEK_INFO_crc32Val2		 :  8;		\
					UNSG32				uRKEK_INFO_crc32Val3		 :  8;		\
					UNSG32				uRKEK_INFO_reserved			 : 16;		\
										}
	/* @'000F4 */	union {	UNSG32		u32BG2_OTP_DAT_RKEK_INFO1;
								struct	w32BG2_OTP_DAT_RKEK_INFO1;
										};

	/* [ 7: 0] */	#define	  BA_BG2_OTP_DAT_RKEK_INFO_crc32Val2	 0x000F4
	/* ---:--- */	#define	    bBG2_OTP_DAT_RKEK_INFO_crc32Val2	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_RKEK_INFO_crc32Val2	    0 /*: 7*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_RKEK_INFO_crc32Val2	       0x000000FF
	/* ---:--- */	#define	GET32BG2_OTP_DAT_RKEK_INFO_crc32Val2(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_RKEK_INFO_crc32Val2(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_RKEK_INFO_crc32Val2(r32,v)	do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_RKEK_INFO_crc32Val2(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_BG2_OTP_DAT_RKEK_INFO_crc32Val3	 0x000F5
	/* ---:--- */	#define	    bBG2_OTP_DAT_RKEK_INFO_crc32Val3	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_RKEK_INFO_crc32Val3	    8 /*:15*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_RKEK_INFO_crc32Val3	       0x0000FF00
	/* ---:--- */	#define	GET32BG2_OTP_DAT_RKEK_INFO_crc32Val3(r32)	 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_RKEK_INFO_crc32Val3(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_RKEK_INFO_crc32Val3(r32,v)	do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_RKEK_INFO_crc32Val3(r16,v)	do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [31:16] */	#define	  BA_BG2_OTP_DAT_RKEK_INFO_reserved		 0x000F6
	/* ---:--- */	#define	    bBG2_OTP_DAT_RKEK_INFO_reserved		   16 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_RKEK_INFO_reserved		   16 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_RKEK_INFO_reserved		       0xFFFF0000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_RKEK_INFO_reserved(r32)	 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_RKEK_INFO_reserved(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_RKEK_INFO_reserved(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_RKEK_INFO_reserved(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_BG2_OTP_DAT_RKEK_DAT 	0x000F8
	/* @'000F8 */	SIE_UINT64 					ie_rkekDat			 [2];
					#define	 arr_BG2_OTP_DAT_rkekDat 				  2

	#define	RA_BG2_OTP_DAT_MDK_START 	0x00108
	/* @'00108 */	SIE_UINT64 					ie_mdkDatHamming;

	#define	RA_BG2_OTP_DAT_MDK_INFO 	0x00110
	#define	w32BG2_OTP_DAT_MDK_INFO 	{										\
					UNSG32				uMDK_INFO_mdkinfoHamming	 : 16;		\
					UNSG32				uMDK_INFO_crc32Val0			 :  8;		\
					UNSG32				uMDK_INFO_crc32Val1			 :  8;		\
										}
	/* @'00110 */	union {	UNSG32		u32BG2_OTP_DAT_MDK_INFO;
								struct	w32BG2_OTP_DAT_MDK_INFO;
										};

	/* [15: 0] */	#define	  BA_BG2_OTP_DAT_MDK_INFO_mdkinfoHamming 0x00110
	/* ---:--- */	#define	    bBG2_OTP_DAT_MDK_INFO_mdkinfoHamming   16 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_MDK_INFO_mdkinfoHamming    0 /*:15*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_MDK_INFO_mdkinfoHamming       0x0000FFFF
	/* ---:--- */	#define	GET32BG2_OTP_DAT_MDK_INFO_mdkinfoHamming(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_MDK_INFO_mdkinfoHamming(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_MDK_INFO_mdkinfoHamming(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_MDK_INFO_mdkinfoHamming(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_BG2_OTP_DAT_MDK_INFO_crc32Val0		 0x00112
	/* ---:--- */	#define	    bBG2_OTP_DAT_MDK_INFO_crc32Val0		    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_MDK_INFO_crc32Val0		   16 /*:23*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_MDK_INFO_crc32Val0		       0x00FF0000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_MDK_INFO_crc32Val0(r32)	 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_MDK_INFO_crc32Val0(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_MDK_INFO_crc32Val0(r32,v)	do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_MDK_INFO_crc32Val0(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_BG2_OTP_DAT_MDK_INFO_crc32Val1		 0x00113
	/* ---:--- */	#define	    bBG2_OTP_DAT_MDK_INFO_crc32Val1		    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_MDK_INFO_crc32Val1		   24 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_MDK_INFO_crc32Val1		       0xFF000000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_MDK_INFO_crc32Val1(r32)	 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_MDK_INFO_crc32Val1(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_MDK_INFO_crc32Val1(r32,v)	do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_MDK_INFO_crc32Val1(r16,v)	do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_BG2_OTP_DAT_MDK_INFO1 	0x00114
	#define	w32BG2_OTP_DAT_MDK_INFO1 	{										\
					UNSG32				uMDK_INFO_crc32Val2			 :  8;		\
					UNSG32				uMDK_INFO_crc32Val3			 :  8;		\
					UNSG32				uMDK_INFO_mdkVersion		 : 16;		\
										}
	/* @'00114 */	union {	UNSG32		u32BG2_OTP_DAT_MDK_INFO1;
								struct	w32BG2_OTP_DAT_MDK_INFO1;
										};

	/* [ 7: 0] */	#define	  BA_BG2_OTP_DAT_MDK_INFO_crc32Val2		 0x00114
	/* ---:--- */	#define	    bBG2_OTP_DAT_MDK_INFO_crc32Val2		    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_MDK_INFO_crc32Val2		    0 /*: 7*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_MDK_INFO_crc32Val2		       0x000000FF
	/* ---:--- */	#define	GET32BG2_OTP_DAT_MDK_INFO_crc32Val2(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_MDK_INFO_crc32Val2(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_MDK_INFO_crc32Val2(r32,v)	do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_MDK_INFO_crc32Val2(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_BG2_OTP_DAT_MDK_INFO_crc32Val3		 0x00115
	/* ---:--- */	#define	    bBG2_OTP_DAT_MDK_INFO_crc32Val3		    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_MDK_INFO_crc32Val3		    8 /*:15*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_MDK_INFO_crc32Val3		       0x0000FF00
	/* ---:--- */	#define	GET32BG2_OTP_DAT_MDK_INFO_crc32Val3(r32)	 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_MDK_INFO_crc32Val3(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_MDK_INFO_crc32Val3(r32,v)	do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_MDK_INFO_crc32Val3(r16,v)	do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [31:16] */	#define	  BA_BG2_OTP_DAT_MDK_INFO_mdkVersion	 0x00116
	/* ---:--- */	#define	    bBG2_OTP_DAT_MDK_INFO_mdkVersion	   16 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_MDK_INFO_mdkVersion	   16 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_MDK_INFO_mdkVersion	       0xFFFF0000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_MDK_INFO_mdkVersion(r32)	 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_MDK_INFO_mdkVersion(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_MDK_INFO_mdkVersion(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_MDK_INFO_mdkVersion(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_BG2_OTP_DAT_MDK_DAT 		0x00118
	/* @'00118 */	SIE_UINT64 					ie_mdkDat			 [2];
					#define	 arr_BG2_OTP_DAT_mdkDat 				  2

	#define	RA_BG2_OTP_DAT_CHIP_ID 		0x00128
	/* @'00128 */	SIE_UINT64 					ie_chipID;

	#define	RA_BG2_OTP_DAT_USER_INFO 	0x00130
	/* @'00130 */	SIE_UINT64 					ie_userInfo;

	#define	RA_BG2_OTP_DAT_BIND_INFO 	0x00138
	/* @'00138 */	SIE_UINT64 					ie_bindinfo;

	#define	RA_BG2_OTP_DAT_AESK_START 	0x00140
	/* @'00140 */	SIE_UINT64 					ie_aeskDatHamming;

	#define	RA_BG2_OTP_DAT_AESK_INFO 	0x00148
	#define	w32BG2_OTP_DAT_AESK_INFO 	{										\
					UNSG32				uAESK_INFO_aeskInfoHamming	 : 16;		\
					UNSG32				uAESK_INFO_crc32Val0		 :  8;		\
					UNSG32				uAESK_INFO_crc32Val1		 :  8;		\
										}
	/* @'00148 */	union {	UNSG32		u32BG2_OTP_DAT_AESK_INFO;
								struct	w32BG2_OTP_DAT_AESK_INFO;
										};

	/* [15: 0] */	#define	  BA_BG2_OTP_DAT_AESK_INFO_aeskInfoHamming 0x00148
	/* ---:--- */	#define	    bBG2_OTP_DAT_AESK_INFO_aeskInfoHamming   16 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_AESK_INFO_aeskInfoHamming    0 /*:15*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_AESK_INFO_aeskInfoHamming       0x0000FFFF
	/* ---:--- */	#define	GET32BG2_OTP_DAT_AESK_INFO_aeskInfoHamming(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_AESK_INFO_aeskInfoHamming(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_AESK_INFO_aeskInfoHamming(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_AESK_INFO_aeskInfoHamming(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_BG2_OTP_DAT_AESK_INFO_crc32Val0	 0x0014A
	/* ---:--- */	#define	    bBG2_OTP_DAT_AESK_INFO_crc32Val0	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_AESK_INFO_crc32Val0	   16 /*:23*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_AESK_INFO_crc32Val0	       0x00FF0000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_AESK_INFO_crc32Val0(r32)	 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_AESK_INFO_crc32Val0(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_AESK_INFO_crc32Val0(r32,v)	do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_AESK_INFO_crc32Val0(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_BG2_OTP_DAT_AESK_INFO_crc32Val1	 0x0014B
	/* ---:--- */	#define	    bBG2_OTP_DAT_AESK_INFO_crc32Val1	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_AESK_INFO_crc32Val1	   24 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_AESK_INFO_crc32Val1	       0xFF000000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_AESK_INFO_crc32Val1(r32)	 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_AESK_INFO_crc32Val1(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_AESK_INFO_crc32Val1(r32,v)	do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_AESK_INFO_crc32Val1(r16,v)	do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_BG2_OTP_DAT_AESK_INFO1 	0x0014C
	#define	w32BG2_OTP_DAT_AESK_INFO1 	{										\
					UNSG32				uAESK_INFO_crc32Val2		 :  8;		\
					UNSG32				uAESK_INFO_crc32Val3		 :  8;		\
					UNSG32				uAESK_INFO_reserved			 : 16;		\
										}
	/* @'0014C */	union {	UNSG32		u32BG2_OTP_DAT_AESK_INFO1;
								struct	w32BG2_OTP_DAT_AESK_INFO1;
										};

	/* [ 7: 0] */	#define	  BA_BG2_OTP_DAT_AESK_INFO_crc32Val2	 0x0014C
	/* ---:--- */	#define	    bBG2_OTP_DAT_AESK_INFO_crc32Val2	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_AESK_INFO_crc32Val2	    0 /*: 7*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_AESK_INFO_crc32Val2	       0x000000FF
	/* ---:--- */	#define	GET32BG2_OTP_DAT_AESK_INFO_crc32Val2(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_AESK_INFO_crc32Val2(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_AESK_INFO_crc32Val2(r32,v)	do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_AESK_INFO_crc32Val2(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_BG2_OTP_DAT_AESK_INFO_crc32Val3	 0x0014D
	/* ---:--- */	#define	    bBG2_OTP_DAT_AESK_INFO_crc32Val3	    8 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_AESK_INFO_crc32Val3	    8 /*:15*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_AESK_INFO_crc32Val3	       0x0000FF00
	/* ---:--- */	#define	GET32BG2_OTP_DAT_AESK_INFO_crc32Val3(r32)	 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_AESK_INFO_crc32Val3(r16)	 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_AESK_INFO_crc32Val3(r32,v)	do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_AESK_INFO_crc32Val3(r16,v)	do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [31:16] */	#define	  BA_BG2_OTP_DAT_AESK_INFO_reserved		 0x0014E
	/* ---:--- */	#define	    bBG2_OTP_DAT_AESK_INFO_reserved		   16 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_DAT_AESK_INFO_reserved		   16 /*:31*/
	/* ---:--- */	#define	MSK32BG2_OTP_DAT_AESK_INFO_reserved		       0xFFFF0000
	/* ---:--- */	#define	GET32BG2_OTP_DAT_AESK_INFO_reserved(r32)	 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16BG2_OTP_DAT_AESK_INFO_reserved(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BG2_OTP_DAT_AESK_INFO_reserved(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_DAT_AESK_INFO_reserved(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_BG2_OTP_DAT_AESK_DAT 	0x00150
	/* @'00150 */	SIE_UINT64 					ie_aeskDat			 [2];
					#define	 arr_BG2_OTP_DAT_aeskDat 				  2

	#define	RA_BG2_OTP_DAT_CHIP_INFO 	0x00160
	/* @'00160 */	SIE_UINT64 					ie_chipinfo;

	#define	RA_BG2_OTP_DAT_reserved 	0x00168
	/* @'00168 */	SIE_UINT64 					ie_reserved			 [19];
					#define	 arr_BG2_OTP_DAT_reserved 				  19

} SIE_BG2_OTP_DAT;

	#define	dftBG2_OTP_DAT_SIGNK_INFO 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_DAT_SIGNK_INFO;
										} T32BG2_OTP_DAT_SIGNK_INFO;
	#define	dftBG2_OTP_DAT_SIGNK_INFO1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_DAT_SIGNK_INFO1;
										} T32BG2_OTP_DAT_SIGNK_INFO1;
	#define	dftBG2_OTP_DAT_RKEK_INFO 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_DAT_RKEK_INFO;
										} T32BG2_OTP_DAT_RKEK_INFO;
	#define	dftBG2_OTP_DAT_RKEK_INFO1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_DAT_RKEK_INFO1;
										} T32BG2_OTP_DAT_RKEK_INFO1;
	#define	dftBG2_OTP_DAT_MDK_INFO 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_DAT_MDK_INFO;
										} T32BG2_OTP_DAT_MDK_INFO;
	#define	dftBG2_OTP_DAT_MDK_INFO1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_DAT_MDK_INFO1;
										} T32BG2_OTP_DAT_MDK_INFO1;
	#define	dftBG2_OTP_DAT_AESK_INFO 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_DAT_AESK_INFO;
										} T32BG2_OTP_DAT_AESK_INFO;
	#define	dftBG2_OTP_DAT_AESK_INFO1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_DAT_AESK_INFO1;
										} T32BG2_OTP_DAT_AESK_INFO1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	BG2_OTP_DAT_drvrd (SIE_BG2_OTP_DAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	BG2_OTP_DAT_drvwr (SIE_BG2_OTP_DAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	BG2_OTP_DAT_reset (SIE_BG2_OTP_DAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	BG2_OTP_DAT_check(p,pie,ps8name,hfpErrLOG)		BG2_OTP_DAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	BG2_OTP_DAT_print(p,    ps8name,hfpErrLOG)		BG2_OTP_DAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	BG2_OTP_DAT_cmp   (SIE_BG2_OTP_DAT *p, SIE_BG2_OTP_DAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	BG2_OTP_DAT_import(SIE_BG2_OTP_DAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	BG2_OTP_DAT_export(SIE_BG2_OTP_DAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: BG2_OTP_DAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: OTP_DAT
*	@  PRVK_START
*		$UINT128  prvkDatHamming  REG  [2]
*						*  *
*						*  Private key information hamming code
*	@  PRVK_INFO
*		%unsigned  8  prvkInfoHamming
*						*  *
*						*  Information header hamming code
*		%unsigned  8  crc32Val0
*		%unsigned  8  crc32Val1
*		%unsigned  8  crc32Val2
*		%unsigned  8  crc32Val3
*						*  *
*						*  CRC32 value of Private Key and configuration information
*		%unsigned  8  prvkType
*			:  AES128  1
*			:  CHIPID128  2
*			:  RSA1024_PUBKEY  4
*			:  RSA1024_PRVKEY  8
*			:  RSA2048_PRVK  16
*		%unsigned  8  otpKeyEnable
*						*  *
*						*  Mask for OTP and ROM Key enable/disable
*						*  00: Disable OTP Key,
*						*       Enable ROM Key
*						*  01: Enable OTP Key
*						*      Enable ROM Key
*						*  10: Disable OTP Key
*						*      Disable ROM Key
*						*  11: Enable OTP Key
*						*      Disable ROM Key
*		%unsigned  8  reserved
*	@  PRVK_DAT
*		$UINT128  prvkDat  REG  [12]
*						*  *
*						*  Private Key Data which contains 128 bits symmetric verification key and public key and modulus of RSA algorithm.
*	@  RKEK
*		$UINT128  kekDat  0
*						*  *
*						*  128-bit Root Key Encryption Key (RKEK), which is randomly created, and burned into OTP registers at fist the time boot-up while manufacturing.
*	@  AESK_START
*		$UINT64  aeskDatHamming
*						*  *
*						*  aes key information hamming code
*	@  AESK_INFO
*		%unsigned  8  aeskInfoHamming
*						*  *
*						*  Information header hamming code
*		%unsigned  8  crc32Val0
*		%unsigned  8  crc32Val1
*		%unsigned  8  crc32Val2
*		%unsigned  8  crc32Val3
*						*  *
*						*  CRC32 value of AES Key and configuration information
*		%unsigned  8  aeskType
*		%unsigned  16  featureInfo1
*						*  *
*						*  Reserved information
*	@  AESK_DAT
*		$UINT64  aeskDat  REG  [2]
*						*  *
*						*  AES Key Data
*	@  CHIP_INFO
*		$UINT128  bindInfo
*						*  *
*						*  Binding info of the platform which indicates the chip features
*	@  USER_INFO
*		$UINT128  userInfo
*						*  *
*						*  Customizable area which indicates the products ID and reversion ID
*	@
*		$UINT64  reserved
*						*  *
*						*  64-bit reserved data
**********************************************************************************************************************/
#ifdef	h_OTP_DAT
#else
#define	h_OTP_DAT

#define	\
	AR_OTP_DAT \
		80
#define	\
	AB_OTP_DAT \
		9

typedef struct SIE_OTP_DAT {

	#define	RA_OTP_DAT_PRVK_START 		0x00000
	/* @'00000 */	SIE_UINT128 				ie_prvkDatHamming	 [2];
					#define	 arr_OTP_DAT_prvkDatHamming 			  2

	#define	RA_OTP_DAT_PRVK_INFO 		0x00020
	#define	w32OTP_DAT_PRVK_INFO 		{										\
					UNSG32				uPRVK_INFO_prvkInfoHamming	 :  8;		\
					UNSG32				uPRVK_INFO_crc32Val0		 :  8;		\
					UNSG32				uPRVK_INFO_crc32Val1		 :  8;		\
					UNSG32				uPRVK_INFO_crc32Val2		 :  8;		\
										}
	/* @'00020 */	union {	UNSG32		u32OTP_DAT_PRVK_INFO;
								struct	w32OTP_DAT_PRVK_INFO;
										};

	/* [ 7: 0] */	#define	  BA_OTP_DAT_PRVK_INFO_prvkInfoHamming	 0x00020
	/* ---:--- */	#define	    bOTP_DAT_PRVK_INFO_prvkInfoHamming	    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_PRVK_INFO_prvkInfoHamming	    0 /*: 7*/
	/* ---:--- */	#define	MSK32OTP_DAT_PRVK_INFO_prvkInfoHamming	       0x000000FF
	/* ---:--- */	#define	GET32OTP_DAT_PRVK_INFO_prvkInfoHamming(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_PRVK_INFO_prvkInfoHamming(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_PRVK_INFO_prvkInfoHamming(r32,v)do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_PRVK_INFO_prvkInfoHamming(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_OTP_DAT_PRVK_INFO_crc32Val0		 0x00021
	/* ---:--- */	#define	    bOTP_DAT_PRVK_INFO_crc32Val0		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_PRVK_INFO_crc32Val0		    8 /*:15*/
	/* ---:--- */	#define	MSK32OTP_DAT_PRVK_INFO_crc32Val0		       0x0000FF00
	/* ---:--- */	#define	GET32OTP_DAT_PRVK_INFO_crc32Val0(r32)		 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_PRVK_INFO_crc32Val0(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_PRVK_INFO_crc32Val0(r32,v)		do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_PRVK_INFO_crc32Val0(r16,v)		do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [23:16] */	#define	  BA_OTP_DAT_PRVK_INFO_crc32Val1		 0x00022
	/* ---:--- */	#define	    bOTP_DAT_PRVK_INFO_crc32Val1		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_PRVK_INFO_crc32Val1		   16 /*:23*/
	/* ---:--- */	#define	MSK32OTP_DAT_PRVK_INFO_crc32Val1		       0x00FF0000
	/* ---:--- */	#define	GET32OTP_DAT_PRVK_INFO_crc32Val1(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_PRVK_INFO_crc32Val1(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_PRVK_INFO_crc32Val1(r32,v)		do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_PRVK_INFO_crc32Val1(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_OTP_DAT_PRVK_INFO_crc32Val2		 0x00023
	/* ---:--- */	#define	    bOTP_DAT_PRVK_INFO_crc32Val2		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_PRVK_INFO_crc32Val2		   24 /*:31*/
	/* ---:--- */	#define	MSK32OTP_DAT_PRVK_INFO_crc32Val2		       0xFF000000
	/* ---:--- */	#define	GET32OTP_DAT_PRVK_INFO_crc32Val2(r32)		 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_PRVK_INFO_crc32Val2(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_PRVK_INFO_crc32Val2(r32,v)		do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_PRVK_INFO_crc32Val2(r16,v)		do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_OTP_DAT_PRVK_INFO1 		0x00024
	#define	w32OTP_DAT_PRVK_INFO1 		{										\
					UNSG32				uPRVK_INFO_crc32Val3		 :  8;		\
					UNSG32				uPRVK_INFO_prvkType			 :  8;		\
					UNSG32				uPRVK_INFO_otpKeyEnable		 :  8;		\
					UNSG32				uPRVK_INFO_reserved			 :  8;		\
										}
	/* @'00024 */	union {	UNSG32		u32OTP_DAT_PRVK_INFO1;
								struct	w32OTP_DAT_PRVK_INFO1;
										};

	/* [ 7: 0] */	#define	  BA_OTP_DAT_PRVK_INFO_crc32Val3		 0x00024
	/* ---:--- */	#define	    bOTP_DAT_PRVK_INFO_crc32Val3		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_PRVK_INFO_crc32Val3		    0 /*: 7*/
	/* ---:--- */	#define	MSK32OTP_DAT_PRVK_INFO_crc32Val3		       0x000000FF
	/* ---:--- */	#define	GET32OTP_DAT_PRVK_INFO_crc32Val3(r32)		 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_PRVK_INFO_crc32Val3(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_PRVK_INFO_crc32Val3(r32,v)		do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_PRVK_INFO_crc32Val3(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_OTP_DAT_PRVK_INFO_prvkType			 0x00025
	/* ---:--- */	#define	    bOTP_DAT_PRVK_INFO_prvkType			    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_PRVK_INFO_prvkType			    8 /*:15*/
	/* ---:--- */	#define	MSK32OTP_DAT_PRVK_INFO_prvkType			       0x0000FF00
	/* ---:--- */	#define	GET32OTP_DAT_PRVK_INFO_prvkType(r32)		 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_PRVK_INFO_prvkType(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_PRVK_INFO_prvkType(r32,v)		do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_PRVK_INFO_prvkType(r16,v)		do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)
					#define	     OTP_DAT_PRVK_INFO_prvkType_AES128			0x1
					#define	     OTP_DAT_PRVK_INFO_prvkType_CHIPID128		0x2
					#define	     OTP_DAT_PRVK_INFO_prvkType_RSA1024_PUBKEY	0x4
					#define	     OTP_DAT_PRVK_INFO_prvkType_RSA1024_PRVKEY	0x8
					#define	     OTP_DAT_PRVK_INFO_prvkType_RSA2048_PRVK	0x10

	/* [23:16] */	#define	  BA_OTP_DAT_PRVK_INFO_otpKeyEnable		 0x00026
	/* ---:--- */	#define	    bOTP_DAT_PRVK_INFO_otpKeyEnable		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_PRVK_INFO_otpKeyEnable		   16 /*:23*/
	/* ---:--- */	#define	MSK32OTP_DAT_PRVK_INFO_otpKeyEnable		       0x00FF0000
	/* ---:--- */	#define	GET32OTP_DAT_PRVK_INFO_otpKeyEnable(r32)	 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_PRVK_INFO_otpKeyEnable(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_PRVK_INFO_otpKeyEnable(r32,v)	do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_PRVK_INFO_otpKeyEnable(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_OTP_DAT_PRVK_INFO_reserved			 0x00027
	/* ---:--- */	#define	    bOTP_DAT_PRVK_INFO_reserved			    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_PRVK_INFO_reserved			   24 /*:31*/
	/* ---:--- */	#define	MSK32OTP_DAT_PRVK_INFO_reserved			       0xFF000000
	/* ---:--- */	#define	GET32OTP_DAT_PRVK_INFO_reserved(r32)		 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_PRVK_INFO_reserved(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_PRVK_INFO_reserved(r32,v)		do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_PRVK_INFO_reserved(r16,v)		do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_OTP_DAT_PRVK_DAT 		0x00028
	/* @'00028 */	SIE_UINT128 				ie_prvkDat			 [12];
					#define	 arr_OTP_DAT_prvkDat 					  12

	#define	RA_OTP_DAT_RKEK 			0x000E8
	/* @'000E8 */	SIE_UINT128 				ie_kekDat;

	#define	RA_OTP_DAT_AESK_START 		0x000F8
	/* @'000F8 */	SIE_UINT64 					ie_aeskDatHamming;

	#define	RA_OTP_DAT_AESK_INFO 		0x00100
	#define	w32OTP_DAT_AESK_INFO 		{										\
					UNSG32				uAESK_INFO_aeskInfoHamming	 :  8;		\
					UNSG32				uAESK_INFO_crc32Val0		 :  8;		\
					UNSG32				uAESK_INFO_crc32Val1		 :  8;		\
					UNSG32				uAESK_INFO_crc32Val2		 :  8;		\
										}
	/* @'00100 */	union {	UNSG32		u32OTP_DAT_AESK_INFO;
								struct	w32OTP_DAT_AESK_INFO;
										};

	/* [ 7: 0] */	#define	  BA_OTP_DAT_AESK_INFO_aeskInfoHamming	 0x00100
	/* ---:--- */	#define	    bOTP_DAT_AESK_INFO_aeskInfoHamming	    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_AESK_INFO_aeskInfoHamming	    0 /*: 7*/
	/* ---:--- */	#define	MSK32OTP_DAT_AESK_INFO_aeskInfoHamming	       0x000000FF
	/* ---:--- */	#define	GET32OTP_DAT_AESK_INFO_aeskInfoHamming(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_AESK_INFO_aeskInfoHamming(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_AESK_INFO_aeskInfoHamming(r32,v)do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_AESK_INFO_aeskInfoHamming(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_OTP_DAT_AESK_INFO_crc32Val0		 0x00101
	/* ---:--- */	#define	    bOTP_DAT_AESK_INFO_crc32Val0		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_AESK_INFO_crc32Val0		    8 /*:15*/
	/* ---:--- */	#define	MSK32OTP_DAT_AESK_INFO_crc32Val0		       0x0000FF00
	/* ---:--- */	#define	GET32OTP_DAT_AESK_INFO_crc32Val0(r32)		 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_AESK_INFO_crc32Val0(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_AESK_INFO_crc32Val0(r32,v)		do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_AESK_INFO_crc32Val0(r16,v)		do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [23:16] */	#define	  BA_OTP_DAT_AESK_INFO_crc32Val1		 0x00102
	/* ---:--- */	#define	    bOTP_DAT_AESK_INFO_crc32Val1		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_AESK_INFO_crc32Val1		   16 /*:23*/
	/* ---:--- */	#define	MSK32OTP_DAT_AESK_INFO_crc32Val1		       0x00FF0000
	/* ---:--- */	#define	GET32OTP_DAT_AESK_INFO_crc32Val1(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_AESK_INFO_crc32Val1(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_AESK_INFO_crc32Val1(r32,v)		do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_AESK_INFO_crc32Val1(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_OTP_DAT_AESK_INFO_crc32Val2		 0x00103
	/* ---:--- */	#define	    bOTP_DAT_AESK_INFO_crc32Val2		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_AESK_INFO_crc32Val2		   24 /*:31*/
	/* ---:--- */	#define	MSK32OTP_DAT_AESK_INFO_crc32Val2		       0xFF000000
	/* ---:--- */	#define	GET32OTP_DAT_AESK_INFO_crc32Val2(r32)		 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_AESK_INFO_crc32Val2(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_AESK_INFO_crc32Val2(r32,v)		do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_AESK_INFO_crc32Val2(r16,v)		do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_OTP_DAT_AESK_INFO1 		0x00104
	#define	w32OTP_DAT_AESK_INFO1 		{										\
					UNSG32				uAESK_INFO_crc32Val3		 :  8;		\
					UNSG32				uAESK_INFO_aeskType			 :  8;		\
					UNSG32				uAESK_INFO_featureInfo1		 : 16;		\
										}
	/* @'00104 */	union {	UNSG32		u32OTP_DAT_AESK_INFO1;
								struct	w32OTP_DAT_AESK_INFO1;
										};

	/* [ 7: 0] */	#define	  BA_OTP_DAT_AESK_INFO_crc32Val3		 0x00104
	/* ---:--- */	#define	    bOTP_DAT_AESK_INFO_crc32Val3		    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_AESK_INFO_crc32Val3		    0 /*: 7*/
	/* ---:--- */	#define	MSK32OTP_DAT_AESK_INFO_crc32Val3		       0x000000FF
	/* ---:--- */	#define	GET32OTP_DAT_AESK_INFO_crc32Val3(r32)		 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_AESK_INFO_crc32Val3(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_AESK_INFO_crc32Val3(r32,v)		do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_AESK_INFO_crc32Val3(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_OTP_DAT_AESK_INFO_aeskType			 0x00105
	/* ---:--- */	#define	    bOTP_DAT_AESK_INFO_aeskType			    8 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_AESK_INFO_aeskType			    8 /*:15*/
	/* ---:--- */	#define	MSK32OTP_DAT_AESK_INFO_aeskType			       0x0000FF00
	/* ---:--- */	#define	GET32OTP_DAT_AESK_INFO_aeskType(r32)		 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16OTP_DAT_AESK_INFO_aeskType(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32OTP_DAT_AESK_INFO_aeskType(r32,v)		do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_AESK_INFO_aeskType(r16,v)		do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [31:16] */	#define	  BA_OTP_DAT_AESK_INFO_featureInfo1		 0x00106
	/* ---:--- */	#define	    bOTP_DAT_AESK_INFO_featureInfo1		   16 /*bit*/
	/* ---:--- */	#define	LSb32OTP_DAT_AESK_INFO_featureInfo1		   16 /*:31*/
	/* ---:--- */	#define	MSK32OTP_DAT_AESK_INFO_featureInfo1		       0xFFFF0000
	/* ---:--- */	#define	GET32OTP_DAT_AESK_INFO_featureInfo1(r32)	 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16OTP_DAT_AESK_INFO_featureInfo1(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32OTP_DAT_AESK_INFO_featureInfo1(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16OTP_DAT_AESK_INFO_featureInfo1(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_OTP_DAT_AESK_DAT 		0x00108
	/* @'00108 */	SIE_UINT64 					ie_aeskDat			 [2];
					#define	 arr_OTP_DAT_aeskDat 					  2

	#define	RA_OTP_DAT_CHIP_INFO 		0x00118
	/* @'00118 */	SIE_UINT128 				ie_bindInfo;

	#define	RA_OTP_DAT_USER_INFO 		0x00128
	/* @'00128 */	SIE_UINT128 				ie_userInfo;

	#define	RA_OTP_DAT_reserved 		0x00138
	/* @'00138 */	SIE_UINT64 					ie_reserved;

} SIE_OTP_DAT;

	#define	dftOTP_DAT_PRVK_INFO 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32OTP_DAT_PRVK_INFO;
										} T32OTP_DAT_PRVK_INFO;
	#define	dftOTP_DAT_PRVK_INFO1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32OTP_DAT_PRVK_INFO1;
										} T32OTP_DAT_PRVK_INFO1;
	#define	dftOTP_DAT_AESK_INFO 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32OTP_DAT_AESK_INFO;
										} T32OTP_DAT_AESK_INFO;
	#define	dftOTP_DAT_AESK_INFO1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32OTP_DAT_AESK_INFO1;
										} T32OTP_DAT_AESK_INFO1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	OTP_DAT_drvrd (SIE_OTP_DAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	OTP_DAT_drvwr (SIE_OTP_DAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	OTP_DAT_reset (SIE_OTP_DAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	OTP_DAT_check(p,pie,ps8name,hfpErrLOG)		OTP_DAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	OTP_DAT_print(p,    ps8name,hfpErrLOG)		OTP_DAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	OTP_DAT_cmp   (SIE_OTP_DAT *p, SIE_OTP_DAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	OTP_DAT_import(SIE_OTP_DAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	OTP_DAT_export(SIE_OTP_DAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: OTP_DAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: OTP_STATUS
*			:  unknown  0
*						*  *OTP region status is unknown
*			:  clean  1
*						*  *OTP region has not been programmed
*			:  dirty  2
*						*  *OTP region has been programmed but not CRC32 check failed
*			:  valid  3
*						*  *OTP region has been programmed and CRC32 check succeed
*	@  DAT
*		%unsigned  2  rkek_status
*						*  *
*						*  RKEK key status
*		%unsigned  2  prvk_status
*						*  *
*						*  private key status
*		%unsigned  2  aesk_status
*						*  *
*						*  aes key status
**********************************************************************************************************************/
#ifdef	h_OTP_STATUS
#else
#define	h_OTP_STATUS

#define	\
	AR_OTP_STATUS \
		1
#define	\
	AB_OTP_STATUS \
		2

	#define	OTP_STATUS_unknown 			0x0
	#define	OTP_STATUS_clean 			0x1
	#define	OTP_STATUS_dirty 			0x2
	#define	OTP_STATUS_valid 			0x3

typedef struct SIE_OTP_STATUS {

	#define	RA_OTP_STATUS_DAT 			0x00000
	#define	w32OTP_STATUS_DAT 			{										\
					UNSG32				uDAT_rkek_status			 :  2;		\
					UNSG32				uDAT_prvk_status			 :  2;		\
					UNSG32				uDAT_aesk_status			 :  2;		\
					UNSG32				_x00000	: 26;							\
										}
	/* @'00000 */	union {	UNSG32		u32OTP_STATUS_DAT;
								struct	w32OTP_STATUS_DAT;
										};

	/* [ 1: 0] */	#define	  BA_OTP_STATUS_DAT_rkek_status			 0x00000
	/* ---:--- */	#define	    bOTP_STATUS_DAT_rkek_status			    2 /*bit*/
	/* ---:--- */	#define	LSb32OTP_STATUS_DAT_rkek_status			    0 /*: 1*/
	/* ---:--- */	#define	MSK32OTP_STATUS_DAT_rkek_status			       0x00000003
	/* ---:--- */	#define	GET32OTP_STATUS_DAT_rkek_status(r32)		 (((r32)>> 0)&0x0003)
	/* ---:--- */	#define	GET16OTP_STATUS_DAT_rkek_status(r16)		 (((r16)>> 0)&0x0003)
	/* ---:--- */	#define	SET32OTP_STATUS_DAT_rkek_status(r32,v)		do{(r32)&=~(0x0003<< 0);(r32)|=((v)&0x0003)<< 0;}while(0)
	/* ---:--- */	#define	SET16OTP_STATUS_DAT_rkek_status(r16,v)		do{(r16)&=~(0x0003<< 0);(r16)|=((v)&0x0003)<< 0;}while(0)

	/* [ 3: 2] */	#define	  BA_OTP_STATUS_DAT_prvk_status			 0x00000
	/* ---:--- */	#define	    bOTP_STATUS_DAT_prvk_status			    2 /*bit*/
	/* ---:--- */	#define	LSb32OTP_STATUS_DAT_prvk_status			    2 /*: 3*/
	/* ---:--- */	#define	MSK32OTP_STATUS_DAT_prvk_status			       0x0000000C
	/* ---:--- */	#define	GET32OTP_STATUS_DAT_prvk_status(r32)		 (((r32)>> 2)&0x0003)
	/* ---:--- */	#define	GET16OTP_STATUS_DAT_prvk_status(r16)		 (((r16)>> 2)&0x0003)
	/* ---:--- */	#define	SET32OTP_STATUS_DAT_prvk_status(r32,v)		do{(r32)&=~(0x0003<< 2);(r32)|=((v)&0x0003)<< 2;}while(0)
	/* ---:--- */	#define	SET16OTP_STATUS_DAT_prvk_status(r16,v)		do{(r16)&=~(0x0003<< 2);(r16)|=((v)&0x0003)<< 2;}while(0)

	/* [ 5: 4] */	#define	  BA_OTP_STATUS_DAT_aesk_status			 0x00000
	/* ---:--- */	#define	    bOTP_STATUS_DAT_aesk_status			    2 /*bit*/
	/* ---:--- */	#define	LSb32OTP_STATUS_DAT_aesk_status			    4 /*: 5*/
	/* ---:--- */	#define	MSK32OTP_STATUS_DAT_aesk_status			       0x00000030
	/* ---:--- */	#define	GET32OTP_STATUS_DAT_aesk_status(r32)		 (((r32)>> 4)&0x0003)
	/* ---:--- */	#define	GET16OTP_STATUS_DAT_aesk_status(r16)		 (((r16)>> 4)&0x0003)
	/* ---:--- */	#define	SET32OTP_STATUS_DAT_aesk_status(r32,v)		do{(r32)&=~(0x0003<< 4);(r32)|=((v)&0x0003)<< 4;}while(0)
	/* ---:--- */	#define	SET16OTP_STATUS_DAT_aesk_status(r16,v)		do{(r16)&=~(0x0003<< 4);(r16)|=((v)&0x0003)<< 4;}while(0)

} SIE_OTP_STATUS;

	#define	dftOTP_STATUS_DAT 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32OTP_STATUS_DAT;
										} T32OTP_STATUS_DAT;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	OTP_STATUS_drvrd (SIE_OTP_STATUS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	OTP_STATUS_drvwr (SIE_OTP_STATUS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	OTP_STATUS_reset (SIE_OTP_STATUS *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	OTP_STATUS_check(p,pie,ps8name,hfpErrLOG)		OTP_STATUS_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	OTP_STATUS_print(p,    ps8name,hfpErrLOG)		OTP_STATUS_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	OTP_STATUS_cmp   (SIE_OTP_STATUS *p, SIE_OTP_STATUS *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	OTP_STATUS_import(SIE_OTP_STATUS *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	OTP_STATUS_export(SIE_OTP_STATUS *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: OTP_STATUS
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: BG2_OTP_STATUS
*			:  unknown  0
*						*  *OTP region status is unknown
*			:  clean  1
*						*  *OTP region has not been programmed
*			:  dirty  2
*						*  *OTP region has been programmed but not CRC32 check failed
*			:  valid  3
*						*  *OTP region has been programmed and CRC32 check succeed
*	@  DAT
*		%unsigned  2  signk_status
*						*  *
*						*  RKEK key status
*		%unsigned  2  rkek_status
*						*  *
*						*  private key status
*		%unsigned  2  aesk_status
*						*  *
*						*  aes key status
*		%unsigned  2  mdk_status
*						*  *
*						*  aes key status
**********************************************************************************************************************/
#ifdef	h_BG2_OTP_STATUS
#else
#define	h_BG2_OTP_STATUS

#define	\
	AR_BG2_OTP_STATUS \
		1
#define	\
	AB_BG2_OTP_STATUS \
		2

	#define	BG2_OTP_STATUS_unknown 		0x0
	#define	BG2_OTP_STATUS_clean 		0x1
	#define	BG2_OTP_STATUS_dirty 		0x2
	#define	BG2_OTP_STATUS_valid 		0x3

typedef struct SIE_BG2_OTP_STATUS {

	#define	RA_BG2_OTP_STATUS_DAT 		0x00000
	#define	w32BG2_OTP_STATUS_DAT 		{										\
					UNSG32				uDAT_signk_status			 :  2;		\
					UNSG32				uDAT_rkek_status			 :  2;		\
					UNSG32				uDAT_aesk_status			 :  2;		\
					UNSG32				uDAT_mdk_status				 :  2;		\
					UNSG32				_x00000	: 24;							\
										}
	/* @'00000 */	union {	UNSG32		u32BG2_OTP_STATUS_DAT;
								struct	w32BG2_OTP_STATUS_DAT;
										};

	/* [ 1: 0] */	#define	  BA_BG2_OTP_STATUS_DAT_signk_status	 0x00000
	/* ---:--- */	#define	    bBG2_OTP_STATUS_DAT_signk_status	    2 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_STATUS_DAT_signk_status	    0 /*: 1*/
	/* ---:--- */	#define	MSK32BG2_OTP_STATUS_DAT_signk_status	       0x00000003
	/* ---:--- */	#define	GET32BG2_OTP_STATUS_DAT_signk_status(r32)	 (((r32)>> 0)&0x0003)
	/* ---:--- */	#define	GET16BG2_OTP_STATUS_DAT_signk_status(r16)	 (((r16)>> 0)&0x0003)
	/* ---:--- */	#define	SET32BG2_OTP_STATUS_DAT_signk_status(r32,v)	do{(r32)&=~(0x0003<< 0);(r32)|=((v)&0x0003)<< 0;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_STATUS_DAT_signk_status(r16,v)	do{(r16)&=~(0x0003<< 0);(r16)|=((v)&0x0003)<< 0;}while(0)

	/* [ 3: 2] */	#define	  BA_BG2_OTP_STATUS_DAT_rkek_status		 0x00000
	/* ---:--- */	#define	    bBG2_OTP_STATUS_DAT_rkek_status		    2 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_STATUS_DAT_rkek_status		    2 /*: 3*/
	/* ---:--- */	#define	MSK32BG2_OTP_STATUS_DAT_rkek_status		       0x0000000C
	/* ---:--- */	#define	GET32BG2_OTP_STATUS_DAT_rkek_status(r32)	 (((r32)>> 2)&0x0003)
	/* ---:--- */	#define	GET16BG2_OTP_STATUS_DAT_rkek_status(r16)	 (((r16)>> 2)&0x0003)
	/* ---:--- */	#define	SET32BG2_OTP_STATUS_DAT_rkek_status(r32,v)	do{(r32)&=~(0x0003<< 2);(r32)|=((v)&0x0003)<< 2;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_STATUS_DAT_rkek_status(r16,v)	do{(r16)&=~(0x0003<< 2);(r16)|=((v)&0x0003)<< 2;}while(0)

	/* [ 5: 4] */	#define	  BA_BG2_OTP_STATUS_DAT_aesk_status		 0x00000
	/* ---:--- */	#define	    bBG2_OTP_STATUS_DAT_aesk_status		    2 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_STATUS_DAT_aesk_status		    4 /*: 5*/
	/* ---:--- */	#define	MSK32BG2_OTP_STATUS_DAT_aesk_status		       0x00000030
	/* ---:--- */	#define	GET32BG2_OTP_STATUS_DAT_aesk_status(r32)	 (((r32)>> 4)&0x0003)
	/* ---:--- */	#define	GET16BG2_OTP_STATUS_DAT_aesk_status(r16)	 (((r16)>> 4)&0x0003)
	/* ---:--- */	#define	SET32BG2_OTP_STATUS_DAT_aesk_status(r32,v)	do{(r32)&=~(0x0003<< 4);(r32)|=((v)&0x0003)<< 4;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_STATUS_DAT_aesk_status(r16,v)	do{(r16)&=~(0x0003<< 4);(r16)|=((v)&0x0003)<< 4;}while(0)

	/* [ 7: 6] */	#define	  BA_BG2_OTP_STATUS_DAT_mdk_status		 0x00000
	/* ---:--- */	#define	    bBG2_OTP_STATUS_DAT_mdk_status		    2 /*bit*/
	/* ---:--- */	#define	LSb32BG2_OTP_STATUS_DAT_mdk_status		    6 /*: 7*/
	/* ---:--- */	#define	MSK32BG2_OTP_STATUS_DAT_mdk_status		       0x000000C0
	/* ---:--- */	#define	GET32BG2_OTP_STATUS_DAT_mdk_status(r32)		 (((r32)>> 6)&0x0003)
	/* ---:--- */	#define	GET16BG2_OTP_STATUS_DAT_mdk_status(r16)		 (((r16)>> 6)&0x0003)
	/* ---:--- */	#define	SET32BG2_OTP_STATUS_DAT_mdk_status(r32,v)	do{(r32)&=~(0x0003<< 6);(r32)|=((v)&0x0003)<< 6;}while(0)
	/* ---:--- */	#define	SET16BG2_OTP_STATUS_DAT_mdk_status(r16,v)	do{(r16)&=~(0x0003<< 6);(r16)|=((v)&0x0003)<< 6;}while(0)

} SIE_BG2_OTP_STATUS;

	#define	dftBG2_OTP_STATUS_DAT 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BG2_OTP_STATUS_DAT;
										} T32BG2_OTP_STATUS_DAT;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	BG2_OTP_STATUS_drvrd (SIE_BG2_OTP_STATUS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	BG2_OTP_STATUS_drvwr (SIE_BG2_OTP_STATUS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	BG2_OTP_STATUS_reset (SIE_BG2_OTP_STATUS *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	BG2_OTP_STATUS_check(p,pie,ps8name,hfpErrLOG)		BG2_OTP_STATUS_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	BG2_OTP_STATUS_print(p,    ps8name,hfpErrLOG)		BG2_OTP_STATUS_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	BG2_OTP_STATUS_cmp   (SIE_BG2_OTP_STATUS *p, SIE_BG2_OTP_STATUS *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	BG2_OTP_STATUS_import(SIE_BG2_OTP_STATUS *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	BG2_OTP_STATUS_export(SIE_BG2_OTP_STATUS *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: BG2_OTP_STATUS
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SECHF_ENTRY
*	@  (P)
*		%unsigned  2  flag  0
*			:  DISABLED  0
*						*  *
*						*  This entry is disabled
*			:  RO  1
*						*  *
*						*  The entry indicate a BIU register space range which is ready only for ARM
*			:  WO  2
*						*  *
*						*  The entry indicate a BIU register space range which is write only for ARM
*			:  RW  3
*						*  *
*						*  The entry indicate a BIU register space range which can be read and written by ARM
*		%unsigned  14  reserved
*						*  *
*						*  Reserved bits
*		%unsigned  16  regSize  0
*						*  *
*						*  The size of the register spaces   in bytes to be configured
*	@  (RW)
*		%unsigned  32  regAddr  0
*						*  *
*						*  Start offset of the register spaces within the secure processor BIU to be configured
*						*  0
**********************************************************************************************************************/
#ifdef	h_SECHF_ENTRY
#else
#define	h_SECHF_ENTRY

#define	\
	AR_SECHF_ENTRY \
		2
#define	\
	AB_SECHF_ENTRY \
		3

typedef struct SIE_SECHF_ENTRY {

	#define	RA_SECHF_ENTRY_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32SECHF_ENTRY_D0th_ 		{										\
					UNSG32				u_flag						 :  2;		\
					UNSG32				u_reserved					 : 14;		\
					UNSG32				u_regSize					 : 16;		\
										}
	/* @'00000 */				struct	w32SECHF_ENTRY_D0th_;

	/* [ 1: 0] */	#define	  BA_SECHF_ENTRY_flag					 0x00000
	/* ---:--- */	#define	    bSECHF_ENTRY_flag					    2 /*bit*/
	/* ---:--- */	#define	LSb32SECHF_ENTRY_flag					    0 /*: 1*/
	/* ---:--- */	#define	MSK32SECHF_ENTRY_flag					       0x00000003
	/* ---:--- */	#define	GET32SECHF_ENTRY_flag(r32)					 (((r32)>> 0)&0x0003)
	/* ---:--- */	#define	GET16SECHF_ENTRY_flag(r16)					 (((r16)>> 0)&0x0003)
	/* ---:--- */	#define	SET32SECHF_ENTRY_flag(r32,v)				do{(r32)&=~(0x0003<< 0);(r32)|=((v)&0x0003)<< 0;}while(0)
	/* ---:--- */	#define	SET16SECHF_ENTRY_flag(r16,v)				do{(r16)&=~(0x0003<< 0);(r16)|=((v)&0x0003)<< 0;}while(0)
					#define	     SECHF_ENTRY_flag_DISABLED					0x0
					#define	     SECHF_ENTRY_flag_RO						0x1
					#define	     SECHF_ENTRY_flag_WO						0x2
					#define	     SECHF_ENTRY_flag_RW						0x3

	/* [15: 2] */	#define	  BA_SECHF_ENTRY_reserved				 0x00000
	/* ---:--- */	#define	    bSECHF_ENTRY_reserved				   14 /*bit*/
	/* ---:--- */	#define	LSb32SECHF_ENTRY_reserved				    2 /*:15*/
	/* ---:--- */	#define	MSK32SECHF_ENTRY_reserved				       0x0000FFFC
	/* ---:--- */	#define	GET32SECHF_ENTRY_reserved(r32)				 (((r32)>> 2)&0x3FFF)
	/* ---:--- */	#define	GET16SECHF_ENTRY_reserved(r16)				 (((r16)>> 2)&0x3FFF)
	/* ---:--- */	#define	SET32SECHF_ENTRY_reserved(r32,v)			do{(r32)&=~(0x3FFF<< 2);(r32)|=((v)&0x3FFF)<< 2;}while(0)
	/* ---:--- */	#define	SET16SECHF_ENTRY_reserved(r16,v)			do{(r16)&=~(0x3FFF<< 2);(r16)|=((v)&0x3FFF)<< 2;}while(0)

	/* [31:16] */	#define	  BA_SECHF_ENTRY_regSize				 0x00002
	/* ---:--- */	#define	    bSECHF_ENTRY_regSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32SECHF_ENTRY_regSize				   16 /*:31*/
	/* ---:--- */	#define	MSK32SECHF_ENTRY_regSize				       0xFFFF0000
	/* ---:--- */	#define	GET32SECHF_ENTRY_regSize(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16SECHF_ENTRY_regSize(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32SECHF_ENTRY_regSize(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16SECHF_ENTRY_regSize(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_SECHF_ENTRY_D1th_ 		ISC_USE_ONLY	0x00004
	#define	w32SECHF_ENTRY_D1th_ 		{										\
					UNSG32				u_regAddr					 : 32;		\
										}
	/* @'00004 */				struct	w32SECHF_ENTRY_D1th_;

	/* [31: 0] */	#define	  BA_SECHF_ENTRY_regAddr				 0x00004
	/* ---:--- */	#define	    bSECHF_ENTRY_regAddr				   32 /*bit*/
	/* ---:--- */	#define	LSb32SECHF_ENTRY_regAddr				    0 /*:31*/
	/* ---:--- */	#define	MSK32SECHF_ENTRY_regAddr				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SECHF_ENTRY_regAddr(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SECHF_ENTRY_regAddr(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SECHF_ENTRY_regAddr(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SECHF_ENTRY_regAddr(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_SECHF_ENTRY;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SECHF_ENTRY_drvrd (SIE_SECHF_ENTRY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SECHF_ENTRY_drvwr (SIE_SECHF_ENTRY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SECHF_ENTRY_reset (SIE_SECHF_ENTRY *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SECHF_ENTRY_check(p,pie,ps8name,hfpErrLOG)		SECHF_ENTRY_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SECHF_ENTRY_print(p,    ps8name,hfpErrLOG)		SECHF_ENTRY_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SECHF_ENTRY_cmp   (SIE_SECHF_ENTRY *p, SIE_SECHF_ENTRY *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SECHF_ENTRY_import(SIE_SECHF_ENTRY *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SECHF_ENTRY_export(SIE_SECHF_ENTRY *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SECHF_ENTRY
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SECHF
*	@
*		$SECHF_ENTRY  secEntries  [8]
*						*  *
*						*  The entries to define accessible range of the secure processor of the BIU
**********************************************************************************************************************/
#ifdef	h_SECHF
#else
#define	h_SECHF

#define	\
	AR_SECHF \
		2
#define	\
	AB_SECHF \
		3

typedef struct SIE_SECHF {

	#define	RA_SECHF_secEntries 		0x00000
	/* @'00000 */	SIE_SECHF_ENTRY 			ie_secEntries;

} SIE_SECHF;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SECHF_drvrd (SIE_SECHF *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SECHF_drvwr (SIE_SECHF *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SECHF_reset (SIE_SECHF *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SECHF_check(p,pie,ps8name,hfpErrLOG)		SECHF_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SECHF_print(p,    ps8name,hfpErrLOG)		SECHF_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SECHF_cmp   (SIE_SECHF *p, SIE_SECHF *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SECHF_import(SIE_SECHF *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SECHF_export(SIE_SECHF *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SECHF
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: JTAGCTL
*	@
*		%unsigned  1  EN  0
*						*  *
*						*  0 to disable Jtag
*						*  1 to enable Jtag
**********************************************************************************************************************/
#ifdef	h_JTAGCTL
#else
#define	h_JTAGCTL

#define	\
	AR_JTAGCTL \
		1
#define	\
	AB_JTAGCTL \
		2

typedef struct SIE_JTAGCTL {

	#define	RA_JTAGCTL_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32JTAGCTL_D0th_ 			{										\
					UNSG32				u_EN						 :  1;		\
					UNSG32				_x00000	: 31;							\
										}
	/* @'00000 */				struct	w32JTAGCTL_D0th_;

	/* [ 0: 0] */	#define	  BA_JTAGCTL_EN							 0x00000
	/* ---:--- */	#define	    bJTAGCTL_EN							    1 /*bit*/
	/* ---:--- */	#define	LSb32JTAGCTL_EN							    0 /*: 0*/
	/* ---:--- */	#define	MSK32JTAGCTL_EN							       0x00000001
	/* ---:--- */	#define	GET32JTAGCTL_EN(r32)						 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16JTAGCTL_EN(r16)						 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32JTAGCTL_EN(r32,v)						do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16JTAGCTL_EN(r16,v)						do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

} SIE_JTAGCTL;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	JTAGCTL_drvrd (SIE_JTAGCTL *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	JTAGCTL_drvwr (SIE_JTAGCTL *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	JTAGCTL_reset (SIE_JTAGCTL *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	JTAGCTL_check(p,pie,ps8name,hfpErrLOG)		JTAGCTL_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	JTAGCTL_print(p,    ps8name,hfpErrLOG)		JTAGCTL_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	JTAGCTL_cmp   (SIE_JTAGCTL *p, SIE_JTAGCTL *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	JTAGCTL_import(SIE_JTAGCTL *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	JTAGCTL_export(SIE_JTAGCTL *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: JTAGCTL
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: REG64
*		%unsigned  8  b  [8]
**********************************************************************************************************************/
#ifdef	h_REG64
#else
#define	h_REG64

#define	\
	AR_REG64 \
		2
#define	\
	AB_REG64 \
		3

typedef struct SIE_REG64 {

	#define	RA_REG64_D0th_ 				ISC_USE_ONLY	0x00000
	#define	w32REG64_D0th_ 				{										\
					UNSG32				u_b_0i						 :  8;		\
					UNSG32				u_b_1i						 :  8;		\
					UNSG32				u_b_2i						 :  8;		\
					UNSG32				u_b_3i						 :  8;		\
										}
	/* @'00000 */				struct	w32REG64_D0th_;

	/* [ 7: 0] */	#define	  BA_REG64_b_0i							 0x00000
	/* ---:--- */	#define	    bREG64_b_0i							    8 /*bit*/
	/* ---:--- */	#define	LSb32REG64_b_0i							    0 /*: 7*/
	/* ---:--- */	#define	MSK32REG64_b_0i							       0x000000FF
	/* ---:--- */	#define	GET32REG64_b_0i(r32)						 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16REG64_b_0i(r16)						 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32REG64_b_0i(r32,v)						do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16REG64_b_0i(r16,v)						do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_REG64_b_1i							 0x00001
	/* ---:--- */	#define	    bREG64_b_1i							    8 /*bit*/
	/* ---:--- */	#define	LSb32REG64_b_1i							    8 /*:15*/
	/* ---:--- */	#define	MSK32REG64_b_1i							       0x0000FF00
	/* ---:--- */	#define	GET32REG64_b_1i(r32)						 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16REG64_b_1i(r16)						 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32REG64_b_1i(r32,v)						do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16REG64_b_1i(r16,v)						do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [23:16] */	#define	  BA_REG64_b_2i							 0x00002
	/* ---:--- */	#define	    bREG64_b_2i							    8 /*bit*/
	/* ---:--- */	#define	LSb32REG64_b_2i							   16 /*:23*/
	/* ---:--- */	#define	MSK32REG64_b_2i							       0x00FF0000
	/* ---:--- */	#define	GET32REG64_b_2i(r32)						 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16REG64_b_2i(r16)						 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32REG64_b_2i(r32,v)						do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16REG64_b_2i(r16,v)						do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_REG64_b_3i							 0x00003
	/* ---:--- */	#define	    bREG64_b_3i							    8 /*bit*/
	/* ---:--- */	#define	LSb32REG64_b_3i							   24 /*:31*/
	/* ---:--- */	#define	MSK32REG64_b_3i							       0xFF000000
	/* ---:--- */	#define	GET32REG64_b_3i(r32)						 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16REG64_b_3i(r16)						 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32REG64_b_3i(r32,v)						do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16REG64_b_3i(r16,v)						do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_REG64_D1th_ 				ISC_USE_ONLY	0x00004
	#define	w32REG64_D1th_ 				{										\
					UNSG32				u_b_4i						 :  8;		\
					UNSG32				u_b_5i						 :  8;		\
					UNSG32				u_b_6i						 :  8;		\
					UNSG32				u_b_7i						 :  8;		\
										}
	/* @'00004 */				struct	w32REG64_D1th_;

	/* [ 7: 0] */	#define	  BA_REG64_b_4i							 0x00004
	/* ---:--- */	#define	    bREG64_b_4i							    8 /*bit*/
	/* ---:--- */	#define	LSb32REG64_b_4i							    0 /*: 7*/
	/* ---:--- */	#define	MSK32REG64_b_4i							       0x000000FF
	/* ---:--- */	#define	GET32REG64_b_4i(r32)						 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16REG64_b_4i(r16)						 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32REG64_b_4i(r32,v)						do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16REG64_b_4i(r16,v)						do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_REG64_b_5i							 0x00005
	/* ---:--- */	#define	    bREG64_b_5i							    8 /*bit*/
	/* ---:--- */	#define	LSb32REG64_b_5i							    8 /*:15*/
	/* ---:--- */	#define	MSK32REG64_b_5i							       0x0000FF00
	/* ---:--- */	#define	GET32REG64_b_5i(r32)						 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16REG64_b_5i(r16)						 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32REG64_b_5i(r32,v)						do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16REG64_b_5i(r16,v)						do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [23:16] */	#define	  BA_REG64_b_6i							 0x00006
	/* ---:--- */	#define	    bREG64_b_6i							    8 /*bit*/
	/* ---:--- */	#define	LSb32REG64_b_6i							   16 /*:23*/
	/* ---:--- */	#define	MSK32REG64_b_6i							       0x00FF0000
	/* ---:--- */	#define	GET32REG64_b_6i(r32)						 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16REG64_b_6i(r16)						 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32REG64_b_6i(r32,v)						do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16REG64_b_6i(r16,v)						do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_REG64_b_7i							 0x00007
	/* ---:--- */	#define	    bREG64_b_7i							    8 /*bit*/
	/* ---:--- */	#define	LSb32REG64_b_7i							   24 /*:31*/
	/* ---:--- */	#define	MSK32REG64_b_7i							       0xFF000000
	/* ---:--- */	#define	GET32REG64_b_7i(r32)						 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16REG64_b_7i(r16)						 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32REG64_b_7i(r32,v)						do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16REG64_b_7i(r16,v)						do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

} SIE_REG64;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	REG64_drvrd (SIE_REG64 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	REG64_drvwr (SIE_REG64 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	REG64_reset (SIE_REG64 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	REG64_check(p,pie,ps8name,hfpErrLOG)		REG64_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	REG64_print(p,    ps8name,hfpErrLOG)		REG64_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	REG64_cmp   (SIE_REG64 *p, SIE_REG64 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	REG64_import(SIE_REG64 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	REG64_export(SIE_REG64 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: REG64
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: A64Par
*	@
*		%unsigned  4  s0  0
*		%unsigned  4  s1  0
*		%unsigned  4  s2  0
*		%unsigned  4  d0  0
**********************************************************************************************************************/
#ifdef	h_A64Par
#else
#define	h_A64Par

#define	\
	AR_A64Par \
		1
#define	\
	AB_A64Par \
		2

typedef struct SIE_A64Par {

	#define	RA_A64Par_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32A64Par_D0th_ 			{										\
					UNSG32				u_s0						 :  4;		\
					UNSG32				u_s1						 :  4;		\
					UNSG32				u_s2						 :  4;		\
					UNSG32				u_d0						 :  4;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32A64Par_D0th_;

	/* [ 3: 0] */	#define	  BA_A64Par_s0							 0x00000
	/* ---:--- */	#define	    bA64Par_s0							    4 /*bit*/
	/* ---:--- */	#define	LSb32A64Par_s0							    0 /*: 3*/
	/* ---:--- */	#define	MSK32A64Par_s0							       0x0000000F
	/* ---:--- */	#define	GET32A64Par_s0(r32)							 (((r32)>> 0)&0x000F)
	/* ---:--- */	#define	GET16A64Par_s0(r16)							 (((r16)>> 0)&0x000F)
	/* ---:--- */	#define	SET32A64Par_s0(r32,v)						do{(r32)&=~(0x000F<< 0);(r32)|=((v)&0x000F)<< 0;}while(0)
	/* ---:--- */	#define	SET16A64Par_s0(r16,v)						do{(r16)&=~(0x000F<< 0);(r16)|=((v)&0x000F)<< 0;}while(0)

	/* [ 7: 4] */	#define	  BA_A64Par_s1							 0x00000
	/* ---:--- */	#define	    bA64Par_s1							    4 /*bit*/
	/* ---:--- */	#define	LSb32A64Par_s1							    4 /*: 7*/
	/* ---:--- */	#define	MSK32A64Par_s1							       0x000000F0
	/* ---:--- */	#define	GET32A64Par_s1(r32)							 (((r32)>> 4)&0x000F)
	/* ---:--- */	#define	GET16A64Par_s1(r16)							 (((r16)>> 4)&0x000F)
	/* ---:--- */	#define	SET32A64Par_s1(r32,v)						do{(r32)&=~(0x000F<< 4);(r32)|=((v)&0x000F)<< 4;}while(0)
	/* ---:--- */	#define	SET16A64Par_s1(r16,v)						do{(r16)&=~(0x000F<< 4);(r16)|=((v)&0x000F)<< 4;}while(0)

	/* [11: 8] */	#define	  BA_A64Par_s2							 0x00001
	/* ---:--- */	#define	    bA64Par_s2							    4 /*bit*/
	/* ---:--- */	#define	LSb32A64Par_s2							    8 /*:11*/
	/* ---:--- */	#define	MSK32A64Par_s2							       0x00000F00
	/* ---:--- */	#define	GET32A64Par_s2(r32)							 (((r32)>> 8)&0x000F)
	/* ---:--- */	#define	GET16A64Par_s2(r16)							 (((r16)>> 8)&0x000F)
	/* ---:--- */	#define	SET32A64Par_s2(r32,v)						do{(r32)&=~(0x000F<< 8);(r32)|=((v)&0x000F)<< 8;}while(0)
	/* ---:--- */	#define	SET16A64Par_s2(r16,v)						do{(r16)&=~(0x000F<< 8);(r16)|=((v)&0x000F)<< 8;}while(0)

	/* [15:12] */	#define	  BA_A64Par_d0							 0x00001
	/* ---:--- */	#define	    bA64Par_d0							    4 /*bit*/
	/* ---:--- */	#define	LSb32A64Par_d0							   12 /*:15*/
	/* ---:--- */	#define	MSK32A64Par_d0							       0x0000F000
	/* ---:--- */	#define	GET32A64Par_d0(r32)							 (((r32)>>12)&0x000F)
	/* ---:--- */	#define	GET16A64Par_d0(r16)							 (((r16)>>12)&0x000F)
	/* ---:--- */	#define	SET32A64Par_d0(r32,v)						do{(r32)&=~(0x000F<<12);(r32)|=((v)&0x000F)<<12;}while(0)
	/* ---:--- */	#define	SET16A64Par_d0(r16,v)						do{(r16)&=~(0x000F<<12);(r16)|=((v)&0x000F)<<12;}while(0)

} SIE_A64Par;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	A64Par_drvrd (SIE_A64Par *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	A64Par_drvwr (SIE_A64Par *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	A64Par_reset (SIE_A64Par *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	A64Par_check(p,pie,ps8name,hfpErrLOG)		A64Par_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	A64Par_print(p,    ps8name,hfpErrLOG)		A64Par_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	A64Par_cmp   (SIE_A64Par *p, SIE_A64Par *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	A64Par_import(SIE_A64Par *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	A64Par_export(SIE_A64Par *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: A64Par
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: K6
*	@
*		%unsigned  1  Re0  0
*		%unsigned  1  Re1  0
*		%unsigned  1  Re2  0
*		%unsigned  1  We  0
*		%unsigned  1  reserved1  0
*		%unsigned  1  reserved2  0
**********************************************************************************************************************/
#ifdef	h_K6
#else
#define	h_K6

#define	\
	AR_K6 \
		1
#define	\
	AB_K6 \
		2

typedef struct SIE_K6 {

	#define	RA_K6_D0th_ 				ISC_USE_ONLY	0x00000
	#define	w32K6_D0th_ 				{										\
					UNSG32				u_Re0						 :  1;		\
					UNSG32				u_Re1						 :  1;		\
					UNSG32				u_Re2						 :  1;		\
					UNSG32				u_We						 :  1;		\
					UNSG32				u_reserved1					 :  1;		\
					UNSG32				u_reserved2					 :  1;		\
					UNSG32				_x00000	: 26;							\
										}
	/* @'00000 */				struct	w32K6_D0th_;

	/* [ 0: 0] */	#define	  BA_K6_Re0								 0x00000
	/* ---:--- */	#define	    bK6_Re0								    1 /*bit*/
	/* ---:--- */	#define	LSb32K6_Re0								    0 /*: 0*/
	/* ---:--- */	#define	MSK32K6_Re0								       0x00000001
	/* ---:--- */	#define	GET32K6_Re0(r32)							 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16K6_Re0(r16)							 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32K6_Re0(r32,v)							do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16K6_Re0(r16,v)							do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [ 1: 1] */	#define	  BA_K6_Re1								 0x00000
	/* ---:--- */	#define	    bK6_Re1								    1 /*bit*/
	/* ---:--- */	#define	LSb32K6_Re1								    1 /*: 1*/
	/* ---:--- */	#define	MSK32K6_Re1								       0x00000002
	/* ---:--- */	#define	GET32K6_Re1(r32)							 (((r32)>> 1)&0x0001)
	/* ---:--- */	#define	GET16K6_Re1(r16)							 (((r16)>> 1)&0x0001)
	/* ---:--- */	#define	SET32K6_Re1(r32,v)							do{(r32)&=~(0x0001<< 1);(r32)|=((v)&0x0001)<< 1;}while(0)
	/* ---:--- */	#define	SET16K6_Re1(r16,v)							do{(r16)&=~(0x0001<< 1);(r16)|=((v)&0x0001)<< 1;}while(0)

	/* [ 2: 2] */	#define	  BA_K6_Re2								 0x00000
	/* ---:--- */	#define	    bK6_Re2								    1 /*bit*/
	/* ---:--- */	#define	LSb32K6_Re2								    2 /*: 2*/
	/* ---:--- */	#define	MSK32K6_Re2								       0x00000004
	/* ---:--- */	#define	GET32K6_Re2(r32)							 (((r32)>> 2)&0x0001)
	/* ---:--- */	#define	GET16K6_Re2(r16)							 (((r16)>> 2)&0x0001)
	/* ---:--- */	#define	SET32K6_Re2(r32,v)							do{(r32)&=~(0x0001<< 2);(r32)|=((v)&0x0001)<< 2;}while(0)
	/* ---:--- */	#define	SET16K6_Re2(r16,v)							do{(r16)&=~(0x0001<< 2);(r16)|=((v)&0x0001)<< 2;}while(0)

	/* [ 3: 3] */	#define	  BA_K6_We								 0x00000
	/* ---:--- */	#define	    bK6_We								    1 /*bit*/
	/* ---:--- */	#define	LSb32K6_We								    3 /*: 3*/
	/* ---:--- */	#define	MSK32K6_We								       0x00000008
	/* ---:--- */	#define	GET32K6_We(r32)								 (((r32)>> 3)&0x0001)
	/* ---:--- */	#define	GET16K6_We(r16)								 (((r16)>> 3)&0x0001)
	/* ---:--- */	#define	SET32K6_We(r32,v)							do{(r32)&=~(0x0001<< 3);(r32)|=((v)&0x0001)<< 3;}while(0)
	/* ---:--- */	#define	SET16K6_We(r16,v)							do{(r16)&=~(0x0001<< 3);(r16)|=((v)&0x0001)<< 3;}while(0)

	/* [ 4: 4] */	#define	  BA_K6_reserved1						 0x00000
	/* ---:--- */	#define	    bK6_reserved1						    1 /*bit*/
	/* ---:--- */	#define	LSb32K6_reserved1						    4 /*: 4*/
	/* ---:--- */	#define	MSK32K6_reserved1						       0x00000010
	/* ---:--- */	#define	GET32K6_reserved1(r32)						 (((r32)>> 4)&0x0001)
	/* ---:--- */	#define	GET16K6_reserved1(r16)						 (((r16)>> 4)&0x0001)
	/* ---:--- */	#define	SET32K6_reserved1(r32,v)					do{(r32)&=~(0x0001<< 4);(r32)|=((v)&0x0001)<< 4;}while(0)
	/* ---:--- */	#define	SET16K6_reserved1(r16,v)					do{(r16)&=~(0x0001<< 4);(r16)|=((v)&0x0001)<< 4;}while(0)

	/* [ 5: 5] */	#define	  BA_K6_reserved2						 0x00000
	/* ---:--- */	#define	    bK6_reserved2						    1 /*bit*/
	/* ---:--- */	#define	LSb32K6_reserved2						    5 /*: 5*/
	/* ---:--- */	#define	MSK32K6_reserved2						       0x00000020
	/* ---:--- */	#define	GET32K6_reserved2(r32)						 (((r32)>> 5)&0x0001)
	/* ---:--- */	#define	GET16K6_reserved2(r16)						 (((r16)>> 5)&0x0001)
	/* ---:--- */	#define	SET32K6_reserved2(r32,v)					do{(r32)&=~(0x0001<< 5);(r32)|=((v)&0x0001)<< 5;}while(0)
	/* ---:--- */	#define	SET16K6_reserved2(r16,v)					do{(r16)&=~(0x0001<< 5);(r16)|=((v)&0x0001)<< 5;}while(0)

} SIE_K6;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	K6_drvrd (SIE_K6 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	K6_drvwr (SIE_K6 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	K6_reset (SIE_K6 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	K6_check(p,pie,ps8name,hfpErrLOG)		K6_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	K6_print(p,    ps8name,hfpErrLOG)		K6_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	K6_cmp   (SIE_K6 *p, SIE_K6 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	K6_import(SIE_K6 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	K6_export(SIE_K6 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: K6
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMPushID
*	@
*		%unsigned  2  OP  0
*			:  PUSH  0x0
*			:  RSV  0x1
*			:  TBINIT  0x2
*			:  EXE0  0x3
*		%unsigned  4  OPCSEL
**********************************************************************************************************************/
#ifdef	h_DRMPushID
#else
#define	h_DRMPushID

#define	\
	AR_DRMPushID \
		1
#define	\
	AB_DRMPushID \
		2

typedef struct SIE_DRMPushID {

	#define	RA_DRMPushID_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32DRMPushID_D0th_ 			{										\
					UNSG32				u_OP						 :  2;		\
					UNSG32				u_OPCSEL					 :  4;		\
					UNSG32				_x00000	: 26;							\
										}
	/* @'00000 */				struct	w32DRMPushID_D0th_;

	/* [ 1: 0] */	#define	  BA_DRMPushID_OP						 0x00000
	/* ---:--- */	#define	    bDRMPushID_OP						    2 /*bit*/
	/* ---:--- */	#define	LSb32DRMPushID_OP						    0 /*: 1*/
	/* ---:--- */	#define	MSK32DRMPushID_OP						       0x00000003
	/* ---:--- */	#define	GET32DRMPushID_OP(r32)						 (((r32)>> 0)&0x0003)
	/* ---:--- */	#define	GET16DRMPushID_OP(r16)						 (((r16)>> 0)&0x0003)
	/* ---:--- */	#define	SET32DRMPushID_OP(r32,v)					do{(r32)&=~(0x0003<< 0);(r32)|=((v)&0x0003)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMPushID_OP(r16,v)					do{(r16)&=~(0x0003<< 0);(r16)|=((v)&0x0003)<< 0;}while(0)
					#define	     DRMPushID_OP_PUSH							0x0
					#define	     DRMPushID_OP_RSV							0x1
					#define	     DRMPushID_OP_TBINIT						0x2
					#define	     DRMPushID_OP_EXE0							0x3

	/* [ 5: 2] */	#define	  BA_DRMPushID_OPCSEL					 0x00000
	/* ---:--- */	#define	    bDRMPushID_OPCSEL					    4 /*bit*/
	/* ---:--- */	#define	LSb32DRMPushID_OPCSEL					    2 /*: 5*/
	/* ---:--- */	#define	MSK32DRMPushID_OPCSEL					       0x0000003C
	/* ---:--- */	#define	GET32DRMPushID_OPCSEL(r32)					 (((r32)>> 2)&0x000F)
	/* ---:--- */	#define	GET16DRMPushID_OPCSEL(r16)					 (((r16)>> 2)&0x000F)
	/* ---:--- */	#define	SET32DRMPushID_OPCSEL(r32,v)				do{(r32)&=~(0x000F<< 2);(r32)|=((v)&0x000F)<< 2;}while(0)
	/* ---:--- */	#define	SET16DRMPushID_OPCSEL(r16,v)				do{(r16)&=~(0x000F<< 2);(r16)|=((v)&0x000F)<< 2;}while(0)

} SIE_DRMPushID;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMPushID_drvrd (SIE_DRMPushID *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMPushID_drvwr (SIE_DRMPushID *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMPushID_reset (SIE_DRMPushID *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMPushID_check(p,pie,ps8name,hfpErrLOG)		DRMPushID_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMPushID_print(p,    ps8name,hfpErrLOG)		DRMPushID_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMPushID_cmp   (SIE_DRMPushID *p, SIE_DRMPushID *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMPushID_import(SIE_DRMPushID *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMPushID_export(SIE_DRMPushID *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMPushID
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: A64Entry
*		$DRMPushID  pushID  0
*		$A64Par  a64Par  0
*		$REG64  xT  0
*		$K6  k6
*		$REG64  r64Before  REG  [16]
*		$REG64  r64After  REG  [16]
**********************************************************************************************************************/
#ifdef	h_A64Entry
#else
#define	h_A64Entry

#define	\
	AR_A64Entry \
		69
#define	\
	AB_A64Entry \
		9

typedef struct SIE_A64Entry {

	#define	RA_A64Entry_pushID 			0x00000
	/* @'00000 */	SIE_DRMPushID 				ie_pushID;

	#define	RA_A64Entry_a64Par 			0x00004
	/* @'00004 */	SIE_A64Par 					ie_a64Par;

	#define	RA_A64Entry_xT 				0x00008
	/* @'00008 */	SIE_REG64 					ie_xT;

	#define	RA_A64Entry_k6 				0x00010
	/* @'00010 */	SIE_K6 						ie_k6;

	#define	RA_A64Entry_r64Before 		0x00014
	/* @'00014 */	SIE_REG64 					ie_r64Before		 [16];
					#define	 arr_A64Entry_r64Before 				  16

	#define	RA_A64Entry_r64After 		0x00094
	/* @'00094 */	SIE_REG64 					ie_r64After			 [16];
					#define	 arr_A64Entry_r64After 					  16

} SIE_A64Entry;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	A64Entry_drvrd (SIE_A64Entry *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	A64Entry_drvwr (SIE_A64Entry *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	A64Entry_reset (SIE_A64Entry *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	A64Entry_check(p,pie,ps8name,hfpErrLOG)		A64Entry_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	A64Entry_print(p,    ps8name,hfpErrLOG)		A64Entry_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	A64Entry_cmp   (SIE_A64Entry *p, SIE_A64Entry *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	A64Entry_import(SIE_A64Entry *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	A64Entry_export(SIE_A64Entry *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: A64Entry
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_CTXTYPE
*	@
*			:  AES
*						*  *
*						*  128 bits AES
*			:  DES
*						*  *
*						*  64 bits DES
*			:  3xDES
*						*  *
*			:  RSA1024
*			:  RSA2048
*			:  SHA1
*			:  HMAC
*			:  CMAC
*	@
*		%unsigned  32  dummy
**********************************************************************************************************************/
#ifdef	h_DRM_CTXTYPE
#else
#define	h_DRM_CTXTYPE

#define	\
	AR_DRM_CTXTYPE \
		1
#define	\
	AB_DRM_CTXTYPE \
		2

typedef struct SIE_DRM_CTXTYPE {

	#define	RA_DRM_CTXTYPE_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32DRM_CTXTYPE_D0th_ 		{										\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32DRM_CTXTYPE_D0th_;

	/* [31: 0] */	#define	  BA_DRM_CTXTYPE_dummy					 0x00000
	/* ---:--- */	#define	    bDRM_CTXTYPE_dummy					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXTYPE_dummy					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_CTXTYPE_dummy					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_CTXTYPE_dummy(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_CTXTYPE_dummy(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_CTXTYPE_dummy(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXTYPE_dummy(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRM_CTXTYPE;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_CTXTYPE_drvrd (SIE_DRM_CTXTYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_CTXTYPE_drvwr (SIE_DRM_CTXTYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_CTXTYPE_reset (SIE_DRM_CTXTYPE *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_CTXTYPE_check(p,pie,ps8name,hfpErrLOG)		DRM_CTXTYPE_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_CTXTYPE_print(p,    ps8name,hfpErrLOG)		DRM_CTXTYPE_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_CTXTYPE_cmp   (SIE_DRM_CTXTYPE *p, SIE_DRM_CTXTYPE *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_CTXTYPE_import(SIE_DRM_CTXTYPE *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_CTXTYPE_export(SIE_DRM_CTXTYPE *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_CTXTYPE
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_CTXHDR
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved
*						*  *
*						*  Key parameter
**********************************************************************************************************************/
#ifdef	h_DRM_CTXHDR
#else
#define	h_DRM_CTXHDR

#define	\
	AR_DRM_CTXHDR \
		2
#define	\
	AB_DRM_CTXHDR \
		3

typedef struct SIE_DRM_CTXHDR {

	#define	RA_DRM_CTXHDR_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32DRM_CTXHDR_D0th_ 		{										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_CTXHDR_D0th_;

	/* [15: 0] */	#define	  BA_DRM_CTXHDR_ctxSize					 0x00000
	/* ---:--- */	#define	    bDRM_CTXHDR_ctxSize					   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXHDR_ctxSize					    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_CTXHDR_ctxSize					       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_CTXHDR_ctxSize(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_CTXHDR_ctxSize(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_CTXHDR_ctxSize(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXHDR_ctxSize(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_CTXHDR_ctxType					 0x00002
	/* ---:--- */	#define	    bDRM_CTXHDR_ctxType					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXHDR_ctxType					   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_CTXHDR_ctxType					       0x00FF0000
	/* ---:--- */	#define	GET32DRM_CTXHDR_ctxType(r32)				 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_CTXHDR_ctxType(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_CTXHDR_ctxType(r32,v)				do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXHDR_ctxType(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_CTXHDR_D1th_ 		ISC_USE_ONLY	0x00004
	#define	w32DRM_CTXHDR_D1th_ 		{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_CTXHDR_D1th_;

	/* [31: 0] */	#define	  BA_DRM_CTXHDR_reserved				 0x00004
	/* ---:--- */	#define	    bDRM_CTXHDR_reserved				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXHDR_reserved				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_CTXHDR_reserved				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_CTXHDR_reserved(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_CTXHDR_reserved(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_CTXHDR_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXHDR_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRM_CTXHDR;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_CTXHDR_drvrd (SIE_DRM_CTXHDR *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_CTXHDR_drvwr (SIE_DRM_CTXHDR *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_CTXHDR_reset (SIE_DRM_CTXHDR *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_CTXHDR_check(p,pie,ps8name,hfpErrLOG)		DRM_CTXHDR_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_CTXHDR_print(p,    ps8name,hfpErrLOG)		DRM_CTXHDR_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_CTXHDR_cmp   (SIE_DRM_CTXHDR *p, SIE_DRM_CTXHDR *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_CTXHDR_import(SIE_DRM_CTXHDR *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_CTXHDR_export(SIE_DRM_CTXHDR *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_CTXHDR
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_SIGNTYPE
*	@  DAT
*		%unsigned  8  typeID
*						*  *
*						*  type ID
*			:  CMAC  0x00
*						*  *
*						*  CMAC
*			:  RSAPSS  0x02
*						*  *
*						*  RSA-PSS signature
*			:  INVALID  0xff
**********************************************************************************************************************/
#ifdef	h_DRM_SIGNTYPE
#else
#define	h_DRM_SIGNTYPE

#define	\
	AR_DRM_SIGNTYPE \
		1
#define	\
	AB_DRM_SIGNTYPE \
		2

typedef struct SIE_DRM_SIGNTYPE {

	#define	RA_DRM_SIGNTYPE_DAT 		0x00000
	#define	w32DRM_SIGNTYPE_DAT 		{										\
					UNSG32				uDAT_typeID					 :  8;		\
					UNSG32				_x00000	: 24;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRM_SIGNTYPE_DAT;
								struct	w32DRM_SIGNTYPE_DAT;
										};

	/* [ 7: 0] */	#define	  BA_DRM_SIGNTYPE_DAT_typeID			 0x00000
	/* ---:--- */	#define	    bDRM_SIGNTYPE_DAT_typeID			    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SIGNTYPE_DAT_typeID			    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_SIGNTYPE_DAT_typeID			       0x000000FF
	/* ---:--- */	#define	GET32DRM_SIGNTYPE_DAT_typeID(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_SIGNTYPE_DAT_typeID(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_SIGNTYPE_DAT_typeID(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SIGNTYPE_DAT_typeID(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRM_SIGNTYPE_DAT_typeID_CMAC				0x0
					#define	     DRM_SIGNTYPE_DAT_typeID_RSAPSS				0x2
					#define	     DRM_SIGNTYPE_DAT_typeID_INVALID			0xFF

} SIE_DRM_SIGNTYPE;

	#define	dftDRM_SIGNTYPE_DAT 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_SIGNTYPE_DAT;
										} T32DRM_SIGNTYPE_DAT;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_SIGNTYPE_drvrd (SIE_DRM_SIGNTYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_SIGNTYPE_drvwr (SIE_DRM_SIGNTYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_SIGNTYPE_reset (SIE_DRM_SIGNTYPE *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_SIGNTYPE_check(p,pie,ps8name,hfpErrLOG)		DRM_SIGNTYPE_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_SIGNTYPE_print(p,    ps8name,hfpErrLOG)		DRM_SIGNTYPE_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_SIGNTYPE_cmp   (SIE_DRM_SIGNTYPE *p, SIE_DRM_SIGNTYPE *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_SIGNTYPE_import(SIE_DRM_SIGNTYPE *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_SIGNTYPE_export(SIE_DRM_SIGNTYPE *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_SIGNTYPE
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_CTXID
*	@  DAT
*		%unsigned  8  ctxID
*						*  *
*						*  Context ID
*			:  RKEK  0x01
*						*  *
*						*  Root Key wrapping key ID
*			:  SIGNK  0x02
*						*  *
*						*  Signature key
*			:  AESK  0x04
*						*  *
*						*  AES key wrapping key ID index aes area in OTP
*			:  ROMKEY  0x10
*						*  *
*						*  ROM key
*			:  UKEY  0x80
*						*  *
*						*  User key id start
*			:  INVALID  0xff
**********************************************************************************************************************/
#ifdef	h_DRM_CTXID
#else
#define	h_DRM_CTXID

#define	\
	AR_DRM_CTXID \
		1
#define	\
	AB_DRM_CTXID \
		2

typedef struct SIE_DRM_CTXID {

	#define	RA_DRM_CTXID_DAT 			0x00000
	#define	w32DRM_CTXID_DAT 			{										\
					UNSG32				uDAT_ctxID					 :  8;		\
					UNSG32				_x00000	: 24;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRM_CTXID_DAT;
								struct	w32DRM_CTXID_DAT;
										};

	/* [ 7: 0] */	#define	  BA_DRM_CTXID_DAT_ctxID				 0x00000
	/* ---:--- */	#define	    bDRM_CTXID_DAT_ctxID				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXID_DAT_ctxID				    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_CTXID_DAT_ctxID				       0x000000FF
	/* ---:--- */	#define	GET32DRM_CTXID_DAT_ctxID(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_CTXID_DAT_ctxID(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_CTXID_DAT_ctxID(r32,v)				do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXID_DAT_ctxID(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRM_CTXID_DAT_ctxID_RKEK					0x1
					#define	     DRM_CTXID_DAT_ctxID_SIGNK					0x2
					#define	     DRM_CTXID_DAT_ctxID_AESK					0x4
					#define	     DRM_CTXID_DAT_ctxID_ROMKEY					0x10
					#define	     DRM_CTXID_DAT_ctxID_UKEY					0x80
					#define	     DRM_CTXID_DAT_ctxID_INVALID				0xFF

} SIE_DRM_CTXID;

	#define	dftDRM_CTXID_DAT 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_CTXID_DAT;
										} T32DRM_CTXID_DAT;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_CTXID_drvrd (SIE_DRM_CTXID *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_CTXID_drvwr (SIE_DRM_CTXID *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_CTXID_reset (SIE_DRM_CTXID *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_CTXID_check(p,pie,ps8name,hfpErrLOG)		DRM_CTXID_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_CTXID_print(p,    ps8name,hfpErrLOG)		DRM_CTXID_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_CTXID_cmp   (SIE_DRM_CTXID *p, SIE_DRM_CTXID *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_CTXID_import(SIE_DRM_CTXID *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_CTXID_export(SIE_DRM_CTXID *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_CTXID
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_BG2_CTXID
*	@  DAT
*		%unsigned  8  ctxID
*						*  *
*						*  Context ID
*			:  RKEK  0x01
*						*  *
*						*  Root Key wrapping key ID
*			:  SIGNK  0x02
*						*  *
*						*  Signature key
*			:  AESK  0x03
*						*  *
*						*  AES key wrapping key ID index aes area in OTP
*			:  MDK  0x04
*						*  *
*						*  Marvell Distribution Key which is a dedicated AES 128 Key for Marvell use only
*			:  ROMKEY  0x10
*						*  *
*						*  ROM key
*			:  UKEY  0x80
*						*  *
*						*  User key id start
*			:  INVALID  0xff
**********************************************************************************************************************/
#ifdef	h_DRM_BG2_CTXID
#else
#define	h_DRM_BG2_CTXID

#define	\
	AR_DRM_BG2_CTXID \
		1
#define	\
	AB_DRM_BG2_CTXID \
		2

typedef struct SIE_DRM_BG2_CTXID {

	#define	RA_DRM_BG2_CTXID_DAT 		0x00000
	#define	w32DRM_BG2_CTXID_DAT 		{										\
					UNSG32				uDAT_ctxID					 :  8;		\
					UNSG32				_x00000	: 24;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRM_BG2_CTXID_DAT;
								struct	w32DRM_BG2_CTXID_DAT;
										};

	/* [ 7: 0] */	#define	  BA_DRM_BG2_CTXID_DAT_ctxID			 0x00000
	/* ---:--- */	#define	    bDRM_BG2_CTXID_DAT_ctxID			    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_BG2_CTXID_DAT_ctxID			    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_BG2_CTXID_DAT_ctxID			       0x000000FF
	/* ---:--- */	#define	GET32DRM_BG2_CTXID_DAT_ctxID(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_BG2_CTXID_DAT_ctxID(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_BG2_CTXID_DAT_ctxID(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_BG2_CTXID_DAT_ctxID(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRM_BG2_CTXID_DAT_ctxID_RKEK				0x1
					#define	     DRM_BG2_CTXID_DAT_ctxID_SIGNK				0x2
					#define	     DRM_BG2_CTXID_DAT_ctxID_AESK				0x3
					#define	     DRM_BG2_CTXID_DAT_ctxID_MDK				0x4
					#define	     DRM_BG2_CTXID_DAT_ctxID_ROMKEY				0x10
					#define	     DRM_BG2_CTXID_DAT_ctxID_UKEY				0x80
					#define	     DRM_BG2_CTXID_DAT_ctxID_INVALID			0xFF

} SIE_DRM_BG2_CTXID;

	#define	dftDRM_BG2_CTXID_DAT 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_BG2_CTXID_DAT;
										} T32DRM_BG2_CTXID_DAT;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_BG2_CTXID_drvrd (SIE_DRM_BG2_CTXID *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_BG2_CTXID_drvwr (SIE_DRM_BG2_CTXID *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_BG2_CTXID_reset (SIE_DRM_BG2_CTXID *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_BG2_CTXID_check(p,pie,ps8name,hfpErrLOG)		DRM_BG2_CTXID_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_BG2_CTXID_print(p,    ps8name,hfpErrLOG)		DRM_BG2_CTXID_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_BG2_CTXID_cmp   (SIE_DRM_BG2_CTXID *p, SIE_DRM_BG2_CTXID *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_BG2_CTXID_import(SIE_DRM_BG2_CTXID *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_BG2_CTXID_export(SIE_DRM_BG2_CTXID *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_BG2_CTXID
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_KEYPARM
*	@
*		$UINT32  keyParm  [8]
*						*  *
*						*  Reserved key parameter data
**********************************************************************************************************************/
#ifdef	h_DRM_KEYPARM
#else
#define	h_DRM_KEYPARM

#define	\
	AR_DRM_KEYPARM \
		1
#define	\
	AB_DRM_KEYPARM \
		2

typedef struct SIE_DRM_KEYPARM {

	#define	RA_DRM_KEYPARM_keyParm 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_keyParm;

} SIE_DRM_KEYPARM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_KEYPARM_drvrd (SIE_DRM_KEYPARM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_KEYPARM_drvwr (SIE_DRM_KEYPARM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_KEYPARM_reset (SIE_DRM_KEYPARM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_KEYPARM_check(p,pie,ps8name,hfpErrLOG)		DRM_KEYPARM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_KEYPARM_print(p,    ps8name,hfpErrLOG)		DRM_KEYPARM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_KEYPARM_cmp   (SIE_DRM_KEYPARM *p, SIE_DRM_KEYPARM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_KEYPARM_import(SIE_DRM_KEYPARM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_KEYPARM_export(SIE_DRM_KEYPARM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_KEYPARM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_KEYPARM_RSA
*	@
*		%unsigned  16  keyLen
*						*  *
*						*  The size of the RSA key in bits
*		%unsigned  16  numPrimes  0
*						*  *
*						*  the number of prime factors used by this RSA key.
*	@
*		%unsigned  16  exponentSize  0
*						*  *
*						*  the size of the exponent. If the key is using the default exponent then the exponentSize MUST be 0.
**********************************************************************************************************************/
#ifdef	h_DRM_KEYPARM_RSA
#else
#define	h_DRM_KEYPARM_RSA

#define	\
	AR_DRM_KEYPARM_RSA \
		2
#define	\
	AB_DRM_KEYPARM_RSA \
		3

typedef struct SIE_DRM_KEYPARM_RSA {

	#define	RA_DRM_KEYPARM_RSA_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRM_KEYPARM_RSA_D0th_ 	{										\
					UNSG32				u_keyLen					 : 16;		\
					UNSG32				u_numPrimes					 : 16;		\
										}
	/* @'00000 */				struct	w32DRM_KEYPARM_RSA_D0th_;

	/* [15: 0] */	#define	  BA_DRM_KEYPARM_RSA_keyLen				 0x00000
	/* ---:--- */	#define	    bDRM_KEYPARM_RSA_keyLen				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_RSA_keyLen				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_RSA_keyLen				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYPARM_RSA_keyLen(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_RSA_keyLen(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_RSA_keyLen(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_RSA_keyLen(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_KEYPARM_RSA_numPrimes			 0x00002
	/* ---:--- */	#define	    bDRM_KEYPARM_RSA_numPrimes			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_RSA_numPrimes			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_RSA_numPrimes			       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_KEYPARM_RSA_numPrimes(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_RSA_numPrimes(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_RSA_numPrimes(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_RSA_numPrimes(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_KEYPARM_RSA_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32DRM_KEYPARM_RSA_D1th_ 	{										\
					UNSG32				u_exponentSize				 : 16;		\
					UNSG32				_x00004	: 16;							\
										}
	/* @'00004 */				struct	w32DRM_KEYPARM_RSA_D1th_;

	/* [15: 0] */	#define	  BA_DRM_KEYPARM_RSA_exponentSize		 0x00004
	/* ---:--- */	#define	    bDRM_KEYPARM_RSA_exponentSize		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_RSA_exponentSize		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_RSA_exponentSize		       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYPARM_RSA_exponentSize(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_RSA_exponentSize(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_RSA_exponentSize(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_RSA_exponentSize(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_DRM_KEYPARM_RSA;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_KEYPARM_RSA_drvrd (SIE_DRM_KEYPARM_RSA *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_KEYPARM_RSA_drvwr (SIE_DRM_KEYPARM_RSA *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_KEYPARM_RSA_reset (SIE_DRM_KEYPARM_RSA *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_KEYPARM_RSA_check(p,pie,ps8name,hfpErrLOG)		DRM_KEYPARM_RSA_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_KEYPARM_RSA_print(p,    ps8name,hfpErrLOG)		DRM_KEYPARM_RSA_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_KEYPARM_RSA_cmp   (SIE_DRM_KEYPARM_RSA *p, SIE_DRM_KEYPARM_RSA *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_KEYPARM_RSA_import(SIE_DRM_KEYPARM_RSA *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_KEYPARM_RSA_export(SIE_DRM_KEYPARM_RSA *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_KEYPARM_RSA
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_KEYPARM_SYM
*	@
*		%unsigned  16  keyLen
*						*  *
*						*  indicate the length of the key in bits
*		%unsigned  16  blockSize  0
*						*  *
*						*  indicate the block size of the algorithm
*	@
*		%unsigned  16  ivSiz  0
*						*  *
*						*  indicate the size of the IV
*		%unsigned  16  keyMode  0
*						*  *
*						*  indicate the encryption and decryption mode
*	@
*		$UINT128  ivData  0
*						*  *
*						*  The initialization vector
**********************************************************************************************************************/
#ifdef	h_DRM_KEYPARM_SYM
#else
#define	h_DRM_KEYPARM_SYM

#define	\
	AR_DRM_KEYPARM_SYM \
		6
#define	\
	AB_DRM_KEYPARM_SYM \
		5

typedef struct SIE_DRM_KEYPARM_SYM {

	#define	RA_DRM_KEYPARM_SYM_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRM_KEYPARM_SYM_D0th_ 	{										\
					UNSG32				u_keyLen					 : 16;		\
					UNSG32				u_blockSize					 : 16;		\
										}
	/* @'00000 */				struct	w32DRM_KEYPARM_SYM_D0th_;

	/* [15: 0] */	#define	  BA_DRM_KEYPARM_SYM_keyLen				 0x00000
	/* ---:--- */	#define	    bDRM_KEYPARM_SYM_keyLen				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_SYM_keyLen				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_SYM_keyLen				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYPARM_SYM_keyLen(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_SYM_keyLen(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_SYM_keyLen(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_SYM_keyLen(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_KEYPARM_SYM_blockSize			 0x00002
	/* ---:--- */	#define	    bDRM_KEYPARM_SYM_blockSize			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_SYM_blockSize			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_SYM_blockSize			       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_KEYPARM_SYM_blockSize(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_SYM_blockSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_SYM_blockSize(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_SYM_blockSize(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_KEYPARM_SYM_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32DRM_KEYPARM_SYM_D1th_ 	{										\
					UNSG32				u_ivSiz						 : 16;		\
					UNSG32				u_keyMode					 : 16;		\
										}
	/* @'00004 */				struct	w32DRM_KEYPARM_SYM_D1th_;

	/* [15: 0] */	#define	  BA_DRM_KEYPARM_SYM_ivSiz				 0x00004
	/* ---:--- */	#define	    bDRM_KEYPARM_SYM_ivSiz				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_SYM_ivSiz				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_SYM_ivSiz				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYPARM_SYM_ivSiz(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_SYM_ivSiz(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_SYM_ivSiz(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_SYM_ivSiz(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_KEYPARM_SYM_keyMode			 0x00006
	/* ---:--- */	#define	    bDRM_KEYPARM_SYM_keyMode			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_SYM_keyMode			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_SYM_keyMode			       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_KEYPARM_SYM_keyMode(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_SYM_keyMode(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_SYM_keyMode(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_SYM_keyMode(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_KEYPARM_SYM_ivData 	0x00008
	/* @'00008 */	SIE_UINT128 				ie_ivData;

} SIE_DRM_KEYPARM_SYM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_KEYPARM_SYM_drvrd (SIE_DRM_KEYPARM_SYM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_KEYPARM_SYM_drvwr (SIE_DRM_KEYPARM_SYM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_KEYPARM_SYM_reset (SIE_DRM_KEYPARM_SYM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_KEYPARM_SYM_check(p,pie,ps8name,hfpErrLOG)		DRM_KEYPARM_SYM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_KEYPARM_SYM_print(p,    ps8name,hfpErrLOG)		DRM_KEYPARM_SYM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_KEYPARM_SYM_cmp   (SIE_DRM_KEYPARM_SYM *p, SIE_DRM_KEYPARM_SYM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_KEYPARM_SYM_import(SIE_DRM_KEYPARM_SYM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_KEYPARM_SYM_export(SIE_DRM_KEYPARM_SYM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_KEYPARM_SYM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_DIGEST
*	@
*		$DRM_CTXID  sigKey
*						*  *
*						*  Signature key
*	@
*		%unsigned  8  sigType
*						*  *
*						*  Signature Type
*		%unsigned  8  sigLen  Signature Length
*		%unsigned  16  reserved  reserved
*	@
*		$UINT32  hashVal  REG  [6]
*						*  *
*						*  Digest value
**********************************************************************************************************************/
#ifdef	h_DRM_DIGEST
#else
#define	h_DRM_DIGEST

#define	\
	AR_DRM_DIGEST \
		8
#define	\
	AB_DRM_DIGEST \
		5

typedef struct SIE_DRM_DIGEST {

	#define	RA_DRM_DIGEST_sigKey 		0x00000
	/* @'00000 */	SIE_DRM_CTXID 				ie_sigKey;

	#define	RA_DRM_DIGEST_D1th_ 		ISC_USE_ONLY	0x00004
	#define	w32DRM_DIGEST_D1th_ 		{										\
					UNSG32				u_sigType					 :  8;		\
					UNSG32				u_sigLen					 :  8;		\
					UNSG32				u_reserved					 : 16;		\
										}
	/* @'00004 */				struct	w32DRM_DIGEST_D1th_;

	/* [ 7: 0] */	#define	  BA_DRM_DIGEST_sigType					 0x00004
	/* ---:--- */	#define	    bDRM_DIGEST_sigType					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_DIGEST_sigType					    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_DIGEST_sigType					       0x000000FF
	/* ---:--- */	#define	GET32DRM_DIGEST_sigType(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_DIGEST_sigType(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_DIGEST_sigType(r32,v)				do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_DIGEST_sigType(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_DRM_DIGEST_sigLen					 0x00005
	/* ---:--- */	#define	    bDRM_DIGEST_sigLen					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_DIGEST_sigLen					    8 /*:15*/
	/* ---:--- */	#define	MSK32DRM_DIGEST_sigLen					       0x0000FF00
	/* ---:--- */	#define	GET32DRM_DIGEST_sigLen(r32)					 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16DRM_DIGEST_sigLen(r16)					 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32DRM_DIGEST_sigLen(r32,v)				do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRM_DIGEST_sigLen(r16,v)				do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [31:16] */	#define	  BA_DRM_DIGEST_reserved				 0x00006
	/* ---:--- */	#define	    bDRM_DIGEST_reserved				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_DIGEST_reserved				   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_DIGEST_reserved				       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_DIGEST_reserved(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_DIGEST_reserved(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_DIGEST_reserved(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_DIGEST_reserved(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_DIGEST_hashVal 		0x00008
	/* @'00008 */	SIE_UINT32 					ie_hashVal			 [6];
					#define	 arr_DRM_DIGEST_hashVal 				  6

} SIE_DRM_DIGEST;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_DIGEST_drvrd (SIE_DRM_DIGEST *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_DIGEST_drvwr (SIE_DRM_DIGEST *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_DIGEST_reset (SIE_DRM_DIGEST *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_DIGEST_check(p,pie,ps8name,hfpErrLOG)		DRM_DIGEST_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_DIGEST_print(p,    ps8name,hfpErrLOG)		DRM_DIGEST_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_DIGEST_cmp   (SIE_DRM_DIGEST *p, SIE_DRM_DIGEST *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_DIGEST_import(SIE_DRM_DIGEST *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_DIGEST_export(SIE_DRM_DIGEST *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_DIGEST
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_SUBKEY_OUT
*	@
*		$DRM_CTXID  parentKeyID
*						*  *
*						*  Parent key ID. It can be RKEK ID or SIGNKEY ID
*	@
*		$UINT32  reserved
*	@
*		$UINT32  keyData  REG  [14]
*						*  *
*						*  Sub key cipher text protected by RKEK
**********************************************************************************************************************/
#ifdef	h_DRM_SUBKEY_OUT
#else
#define	h_DRM_SUBKEY_OUT

#define	\
	AR_DRM_SUBKEY_OUT \
		16
#define	\
	AB_DRM_SUBKEY_OUT \
		6

typedef struct SIE_DRM_SUBKEY_OUT {

	#define	RA_DRM_SUBKEY_OUT_parentKeyID 0x00000
	/* @'00000 */	SIE_DRM_CTXID 				ie_parentKeyID;

	#define	RA_DRM_SUBKEY_OUT_reserved 	0x00004
	/* @'00004 */	SIE_UINT32 					ie_reserved;

	#define	RA_DRM_SUBKEY_OUT_keyData 	0x00008
	/* @'00008 */	SIE_UINT32 					ie_keyData			 [14];
					#define	 arr_DRM_SUBKEY_OUT_keyData 			  14

} SIE_DRM_SUBKEY_OUT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_SUBKEY_OUT_drvrd (SIE_DRM_SUBKEY_OUT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_SUBKEY_OUT_drvwr (SIE_DRM_SUBKEY_OUT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_SUBKEY_OUT_reset (SIE_DRM_SUBKEY_OUT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_SUBKEY_OUT_check(p,pie,ps8name,hfpErrLOG)		DRM_SUBKEY_OUT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_SUBKEY_OUT_print(p,    ps8name,hfpErrLOG)		DRM_SUBKEY_OUT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_SUBKEY_OUT_cmp   (SIE_DRM_SUBKEY_OUT *p, SIE_DRM_SUBKEY_OUT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_SUBKEY_OUT_import(SIE_DRM_SUBKEY_OUT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_SUBKEY_OUT_export(SIE_DRM_SUBKEY_OUT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_SUBKEY_OUT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_KEYCTX_OUT
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved
*						*  *
*						*  Reserved
*	@
*		$DRM_KEYPARM  keyParm
*						*  *
*						*  Key parameter
*	@
*		$DRM_DIGEST  hashVal
*						*  *
*						*  Cipher text SHA1 hash value
*	@
*		$UINT64  cipherTxt
*						*  *
*						*  Cipher text of the key context
**********************************************************************************************************************/
#ifdef	h_DRM_KEYCTX_OUT
#else
#define	h_DRM_KEYCTX_OUT

#define	\
	AR_DRM_KEYCTX_OUT \
		13
#define	\
	AB_DRM_KEYCTX_OUT \
		6

typedef struct SIE_DRM_KEYCTX_OUT {

	#define	RA_DRM_KEYCTX_OUT_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRM_KEYCTX_OUT_D0th_ 	{										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_KEYCTX_OUT_D0th_;

	/* [15: 0] */	#define	  BA_DRM_KEYCTX_OUT_ctxSize				 0x00000
	/* ---:--- */	#define	    bDRM_KEYCTX_OUT_ctxSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYCTX_OUT_ctxSize				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYCTX_OUT_ctxSize				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYCTX_OUT_ctxSize(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYCTX_OUT_ctxSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYCTX_OUT_ctxSize(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYCTX_OUT_ctxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_KEYCTX_OUT_ctxType				 0x00002
	/* ---:--- */	#define	    bDRM_KEYCTX_OUT_ctxType				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYCTX_OUT_ctxType				   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_KEYCTX_OUT_ctxType				       0x00FF0000
	/* ---:--- */	#define	GET32DRM_KEYCTX_OUT_ctxType(r32)			 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_KEYCTX_OUT_ctxType(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_KEYCTX_OUT_ctxType(r32,v)			do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYCTX_OUT_ctxType(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_KEYCTX_OUT_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32DRM_KEYCTX_OUT_D1th_ 	{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_KEYCTX_OUT_D1th_;

	/* [31: 0] */	#define	  BA_DRM_KEYCTX_OUT_reserved			 0x00004
	/* ---:--- */	#define	    bDRM_KEYCTX_OUT_reserved			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYCTX_OUT_reserved			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_KEYCTX_OUT_reserved			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_KEYCTX_OUT_reserved(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_KEYCTX_OUT_reserved(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_KEYCTX_OUT_reserved(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYCTX_OUT_reserved(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_KEYCTX_OUT_keyParm 	0x00008
	/* @'00008 */	SIE_DRM_KEYPARM 			ie_keyParm;

	#define	RA_DRM_KEYCTX_OUT_hashVal 	0x0000C
	/* @'0000C */	SIE_DRM_DIGEST 				ie_hashVal;

	#define	RA_DRM_KEYCTX_OUT_cipherTxt 0x0002C
	/* @'0002C */	SIE_UINT64 					ie_cipherTxt;

} SIE_DRM_KEYCTX_OUT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_KEYCTX_OUT_drvrd (SIE_DRM_KEYCTX_OUT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_KEYCTX_OUT_drvwr (SIE_DRM_KEYCTX_OUT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_KEYCTX_OUT_reset (SIE_DRM_KEYCTX_OUT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_KEYCTX_OUT_check(p,pie,ps8name,hfpErrLOG)		DRM_KEYCTX_OUT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_KEYCTX_OUT_print(p,    ps8name,hfpErrLOG)		DRM_KEYCTX_OUT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_KEYCTX_OUT_cmp   (SIE_DRM_KEYCTX_OUT *p, SIE_DRM_KEYCTX_OUT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_KEYCTX_OUT_import(SIE_DRM_KEYCTX_OUT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_KEYCTX_OUT_export(SIE_DRM_KEYCTX_OUT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_KEYCTX_OUT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_SYMKEYCTX256_IN_B
*	@
*		$DRM_KEYPARM_SYM  keyParm
*						*  *
*						*  Key parameter
*	@
*		$DRM_DIGEST  hashVal
*						*  *
*						*  Cipher text SHA1 hash value
*	@
*		$UINT128  keyData
*						*  *
*						*  Algorithm specific of the key data
**********************************************************************************************************************/
#ifdef	h_DRM_SYMKEYCTX256_IN_B
#else
#define	h_DRM_SYMKEYCTX256_IN_B

#define	\
	AR_DRM_SYMKEYCTX256_IN_B \
		18
#define	\
	AB_DRM_SYMKEYCTX256_IN_B \
		7

typedef struct SIE_DRM_SYMKEYCTX256_IN_B {

	#define	RA_DRM_SYMKEYCTX256_IN_B_keyParm 0x00000
	/* @'00000 */	SIE_DRM_KEYPARM_SYM 		ie_keyParm;

	#define	RA_DRM_SYMKEYCTX256_IN_B_hashVal 0x00018
	/* @'00018 */	SIE_DRM_DIGEST 				ie_hashVal;

	#define	RA_DRM_SYMKEYCTX256_IN_B_keyData 0x00038
	/* @'00038 */	SIE_UINT128 				ie_keyData;

} SIE_DRM_SYMKEYCTX256_IN_B;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_SYMKEYCTX256_IN_B_drvrd (SIE_DRM_SYMKEYCTX256_IN_B *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_SYMKEYCTX256_IN_B_drvwr (SIE_DRM_SYMKEYCTX256_IN_B *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_SYMKEYCTX256_IN_B_reset (SIE_DRM_SYMKEYCTX256_IN_B *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_SYMKEYCTX256_IN_B_check(p,pie,ps8name,hfpErrLOG)		DRM_SYMKEYCTX256_IN_B_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_SYMKEYCTX256_IN_B_print(p,    ps8name,hfpErrLOG)		DRM_SYMKEYCTX256_IN_B_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_SYMKEYCTX256_IN_B_cmp   (SIE_DRM_SYMKEYCTX256_IN_B *p, SIE_DRM_SYMKEYCTX256_IN_B *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_SYMKEYCTX256_IN_B_import(SIE_DRM_SYMKEYCTX256_IN_B *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_SYMKEYCTX256_IN_B_export(SIE_DRM_SYMKEYCTX256_IN_B *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_SYMKEYCTX256_IN_B
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_SYMKEYCTX256_IN
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved0
*						*  *
*						*  Reserved
*	@
*		$DRM_KEYPARM_SYM  keyParm
*						*  *
*						*  Key parameter
*	@
*		$DRM_DIGEST  hashVal
*						*  *
*						*  Cipher text SHA1 hash value
*	@
*		%unsigned  8  keyUsageRule
*						*  *
*						*  Context usage rules
*			:  KUL_SIGN  0x01
*						*  *
*						*  a signing key
*			:  KUL_KEK  0x02
*						*  *
*						*  wrap and unwrap other keys
*			:  KUL_ENC  0x04
*						*  *
*						*  Encrypt data
*			:  KUL_DEC  0x04
*						*  *
*						*  Decrypt data
*			:  KUL_EXPORT  0x08
*						*  *
*						*  Exportable keys
*			:  KUL_AUTH  0x10
*						*  *
*						*  Key usage authentication or not
*	@
*		%unsigned  32  reserved1
*						*  *
*						*  Reserved
*	@
*		$UINT64  keyPwd
*						*  *
*						*  Authentication password
*	@
*		$UINT128  keyData
*						*  *
*						*  Algorithm specific of the key data
**********************************************************************************************************************/
#ifdef	h_DRM_SYMKEYCTX256_IN
#else
#define	h_DRM_SYMKEYCTX256_IN

#define	\
	AR_DRM_SYMKEYCTX256_IN \
		24
#define	\
	AB_DRM_SYMKEYCTX256_IN \
		7

typedef struct SIE_DRM_SYMKEYCTX256_IN {

	#define	RA_DRM_SYMKEYCTX256_IN_D0th_ ISC_USE_ONLY	0x00000
	#define	w32DRM_SYMKEYCTX256_IN_D0th_ {										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_SYMKEYCTX256_IN_D0th_;

	/* [15: 0] */	#define	  BA_DRM_SYMKEYCTX256_IN_ctxSize		 0x00000
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_ctxSize		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_ctxSize		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_ctxSize		       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_ctxSize(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_ctxSize(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_ctxSize(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_ctxSize(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_SYMKEYCTX256_IN_ctxType		 0x00002
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_ctxType		    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_ctxType		   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_ctxType		       0x00FF0000
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_ctxType(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_ctxType(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_ctxType(r32,v)		do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_ctxType(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_SYMKEYCTX256_IN_D1th_ ISC_USE_ONLY	0x00004
	#define	w32DRM_SYMKEYCTX256_IN_D1th_ {										\
					UNSG32				u_reserved0					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_SYMKEYCTX256_IN_D1th_;

	/* [31: 0] */	#define	  BA_DRM_SYMKEYCTX256_IN_reserved0		 0x00004
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_reserved0		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_reserved0		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_reserved0		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_reserved0(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_reserved0(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_reserved0(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_reserved0(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_SYMKEYCTX256_IN_keyParm 0x00008
	/* @'00008 */	SIE_DRM_KEYPARM_SYM 		ie_keyParm;

	#define	RA_DRM_SYMKEYCTX256_IN_hashVal 0x00020
	/* @'00020 */	SIE_DRM_DIGEST 				ie_hashVal;

	#define	RA_DRM_SYMKEYCTX256_IN_D16th_ ISC_USE_ONLY	0x00040
	#define	w32DRM_SYMKEYCTX256_IN_D16th_ {										\
					UNSG32				u_keyUsageRule				 :  8;		\
					UNSG32				_x00040	: 24;							\
										}
	/* @'00040 */				struct	w32DRM_SYMKEYCTX256_IN_D16th_;

	/* [ 7: 0] */	#define	  BA_DRM_SYMKEYCTX256_IN_keyUsageRule	 0x00040
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_keyUsageRule	    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_keyUsageRule	    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_keyUsageRule	       0x000000FF
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_keyUsageRule(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_keyUsageRule(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_keyUsageRule(r32,v)do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_keyUsageRule(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_SIGN	0x1
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_KEK	0x2
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_ENC	0x4
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_DEC	0x4
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_EXPORT	0x8
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_AUTH	0x10

	#define	RA_DRM_SYMKEYCTX256_IN_D17th_ ISC_USE_ONLY	0x00044
	#define	w32DRM_SYMKEYCTX256_IN_D17th_ {										\
					UNSG32				u_reserved1					 : 32;		\
										}
	/* @'00044 */				struct	w32DRM_SYMKEYCTX256_IN_D17th_;

	/* [31: 0] */	#define	  BA_DRM_SYMKEYCTX256_IN_reserved1		 0x00044
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_reserved1		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_reserved1		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_reserved1		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_reserved1(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_reserved1(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_reserved1(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_reserved1(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_SYMKEYCTX256_IN_keyPwd 0x00048
	/* @'00048 */	SIE_UINT64 					ie_keyPwd;

	#define	RA_DRM_SYMKEYCTX256_IN_keyData 0x00050
	/* @'00050 */	SIE_UINT128 				ie_keyData;

} SIE_DRM_SYMKEYCTX256_IN;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_SYMKEYCTX256_IN_drvrd (SIE_DRM_SYMKEYCTX256_IN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_SYMKEYCTX256_IN_drvwr (SIE_DRM_SYMKEYCTX256_IN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_SYMKEYCTX256_IN_reset (SIE_DRM_SYMKEYCTX256_IN *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_SYMKEYCTX256_IN_check(p,pie,ps8name,hfpErrLOG)		DRM_SYMKEYCTX256_IN_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_SYMKEYCTX256_IN_print(p,    ps8name,hfpErrLOG)		DRM_SYMKEYCTX256_IN_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_SYMKEYCTX256_IN_cmp   (SIE_DRM_SYMKEYCTX256_IN *p, SIE_DRM_SYMKEYCTX256_IN *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_SYMKEYCTX256_IN_import(SIE_DRM_SYMKEYCTX256_IN *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_SYMKEYCTX256_IN_export(SIE_DRM_SYMKEYCTX256_IN *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_SYMKEYCTX256_IN
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_RSA1024_PUBKEY
*	@
*		$UINT128  rsaMod  REG
*						*  *
*						*  RSA algorithm specific modulus data
*	@
*		$UINT128  keyData  REG  [8]
*						*  *
*						*  Algorithm specific of the public or private key data
**********************************************************************************************************************/
#ifdef	h_DRM_RSA1024_PUBKEY
#else
#define	h_DRM_RSA1024_PUBKEY

#define	\
	AR_DRM_RSA1024_PUBKEY \
		36
#define	\
	AB_DRM_RSA1024_PUBKEY \
		8

typedef struct SIE_DRM_RSA1024_PUBKEY {

	#define	RA_DRM_RSA1024_PUBKEY_rsaMod 0x00000
	/* @'00000 */	SIE_UINT128 				ie_rsaMod;

	#define	RA_DRM_RSA1024_PUBKEY_keyData 0x00010
	/* @'00010 */	SIE_UINT128 				ie_keyData			 [8];
					#define	 arr_DRM_RSA1024_PUBKEY_keyData 		  8

} SIE_DRM_RSA1024_PUBKEY;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_RSA1024_PUBKEY_drvrd (SIE_DRM_RSA1024_PUBKEY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_RSA1024_PUBKEY_drvwr (SIE_DRM_RSA1024_PUBKEY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_RSA1024_PUBKEY_reset (SIE_DRM_RSA1024_PUBKEY *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_RSA1024_PUBKEY_check(p,pie,ps8name,hfpErrLOG)		DRM_RSA1024_PUBKEY_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_RSA1024_PUBKEY_print(p,    ps8name,hfpErrLOG)		DRM_RSA1024_PUBKEY_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_RSA1024_PUBKEY_cmp   (SIE_DRM_RSA1024_PUBKEY *p, SIE_DRM_RSA1024_PUBKEY *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_RSA1024_PUBKEY_import(SIE_DRM_RSA1024_PUBKEY *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_RSA1024_PUBKEY_export(SIE_DRM_RSA1024_PUBKEY *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_RSA1024_PUBKEY
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_RSAKEYCTX1024_IN
*	@
*		$DRM_DIGEST  hashVal
*						*  *
*						*  Cipher text SHA1 hash value
*	@
*		$DRM_RSA1024_PUBKEY  keyData
*						*  *
*						*  Algorithm specific of the key data
**********************************************************************************************************************/
#ifdef	h_DRM_RSAKEYCTX1024_IN
#else
#define	h_DRM_RSAKEYCTX1024_IN

#define	\
	AR_DRM_RSAKEYCTX1024_IN \
		44
#define	\
	AB_DRM_RSAKEYCTX1024_IN \
		8

typedef struct SIE_DRM_RSAKEYCTX1024_IN {

	#define	RA_DRM_RSAKEYCTX1024_IN_hashVal 0x00000
	/* @'00000 */	SIE_DRM_DIGEST 				ie_hashVal;

	#define	RA_DRM_RSAKEYCTX1024_IN_keyData 0x00020
	/* @'00020 */	SIE_DRM_RSA1024_PUBKEY 		ie_keyData;

} SIE_DRM_RSAKEYCTX1024_IN;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_RSAKEYCTX1024_IN_drvrd (SIE_DRM_RSAKEYCTX1024_IN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_RSAKEYCTX1024_IN_drvwr (SIE_DRM_RSAKEYCTX1024_IN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_RSAKEYCTX1024_IN_reset (SIE_DRM_RSAKEYCTX1024_IN *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_RSAKEYCTX1024_IN_check(p,pie,ps8name,hfpErrLOG)		DRM_RSAKEYCTX1024_IN_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_RSAKEYCTX1024_IN_print(p,    ps8name,hfpErrLOG)		DRM_RSAKEYCTX1024_IN_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_RSAKEYCTX1024_IN_cmp   (SIE_DRM_RSAKEYCTX1024_IN *p, SIE_DRM_RSAKEYCTX1024_IN *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_RSAKEYCTX1024_IN_import(SIE_DRM_RSAKEYCTX1024_IN *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_RSAKEYCTX1024_IN_export(SIE_DRM_RSAKEYCTX1024_IN *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_RSAKEYCTX1024_IN
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_RSAKEYCTX1024_IN_B
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved0
*						*  *
*						*  Reserved
*	@
*		$DRM_KEYPARM_RSA  keyParm
*						*  *
*						*  Key parameter
*	@
*		$DRM_DIGEST  hashVal
*						*  *
*						*  Cipher text SHA1 hash value
*	@
*		%unsigned  8  keyUsageRule
*						*  *
*						*  Context usage rules
*			:  KUL_SIGN  0x01
*						*  *
*						*  a signing key
*			:  KUL_KEK  0x02
*						*  *
*						*  wrap and unwrap other keys
*			:  KUL_ENC  0x04
*						*  *
*						*  Encrypt data
*			:  KUL_DEC  0x04
*						*  *
*						*  Decrypt data
*			:  KUL_EXPORT  0x08
*						*  *
*						*  Exportable keys
*			:  KUL_AUTH  0x10
*						*  *
*						*  Key usage authentication or not
*	@
*		%unsigned  32  reserved1
*						*  *
*						*  Reserved
*	@
*		$UINT64  keyPwd
*						*  *
*						*  Authentication password
*	@
*		$UINT128  keyData  [16]
*						*  *
*						*  Algorithm specific of the key data
**********************************************************************************************************************/
#ifdef	h_DRM_RSAKEYCTX1024_IN_B
#else
#define	h_DRM_RSAKEYCTX1024_IN_B

#define	\
	AR_DRM_RSAKEYCTX1024_IN_B \
		20
#define	\
	AB_DRM_RSAKEYCTX1024_IN_B \
		7

typedef struct SIE_DRM_RSAKEYCTX1024_IN_B {

	#define	RA_DRM_RSAKEYCTX1024_IN_B_D0th_ ISC_USE_ONLY	0x00000
	#define	w32DRM_RSAKEYCTX1024_IN_B_D0th_ {									\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_RSAKEYCTX1024_IN_B_D0th_;

	/* [15: 0] */	#define	  BA_DRM_RSAKEYCTX1024_IN_B_ctxSize		 0x00000
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_B_ctxSize		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_B_ctxSize		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_B_ctxSize		       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_B_ctxSize(r32)	 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_B_ctxSize(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_B_ctxSize(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_B_ctxSize(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_RSAKEYCTX1024_IN_B_ctxType		 0x00002
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_B_ctxType		    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_B_ctxType		   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_B_ctxType		       0x00FF0000
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_B_ctxType(r32)	 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_B_ctxType(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_B_ctxType(r32,v)	do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_B_ctxType(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_RSAKEYCTX1024_IN_B_D1th_ ISC_USE_ONLY	0x00004
	#define	w32DRM_RSAKEYCTX1024_IN_B_D1th_ {									\
					UNSG32				u_reserved0					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_RSAKEYCTX1024_IN_B_D1th_;

	/* [31: 0] */	#define	  BA_DRM_RSAKEYCTX1024_IN_B_reserved0	 0x00004
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_B_reserved0	   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_B_reserved0	    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_B_reserved0	       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_B_reserved0(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_B_reserved0(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_B_reserved0(r32,v)do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_B_reserved0(r16,v)do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_RSAKEYCTX1024_IN_B_keyParm 0x00008
	/* @'00008 */	SIE_DRM_KEYPARM_RSA 		ie_keyParm;

	#define	RA_DRM_RSAKEYCTX1024_IN_B_hashVal 0x00010
	/* @'00010 */	SIE_DRM_DIGEST 				ie_hashVal;

	#define	RA_DRM_RSAKEYCTX1024_IN_B_D12th_ ISC_USE_ONLY	0x00030
	#define	w32DRM_RSAKEYCTX1024_IN_B_D12th_ {									\
					UNSG32				u_keyUsageRule				 :  8;		\
					UNSG32				_x00030	: 24;							\
										}
	/* @'00030 */				struct	w32DRM_RSAKEYCTX1024_IN_B_D12th_;

	/* [ 7: 0] */	#define	  BA_DRM_RSAKEYCTX1024_IN_B_keyUsageRule 0x00030
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_B_keyUsageRule    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_B_keyUsageRule    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_B_keyUsageRule       0x000000FF
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_B_keyUsageRule(r32) (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_B_keyUsageRule(r16) (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_B_keyUsageRule(r32,v)do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_B_keyUsageRule(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRM_RSAKEYCTX1024_IN_B_keyUsageRule_KUL_SIGN	0x1
					#define	     DRM_RSAKEYCTX1024_IN_B_keyUsageRule_KUL_KEK	0x2
					#define	     DRM_RSAKEYCTX1024_IN_B_keyUsageRule_KUL_ENC	0x4
					#define	     DRM_RSAKEYCTX1024_IN_B_keyUsageRule_KUL_DEC	0x4
					#define	     DRM_RSAKEYCTX1024_IN_B_keyUsageRule_KUL_EXPORT	0x8
					#define	     DRM_RSAKEYCTX1024_IN_B_keyUsageRule_KUL_AUTH	0x10

	#define	RA_DRM_RSAKEYCTX1024_IN_B_D13th_ ISC_USE_ONLY	0x00034
	#define	w32DRM_RSAKEYCTX1024_IN_B_D13th_ {									\
					UNSG32				u_reserved1					 : 32;		\
										}
	/* @'00034 */				struct	w32DRM_RSAKEYCTX1024_IN_B_D13th_;

	/* [31: 0] */	#define	  BA_DRM_RSAKEYCTX1024_IN_B_reserved1	 0x00034
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_B_reserved1	   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_B_reserved1	    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_B_reserved1	       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_B_reserved1(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_B_reserved1(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_B_reserved1(r32,v)do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_B_reserved1(r16,v)do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_RSAKEYCTX1024_IN_B_keyPwd 0x00038
	/* @'00038 */	SIE_UINT64 					ie_keyPwd;

	#define	RA_DRM_RSAKEYCTX1024_IN_B_keyData 0x00040
	/* @'00040 */	SIE_UINT128 				ie_keyData;

} SIE_DRM_RSAKEYCTX1024_IN_B;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_RSAKEYCTX1024_IN_B_drvrd (SIE_DRM_RSAKEYCTX1024_IN_B *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_RSAKEYCTX1024_IN_B_drvwr (SIE_DRM_RSAKEYCTX1024_IN_B *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_RSAKEYCTX1024_IN_B_reset (SIE_DRM_RSAKEYCTX1024_IN_B *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_RSAKEYCTX1024_IN_B_check(p,pie,ps8name,hfpErrLOG)		DRM_RSAKEYCTX1024_IN_B_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_RSAKEYCTX1024_IN_B_print(p,    ps8name,hfpErrLOG)		DRM_RSAKEYCTX1024_IN_B_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_RSAKEYCTX1024_IN_B_cmp   (SIE_DRM_RSAKEYCTX1024_IN_B *p, SIE_DRM_RSAKEYCTX1024_IN_B *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_RSAKEYCTX1024_IN_B_import(SIE_DRM_RSAKEYCTX1024_IN_B *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_RSAKEYCTX1024_IN_B_export(SIE_DRM_RSAKEYCTX1024_IN_B *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_RSAKEYCTX1024_IN_B
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_HASH_CTXIN
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved
*						*  *
*						*  Reserved
*	@
*		%unsigned  32  ctxData
*						*  *
*						*  Reserved
**********************************************************************************************************************/
#ifdef	h_DRM_HASH_CTXIN
#else
#define	h_DRM_HASH_CTXIN

#define	\
	AR_DRM_HASH_CTXIN \
		3
#define	\
	AB_DRM_HASH_CTXIN \
		4

typedef struct SIE_DRM_HASH_CTXIN {

	#define	RA_DRM_HASH_CTXIN_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRM_HASH_CTXIN_D0th_ 	{										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_HASH_CTXIN_D0th_;

	/* [15: 0] */	#define	  BA_DRM_HASH_CTXIN_ctxSize				 0x00000
	/* ---:--- */	#define	    bDRM_HASH_CTXIN_ctxSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_HASH_CTXIN_ctxSize				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_HASH_CTXIN_ctxSize				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_HASH_CTXIN_ctxSize(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_HASH_CTXIN_ctxSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_HASH_CTXIN_ctxSize(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_HASH_CTXIN_ctxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_HASH_CTXIN_ctxType				 0x00002
	/* ---:--- */	#define	    bDRM_HASH_CTXIN_ctxType				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_HASH_CTXIN_ctxType				   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_HASH_CTXIN_ctxType				       0x00FF0000
	/* ---:--- */	#define	GET32DRM_HASH_CTXIN_ctxType(r32)			 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_HASH_CTXIN_ctxType(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_HASH_CTXIN_ctxType(r32,v)			do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_HASH_CTXIN_ctxType(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_HASH_CTXIN_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32DRM_HASH_CTXIN_D1th_ 	{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_HASH_CTXIN_D1th_;

	/* [31: 0] */	#define	  BA_DRM_HASH_CTXIN_reserved			 0x00004
	/* ---:--- */	#define	    bDRM_HASH_CTXIN_reserved			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_HASH_CTXIN_reserved			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_HASH_CTXIN_reserved			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_HASH_CTXIN_reserved(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_HASH_CTXIN_reserved(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_HASH_CTXIN_reserved(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_HASH_CTXIN_reserved(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_HASH_CTXIN_D2th_ 	ISC_USE_ONLY	0x00008
	#define	w32DRM_HASH_CTXIN_D2th_ 	{										\
					UNSG32				u_ctxData					 : 32;		\
										}
	/* @'00008 */				struct	w32DRM_HASH_CTXIN_D2th_;

	/* [31: 0] */	#define	  BA_DRM_HASH_CTXIN_ctxData				 0x00008
	/* ---:--- */	#define	    bDRM_HASH_CTXIN_ctxData				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_HASH_CTXIN_ctxData				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_HASH_CTXIN_ctxData				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_HASH_CTXIN_ctxData(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_HASH_CTXIN_ctxData(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_HASH_CTXIN_ctxData(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_HASH_CTXIN_ctxData(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRM_HASH_CTXIN;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_HASH_CTXIN_drvrd (SIE_DRM_HASH_CTXIN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_HASH_CTXIN_drvwr (SIE_DRM_HASH_CTXIN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_HASH_CTXIN_reset (SIE_DRM_HASH_CTXIN *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_HASH_CTXIN_check(p,pie,ps8name,hfpErrLOG)		DRM_HASH_CTXIN_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_HASH_CTXIN_print(p,    ps8name,hfpErrLOG)		DRM_HASH_CTXIN_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_HASH_CTXIN_cmp   (SIE_DRM_HASH_CTXIN *p, SIE_DRM_HASH_CTXIN *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_HASH_CTXIN_import(SIE_DRM_HASH_CTXIN *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_HASH_CTXIN_export(SIE_DRM_HASH_CTXIN *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_HASH_CTXIN
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_FIGOIMG
*	@
*		$DRM_SUBKEY_OUT  encKey
*						*  *
*						*  Image protection Key
*	@
*		$DRM_DIGEST  authData
*						*  *
*						*  Authentication information signed by sigKey
*	@
*		$UINT128  bindInfo
*						*  *
*						*  Platform binding information to indicate what type of underling hardware to run this firmware
*	@  INFO
*		%unsigned  16  insNum  0
*						*  *
*						*  Instructions Number
*		%unsigned  16  insPCoff
*						*  *
*						*  Destination PC
*		%unsigned  16  datCnt
*						*  *
*						*  Static data area size in 64bits entries
*		%unsigned  16  datCntOff
*						*  *
*						*  Destination offset
*	@
*		$UINT32  reserved  REG  [2]
*						*  *
*						*  Reserved bits
*	@
*		$UINT32  imgDat
**********************************************************************************************************************/
#ifdef	h_DRM_FIGOIMG
#else
#define	h_DRM_FIGOIMG

#define	\
	AR_DRM_FIGOIMG \
		33
#define	\
	AB_DRM_FIGOIMG \
		8

typedef struct SIE_DRM_FIGOIMG {

	#define	RA_DRM_FIGOIMG_encKey 		0x00000
	/* @'00000 */	SIE_DRM_SUBKEY_OUT 			ie_encKey;

	#define	RA_DRM_FIGOIMG_authData 	0x00040
	/* @'00040 */	SIE_DRM_DIGEST 				ie_authData;

	#define	RA_DRM_FIGOIMG_bindInfo 	0x00060
	/* @'00060 */	SIE_UINT128 				ie_bindInfo;

	#define	RA_DRM_FIGOIMG_INFO 		0x00070
	#define	w32DRM_FIGOIMG_INFO 		{										\
					UNSG32				uINFO_insNum				 : 16;		\
					UNSG32				uINFO_insPCoff				 : 16;		\
										}
	/* @'00070 */	union {	UNSG32		u32DRM_FIGOIMG_INFO;
								struct	w32DRM_FIGOIMG_INFO;
										};

	/* [15: 0] */	#define	  BA_DRM_FIGOIMG_INFO_insNum			 0x00070
	/* ---:--- */	#define	    bDRM_FIGOIMG_INFO_insNum			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_FIGOIMG_INFO_insNum			    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_FIGOIMG_INFO_insNum			       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_FIGOIMG_INFO_insNum(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_FIGOIMG_INFO_insNum(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_FIGOIMG_INFO_insNum(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_FIGOIMG_INFO_insNum(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_FIGOIMG_INFO_insPCoff			 0x00072
	/* ---:--- */	#define	    bDRM_FIGOIMG_INFO_insPCoff			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_FIGOIMG_INFO_insPCoff			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_FIGOIMG_INFO_insPCoff			       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_FIGOIMG_INFO_insPCoff(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_FIGOIMG_INFO_insPCoff(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_FIGOIMG_INFO_insPCoff(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_FIGOIMG_INFO_insPCoff(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_FIGOIMG_INFO1 		0x00074
	#define	w32DRM_FIGOIMG_INFO1 		{										\
					UNSG32				uINFO_datCnt				 : 16;		\
					UNSG32				uINFO_datCntOff				 : 16;		\
										}
	/* @'00074 */	union {	UNSG32		u32DRM_FIGOIMG_INFO1;
								struct	w32DRM_FIGOIMG_INFO1;
										};

	/* [15: 0] */	#define	  BA_DRM_FIGOIMG_INFO_datCnt			 0x00074
	/* ---:--- */	#define	    bDRM_FIGOIMG_INFO_datCnt			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_FIGOIMG_INFO_datCnt			    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_FIGOIMG_INFO_datCnt			       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_FIGOIMG_INFO_datCnt(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_FIGOIMG_INFO_datCnt(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_FIGOIMG_INFO_datCnt(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_FIGOIMG_INFO_datCnt(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_FIGOIMG_INFO_datCntOff			 0x00076
	/* ---:--- */	#define	    bDRM_FIGOIMG_INFO_datCntOff			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_FIGOIMG_INFO_datCntOff			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_FIGOIMG_INFO_datCntOff			       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_FIGOIMG_INFO_datCntOff(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_FIGOIMG_INFO_datCntOff(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_FIGOIMG_INFO_datCntOff(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_FIGOIMG_INFO_datCntOff(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_FIGOIMG_reserved 	0x00078
	/* @'00078 */	SIE_UINT32 					ie_reserved			 [2];
					#define	 arr_DRM_FIGOIMG_reserved 				  2

	#define	RA_DRM_FIGOIMG_imgDat 		0x00080
	/* @'00080 */	SIE_UINT32 					ie_imgDat;

} SIE_DRM_FIGOIMG;

	#define	dftDRM_FIGOIMG_INFO 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_FIGOIMG_INFO;
										} T32DRM_FIGOIMG_INFO;
	#define	dftDRM_FIGOIMG_INFO1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_FIGOIMG_INFO1;
										} T32DRM_FIGOIMG_INFO1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_FIGOIMG_drvrd (SIE_DRM_FIGOIMG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_FIGOIMG_drvwr (SIE_DRM_FIGOIMG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_FIGOIMG_reset (SIE_DRM_FIGOIMG *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_FIGOIMG_check(p,pie,ps8name,hfpErrLOG)		DRM_FIGOIMG_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_FIGOIMG_print(p,    ps8name,hfpErrLOG)		DRM_FIGOIMG_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_FIGOIMG_cmp   (SIE_DRM_FIGOIMG *p, SIE_DRM_FIGOIMG *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_FIGOIMG_import(SIE_DRM_FIGOIMG *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_FIGOIMG_export(SIE_DRM_FIGOIMG *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_FIGOIMG
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_ARMIMG
*	@
*		$DRM_SUBKEY_OUT  encKey
*						*  *
*						*  Image protection Key
*	@
*		$DRM_DIGEST  authData
*						*  *
*						*  Authentication information signed by sigKey
*	@
*		$UINT128  bindInfo
*						*  *
*						*  Platform binding information to indicate what type of underling hardware to run this firmware
*	@
*		$UINT32  reserved  REG  [3]
*	@
*		$UINT32  imgSize
*						*  *
*						*  Actual Image size. Total Image size is ALIGN16(imgSize) + 128
*	@
*		$UINT32  imgDat
**********************************************************************************************************************/
#ifdef	h_DRM_ARMIMG
#else
#define	h_DRM_ARMIMG

#define	\
	AR_DRM_ARMIMG \
		33
#define	\
	AB_DRM_ARMIMG \
		8

typedef struct SIE_DRM_ARMIMG {

	#define	RA_DRM_ARMIMG_encKey 		0x00000
	/* @'00000 */	SIE_DRM_SUBKEY_OUT 			ie_encKey;

	#define	RA_DRM_ARMIMG_authData 		0x00040
	/* @'00040 */	SIE_DRM_DIGEST 				ie_authData;

	#define	RA_DRM_ARMIMG_bindInfo 		0x00060
	/* @'00060 */	SIE_UINT128 				ie_bindInfo;

	#define	RA_DRM_ARMIMG_reserved 		0x00070
	/* @'00070 */	SIE_UINT32 					ie_reserved			 [3];
					#define	 arr_DRM_ARMIMG_reserved 				  3

	#define	RA_DRM_ARMIMG_imgSize 		0x0007C
	/* @'0007C */	SIE_UINT32 					ie_imgSize;

	#define	RA_DRM_ARMIMG_imgDat 		0x00080
	/* @'00080 */	SIE_UINT32 					ie_imgDat;

} SIE_DRM_ARMIMG;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_ARMIMG_drvrd (SIE_DRM_ARMIMG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_ARMIMG_drvwr (SIE_DRM_ARMIMG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_ARMIMG_reset (SIE_DRM_ARMIMG *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_ARMIMG_check(p,pie,ps8name,hfpErrLOG)		DRM_ARMIMG_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_ARMIMG_print(p,    ps8name,hfpErrLOG)		DRM_ARMIMG_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_ARMIMG_cmp   (SIE_DRM_ARMIMG *p, SIE_DRM_ARMIMG *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_ARMIMG_import(SIE_DRM_ARMIMG *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_ARMIMG_export(SIE_DRM_ARMIMG *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_ARMIMG
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SHA1_RODAT
*	@
*		$UINT32  a64Blk  REG  [576]
**********************************************************************************************************************/
#ifdef	h_SHA1_RODAT
#else
#define	h_SHA1_RODAT

#define	\
	AR_SHA1_RODAT \
		576
#define	\
	AB_SHA1_RODAT \
		12

typedef struct SIE_SHA1_RODAT {

	#define	RA_SHA1_RODAT_a64Blk 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_a64Blk			 [576];
					#define	 arr_SHA1_RODAT_a64Blk 					  576

} SIE_SHA1_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SHA1_RODAT_drvrd (SIE_SHA1_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SHA1_RODAT_drvwr (SIE_SHA1_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SHA1_RODAT_reset (SIE_SHA1_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SHA1_RODAT_check(p,pie,ps8name,hfpErrLOG)		SHA1_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SHA1_RODAT_print(p,    ps8name,hfpErrLOG)		SHA1_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SHA1_RODAT_cmp   (SIE_SHA1_RODAT *p, SIE_SHA1_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SHA1_RODAT_import(SIE_SHA1_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SHA1_RODAT_export(SIE_SHA1_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SHA1_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SHA1_CTXDAT
*	@
*		$UINT64  puCount
*						*  *
*						*  Counter
*	@
*		$UINT32  pbBuf  REG  [16]
*						*  *
*						*  Internal buffer
*	@
*		$UINT32  puState  REG  [6]
*						*  *
*						*  Hash state
**********************************************************************************************************************/
#ifdef	h_SHA1_CTXDAT
#else
#define	h_SHA1_CTXDAT

#define	\
	AR_SHA1_CTXDAT \
		24
#define	\
	AB_SHA1_CTXDAT \
		7

typedef struct SIE_SHA1_CTXDAT {

	#define	RA_SHA1_CTXDAT_puCount 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_puCount;

	#define	RA_SHA1_CTXDAT_pbBuf 		0x00008
	/* @'00008 */	SIE_UINT32 					ie_pbBuf			 [16];
					#define	 arr_SHA1_CTXDAT_pbBuf 					  16

	#define	RA_SHA1_CTXDAT_puState 		0x00048
	/* @'00048 */	SIE_UINT32 					ie_puState			 [6];
					#define	 arr_SHA1_CTXDAT_puState 				  6

} SIE_SHA1_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SHA1_CTXDAT_drvrd (SIE_SHA1_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SHA1_CTXDAT_drvwr (SIE_SHA1_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SHA1_CTXDAT_reset (SIE_SHA1_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SHA1_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		SHA1_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SHA1_CTXDAT_print(p,    ps8name,hfpErrLOG)		SHA1_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SHA1_CTXDAT_cmp   (SIE_SHA1_CTXDAT *p, SIE_SHA1_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SHA1_CTXDAT_import(SIE_SHA1_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SHA1_CTXDAT_export(SIE_SHA1_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SHA1_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CRC32_RODAT
*	@
*		$UINT32  a64Blk  REG  [80]
**********************************************************************************************************************/
#ifdef	h_CRC32_RODAT
#else
#define	h_CRC32_RODAT

#define	\
	AR_CRC32_RODAT \
		80
#define	\
	AB_CRC32_RODAT \
		9

typedef struct SIE_CRC32_RODAT {

	#define	RA_CRC32_RODAT_a64Blk 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_a64Blk			 [80];
					#define	 arr_CRC32_RODAT_a64Blk 				  80

} SIE_CRC32_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CRC32_RODAT_drvrd (SIE_CRC32_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CRC32_RODAT_drvwr (SIE_CRC32_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CRC32_RODAT_reset (SIE_CRC32_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CRC32_RODAT_check(p,pie,ps8name,hfpErrLOG)		CRC32_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CRC32_RODAT_print(p,    ps8name,hfpErrLOG)		CRC32_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CRC32_RODAT_cmp   (SIE_CRC32_RODAT *p, SIE_CRC32_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CRC32_RODAT_import(SIE_CRC32_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CRC32_RODAT_export(SIE_CRC32_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CRC32_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: AESWRAP_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_AESWRAP_RODAT
#else
#define	h_AESWRAP_RODAT

#define	\
	AR_AESWRAP_RODAT \
		1
#define	\
	AB_AESWRAP_RODAT \
		2

typedef struct SIE_AESWRAP_RODAT {

	#define	RA_AESWRAP_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_AESWRAP_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	AESWRAP_RODAT_drvrd (SIE_AESWRAP_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	AESWRAP_RODAT_drvwr (SIE_AESWRAP_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	AESWRAP_RODAT_reset (SIE_AESWRAP_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	AESWRAP_RODAT_check(p,pie,ps8name,hfpErrLOG)		AESWRAP_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	AESWRAP_RODAT_print(p,    ps8name,hfpErrLOG)		AESWRAP_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	AESWRAP_RODAT_cmp   (SIE_AESWRAP_RODAT *p, SIE_AESWRAP_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	AESWRAP_RODAT_import(SIE_AESWRAP_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	AESWRAP_RODAT_export(SIE_AESWRAP_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: AESWRAP_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: AESWRAP_CTX
*	@
*		$UINT128  R
*	@
*		$UINT128  A
*	@
*		$UINT128  B
**********************************************************************************************************************/
#ifdef	h_AESWRAP_CTX
#else
#define	h_AESWRAP_CTX

#define	\
	AR_AESWRAP_CTX \
		12
#define	\
	AB_AESWRAP_CTX \
		6

typedef struct SIE_AESWRAP_CTX {

	#define	RA_AESWRAP_CTX_R 			0x00000
	/* @'00000 */	SIE_UINT128 				ie_R;

	#define	RA_AESWRAP_CTX_A 			0x00010
	/* @'00010 */	SIE_UINT128 				ie_A;

	#define	RA_AESWRAP_CTX_B 			0x00020
	/* @'00020 */	SIE_UINT128 				ie_B;

} SIE_AESWRAP_CTX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	AESWRAP_CTX_drvrd (SIE_AESWRAP_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	AESWRAP_CTX_drvwr (SIE_AESWRAP_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	AESWRAP_CTX_reset (SIE_AESWRAP_CTX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	AESWRAP_CTX_check(p,pie,ps8name,hfpErrLOG)		AESWRAP_CTX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	AESWRAP_CTX_print(p,    ps8name,hfpErrLOG)		AESWRAP_CTX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	AESWRAP_CTX_cmp   (SIE_AESWRAP_CTX *p, SIE_AESWRAP_CTX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	AESWRAP_CTX_import(SIE_AESWRAP_CTX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	AESWRAP_CTX_export(SIE_AESWRAP_CTX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: AESWRAP_CTX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: HMAC_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_HMAC_RODAT
#else
#define	h_HMAC_RODAT

#define	\
	AR_HMAC_RODAT \
		1
#define	\
	AB_HMAC_RODAT \
		2

typedef struct SIE_HMAC_RODAT {

	#define	RA_HMAC_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_HMAC_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	HMAC_RODAT_drvrd (SIE_HMAC_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	HMAC_RODAT_drvwr (SIE_HMAC_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	HMAC_RODAT_reset (SIE_HMAC_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	HMAC_RODAT_check(p,pie,ps8name,hfpErrLOG)		HMAC_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	HMAC_RODAT_print(p,    ps8name,hfpErrLOG)		HMAC_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	HMAC_RODAT_cmp   (SIE_HMAC_RODAT *p, SIE_HMAC_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	HMAC_RODAT_import(SIE_HMAC_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	HMAC_RODAT_export(SIE_HMAC_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: HMAC_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: HMAC_CTXDAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_HMAC_CTXDAT
#else
#define	h_HMAC_CTXDAT

#define	\
	AR_HMAC_CTXDAT \
		1
#define	\
	AB_HMAC_CTXDAT \
		2

typedef struct SIE_HMAC_CTXDAT {

	#define	RA_HMAC_CTXDAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_HMAC_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	HMAC_CTXDAT_drvrd (SIE_HMAC_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	HMAC_CTXDAT_drvwr (SIE_HMAC_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	HMAC_CTXDAT_reset (SIE_HMAC_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	HMAC_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		HMAC_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	HMAC_CTXDAT_print(p,    ps8name,hfpErrLOG)		HMAC_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	HMAC_CTXDAT_cmp   (SIE_HMAC_CTXDAT *p, SIE_HMAC_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	HMAC_CTXDAT_import(SIE_HMAC_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	HMAC_CTXDAT_export(SIE_HMAC_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: HMAC_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CMAC_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_CMAC_RODAT
#else
#define	h_CMAC_RODAT

#define	\
	AR_CMAC_RODAT \
		1
#define	\
	AB_CMAC_RODAT \
		2

typedef struct SIE_CMAC_RODAT {

	#define	RA_CMAC_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_CMAC_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CMAC_RODAT_drvrd (SIE_CMAC_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CMAC_RODAT_drvwr (SIE_CMAC_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CMAC_RODAT_reset (SIE_CMAC_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CMAC_RODAT_check(p,pie,ps8name,hfpErrLOG)		CMAC_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CMAC_RODAT_print(p,    ps8name,hfpErrLOG)		CMAC_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CMAC_RODAT_cmp   (SIE_CMAC_RODAT *p, SIE_CMAC_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CMAC_RODAT_import(SIE_CMAC_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CMAC_RODAT_export(SIE_CMAC_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CMAC_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CMAC_CTXDAT
*	@
*		$UINT128  k1
*	@
*		$UINT128  k2
**********************************************************************************************************************/
#ifdef	h_CMAC_CTXDAT
#else
#define	h_CMAC_CTXDAT

#define	\
	AR_CMAC_CTXDAT \
		8
#define	\
	AB_CMAC_CTXDAT \
		5

typedef struct SIE_CMAC_CTXDAT {

	#define	RA_CMAC_CTXDAT_k1 			0x00000
	/* @'00000 */	SIE_UINT128 				ie_k1;

	#define	RA_CMAC_CTXDAT_k2 			0x00010
	/* @'00010 */	SIE_UINT128 				ie_k2;

} SIE_CMAC_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CMAC_CTXDAT_drvrd (SIE_CMAC_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CMAC_CTXDAT_drvwr (SIE_CMAC_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CMAC_CTXDAT_reset (SIE_CMAC_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CMAC_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		CMAC_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CMAC_CTXDAT_print(p,    ps8name,hfpErrLOG)		CMAC_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CMAC_CTXDAT_cmp   (SIE_CMAC_CTXDAT *p, SIE_CMAC_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CMAC_CTXDAT_import(SIE_CMAC_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CMAC_CTXDAT_export(SIE_CMAC_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CMAC_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: AES128_RODAT
*	@
*		$UINT32  Sbox  REG  [64]
*						*  *
*						*  S-Box for AES encryption
*	@
*		$UINT32  iSbox  REG  [64]
*						*  *
*						*  Inverse S-Box for AES decryption
*	@
*		$UINT128  Recon  REG  [5]
*	@
*		$UINT32  a64Blk  REG  [368]
**********************************************************************************************************************/
#ifdef	h_AES128_RODAT
#else
#define	h_AES128_RODAT

#define	\
	AR_AES128_RODAT \
		516
#define	\
	AB_AES128_RODAT \
		12

typedef struct SIE_AES128_RODAT {

	#define	RA_AES128_RODAT_Sbox 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_Sbox				 [64];
					#define	 arr_AES128_RODAT_Sbox 					  64

	#define	RA_AES128_RODAT_iSbox 		0x00100
	/* @'00100 */	SIE_UINT32 					ie_iSbox			 [64];
					#define	 arr_AES128_RODAT_iSbox 				  64

	#define	RA_AES128_RODAT_Recon 		0x00200
	/* @'00200 */	SIE_UINT128 				ie_Recon			 [5];
					#define	 arr_AES128_RODAT_Recon 				  5

	#define	RA_AES128_RODAT_a64Blk 		0x00250
	/* @'00250 */	SIE_UINT32 					ie_a64Blk			 [368];
					#define	 arr_AES128_RODAT_a64Blk 				  368

} SIE_AES128_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	AES128_RODAT_drvrd (SIE_AES128_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	AES128_RODAT_drvwr (SIE_AES128_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	AES128_RODAT_reset (SIE_AES128_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	AES128_RODAT_check(p,pie,ps8name,hfpErrLOG)		AES128_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	AES128_RODAT_print(p,    ps8name,hfpErrLOG)		AES128_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	AES128_RODAT_cmp   (SIE_AES128_RODAT *p, SIE_AES128_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	AES128_RODAT_import(SIE_AES128_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	AES128_RODAT_export(SIE_AES128_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: AES128_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: AES128_CTXDAT
*	@
*		$UINT32  a64Blk  REG  [368]
*	@
*		$UINT128  Recon  REG  [5]
*	@  TB_OFF
*		%unsigned  16  pbSbox  REG
*		%unsigned  16  pbiSbox  REG
*		%unsigned  16  pbRecon  REG
**********************************************************************************************************************/
#ifdef	h_AES128_CTXDAT
#else
#define	h_AES128_CTXDAT

#define	\
	AR_AES128_CTXDAT \
		390
#define	\
	AB_AES128_CTXDAT \
		11

typedef struct SIE_AES128_CTXDAT {

	#define	RA_AES128_CTXDAT_a64Blk 	0x00000
	/* @'00000 */	SIE_UINT32 					ie_a64Blk			 [368];
					#define	 arr_AES128_CTXDAT_a64Blk 				  368

	#define	RA_AES128_CTXDAT_Recon 		0x005C0
	/* @'005C0 */	SIE_UINT128 				ie_Recon			 [5];
					#define	 arr_AES128_CTXDAT_Recon 				  5

	#define	RA_AES128_CTXDAT_TB_OFF 	0x00610
	#define	w32AES128_CTXDAT_TB_OFF 	{										\
					UNSG32				uTB_OFF_pbSbox				 : 16;		\
					UNSG32				uTB_OFF_pbiSbox				 : 16;		\
										}
	/* @'00610 */	union {	UNSG32		u32AES128_CTXDAT_TB_OFF;
								struct	w32AES128_CTXDAT_TB_OFF;
										};

	/* [15: 0] */	#define	  BA_AES128_CTXDAT_TB_OFF_pbSbox		 0x00610
	/* ---:--- */	#define	    bAES128_CTXDAT_TB_OFF_pbSbox		   16 /*bit*/
	/* ---:--- */	#define	LSb32AES128_CTXDAT_TB_OFF_pbSbox		    0 /*:15*/
	/* ---:--- */	#define	MSK32AES128_CTXDAT_TB_OFF_pbSbox		       0x0000FFFF
	/* ---:--- */	#define	GET32AES128_CTXDAT_TB_OFF_pbSbox(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16AES128_CTXDAT_TB_OFF_pbSbox(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32AES128_CTXDAT_TB_OFF_pbSbox(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16AES128_CTXDAT_TB_OFF_pbSbox(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_AES128_CTXDAT_TB_OFF_pbiSbox		 0x00612
	/* ---:--- */	#define	    bAES128_CTXDAT_TB_OFF_pbiSbox		   16 /*bit*/
	/* ---:--- */	#define	LSb32AES128_CTXDAT_TB_OFF_pbiSbox		   16 /*:31*/
	/* ---:--- */	#define	MSK32AES128_CTXDAT_TB_OFF_pbiSbox		       0xFFFF0000
	/* ---:--- */	#define	GET32AES128_CTXDAT_TB_OFF_pbiSbox(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16AES128_CTXDAT_TB_OFF_pbiSbox(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32AES128_CTXDAT_TB_OFF_pbiSbox(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16AES128_CTXDAT_TB_OFF_pbiSbox(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_AES128_CTXDAT_TB_OFF1 	0x00614
	#define	w32AES128_CTXDAT_TB_OFF1 	{										\
					UNSG32				uTB_OFF_pbRecon				 : 16;		\
					UNSG32				_x00614	: 16;							\
										}
	/* @'00614 */	union {	UNSG32		u32AES128_CTXDAT_TB_OFF1;
								struct	w32AES128_CTXDAT_TB_OFF1;
										};

	/* [15: 0] */	#define	  BA_AES128_CTXDAT_TB_OFF_pbRecon		 0x00614
	/* ---:--- */	#define	    bAES128_CTXDAT_TB_OFF_pbRecon		   16 /*bit*/
	/* ---:--- */	#define	LSb32AES128_CTXDAT_TB_OFF_pbRecon		    0 /*:15*/
	/* ---:--- */	#define	MSK32AES128_CTXDAT_TB_OFF_pbRecon		       0x0000FFFF
	/* ---:--- */	#define	GET32AES128_CTXDAT_TB_OFF_pbRecon(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16AES128_CTXDAT_TB_OFF_pbRecon(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32AES128_CTXDAT_TB_OFF_pbRecon(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16AES128_CTXDAT_TB_OFF_pbRecon(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_AES128_CTXDAT;

	#define	dftAES128_CTXDAT_TB_OFF 	0xCCCCCCCC
			typedef	union {	UNSG32		u32;
								struct	w32AES128_CTXDAT_TB_OFF;
										} T32AES128_CTXDAT_TB_OFF;
	#define	dftAES128_CTXDAT_TB_OFF1 	0x0000CCCC
			typedef	union {	UNSG32		u32;
								struct	w32AES128_CTXDAT_TB_OFF1;
										} T32AES128_CTXDAT_TB_OFF1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	AES128_CTXDAT_drvrd (SIE_AES128_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	AES128_CTXDAT_drvwr (SIE_AES128_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	AES128_CTXDAT_reset (SIE_AES128_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	AES128_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		AES128_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	AES128_CTXDAT_print(p,    ps8name,hfpErrLOG)		AES128_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	AES128_CTXDAT_cmp   (SIE_AES128_CTXDAT *p, SIE_AES128_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	AES128_CTXDAT_import(SIE_AES128_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	AES128_CTXDAT_export(SIE_AES128_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: AES128_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: HAMMING_INVALID_ENTRY
*	@
*			:  VAL  0xff
*						*  *
*						*  Invalid hamming table entry
*	@
*		%unsigned  32  dummy
**********************************************************************************************************************/
#ifdef	h_HAMMING_INVALID_ENTRY
#else
#define	h_HAMMING_INVALID_ENTRY

#define	\
	AR_HAMMING_INVALID_ENTRY \
		1
#define	\
	AB_HAMMING_INVALID_ENTRY \
		2

	#define	HAMMING_INVALID_ENTRY_VAL 	0xFF

typedef struct SIE_HAMMING_INVALID_ENTRY {

	#define	RA_HAMMING_INVALID_ENTRY_D0th_ ISC_USE_ONLY	0x00000
	#define	w32HAMMING_INVALID_ENTRY_D0th_ {									\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32HAMMING_INVALID_ENTRY_D0th_;

	/* [31: 0] */	#define	  BA_HAMMING_INVALID_ENTRY_dummy		 0x00000
	/* ---:--- */	#define	    bHAMMING_INVALID_ENTRY_dummy		   32 /*bit*/
	/* ---:--- */	#define	LSb32HAMMING_INVALID_ENTRY_dummy		    0 /*:31*/
	/* ---:--- */	#define	MSK32HAMMING_INVALID_ENTRY_dummy		       0xFFFFFFFF
	/* ---:--- */	#define	GET32HAMMING_INVALID_ENTRY_dummy(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16HAMMING_INVALID_ENTRY_dummy(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32HAMMING_INVALID_ENTRY_dummy(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16HAMMING_INVALID_ENTRY_dummy(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_HAMMING_INVALID_ENTRY;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	HAMMING_INVALID_ENTRY_drvrd (SIE_HAMMING_INVALID_ENTRY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	HAMMING_INVALID_ENTRY_drvwr (SIE_HAMMING_INVALID_ENTRY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	HAMMING_INVALID_ENTRY_reset (SIE_HAMMING_INVALID_ENTRY *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	HAMMING_INVALID_ENTRY_check(p,pie,ps8name,hfpErrLOG)		HAMMING_INVALID_ENTRY_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	HAMMING_INVALID_ENTRY_print(p,    ps8name,hfpErrLOG)		HAMMING_INVALID_ENTRY_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	HAMMING_INVALID_ENTRY_cmp   (SIE_HAMMING_INVALID_ENTRY *p, SIE_HAMMING_INVALID_ENTRY *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	HAMMING_INVALID_ENTRY_import(SIE_HAMMING_INVALID_ENTRY *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	HAMMING_INVALID_ENTRY_export(SIE_HAMMING_INVALID_ENTRY *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: HAMMING_INVALID_ENTRY
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: OFFTB_ENTRY
*	@
*		%unsigned  8  dat2ham
*						*  *
*						*  Offset mapping from data offset to hamming bit offset
*		%unsigned  8  ham2dat
*						*  *
*						*  Offset mapping from hamming bit offset to data bit offset
**********************************************************************************************************************/
#ifdef	h_OFFTB_ENTRY
#else
#define	h_OFFTB_ENTRY

#define	\
	AR_OFFTB_ENTRY \
		1
#define	\
	AB_OFFTB_ENTRY \
		2

typedef struct SIE_OFFTB_ENTRY {

	#define	RA_OFFTB_ENTRY_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32OFFTB_ENTRY_D0th_ 		{										\
					UNSG32				u_dat2ham					 :  8;		\
					UNSG32				u_ham2dat					 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32OFFTB_ENTRY_D0th_;

	/* [ 7: 0] */	#define	  BA_OFFTB_ENTRY_dat2ham				 0x00000
	/* ---:--- */	#define	    bOFFTB_ENTRY_dat2ham				    8 /*bit*/
	/* ---:--- */	#define	LSb32OFFTB_ENTRY_dat2ham				    0 /*: 7*/
	/* ---:--- */	#define	MSK32OFFTB_ENTRY_dat2ham				       0x000000FF
	/* ---:--- */	#define	GET32OFFTB_ENTRY_dat2ham(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16OFFTB_ENTRY_dat2ham(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32OFFTB_ENTRY_dat2ham(r32,v)				do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16OFFTB_ENTRY_dat2ham(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_OFFTB_ENTRY_ham2dat				 0x00001
	/* ---:--- */	#define	    bOFFTB_ENTRY_ham2dat				    8 /*bit*/
	/* ---:--- */	#define	LSb32OFFTB_ENTRY_ham2dat				    8 /*:15*/
	/* ---:--- */	#define	MSK32OFFTB_ENTRY_ham2dat				       0x0000FF00
	/* ---:--- */	#define	GET32OFFTB_ENTRY_ham2dat(r32)				 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16OFFTB_ENTRY_ham2dat(r16)				 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32OFFTB_ENTRY_ham2dat(r32,v)				do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16OFFTB_ENTRY_ham2dat(r16,v)				do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

} SIE_OFFTB_ENTRY;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	OFFTB_ENTRY_drvrd (SIE_OFFTB_ENTRY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	OFFTB_ENTRY_drvwr (SIE_OFFTB_ENTRY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	OFFTB_ENTRY_reset (SIE_OFFTB_ENTRY *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	OFFTB_ENTRY_check(p,pie,ps8name,hfpErrLOG)		OFFTB_ENTRY_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	OFFTB_ENTRY_print(p,    ps8name,hfpErrLOG)		OFFTB_ENTRY_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	OFFTB_ENTRY_cmp   (SIE_OFFTB_ENTRY *p, SIE_OFFTB_ENTRY *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	OFFTB_ENTRY_import(SIE_OFFTB_ENTRY *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	OFFTB_ENTRY_export(SIE_OFFTB_ENTRY *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: OFFTB_ENTRY
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: HAMMING_RODAT
*	@  OFFSET_TB64
*		$UINT32  offsetTb64  REG  [64]
*						*  *
*						*  Offset mapping table
*	@  MASK_TB64
*		$UINT32  maskTb64  REG  [16]
*						*  *
*						*  mask table
*	@  MOD2SUM_TB64
*		$UINT32  mod2SumTb64  REG  [128]
*						*  *
*						*  Modula 2 sum table
**********************************************************************************************************************/
#ifdef	h_HAMMING_RODAT
#else
#define	h_HAMMING_RODAT

#define	\
	AR_HAMMING_RODAT \
		208
#define	\
	AB_HAMMING_RODAT \
		10

typedef struct SIE_HAMMING_RODAT {

	#define	RA_HAMMING_RODAT_OFFSET_TB64 0x00000
	/* @'00000 */	SIE_UINT32 					ie_offsetTb64		 [64];
					#define	 arr_HAMMING_RODAT_offsetTb64 			  64

	#define	RA_HAMMING_RODAT_MASK_TB64 	0x00100
	/* @'00100 */	SIE_UINT32 					ie_maskTb64			 [16];
					#define	 arr_HAMMING_RODAT_maskTb64 			  16

	#define	RA_HAMMING_RODAT_MOD2SUM_TB64 0x00140
	/* @'00140 */	SIE_UINT32 					ie_mod2SumTb64		 [128];
					#define	 arr_HAMMING_RODAT_mod2SumTb64 			  128

} SIE_HAMMING_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	HAMMING_RODAT_drvrd (SIE_HAMMING_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	HAMMING_RODAT_drvwr (SIE_HAMMING_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	HAMMING_RODAT_reset (SIE_HAMMING_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	HAMMING_RODAT_check(p,pie,ps8name,hfpErrLOG)		HAMMING_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	HAMMING_RODAT_print(p,    ps8name,hfpErrLOG)		HAMMING_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	HAMMING_RODAT_cmp   (SIE_HAMMING_RODAT *p, SIE_HAMMING_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	HAMMING_RODAT_import(SIE_HAMMING_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	HAMMING_RODAT_export(SIE_HAMMING_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: HAMMING_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DES3_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_DES3_RODAT
#else
#define	h_DES3_RODAT

#define	\
	AR_DES3_RODAT \
		1
#define	\
	AB_DES3_RODAT \
		2

typedef struct SIE_DES3_RODAT {

	#define	RA_DES3_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_DES3_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DES3_RODAT_drvrd (SIE_DES3_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DES3_RODAT_drvwr (SIE_DES3_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DES3_RODAT_reset (SIE_DES3_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DES3_RODAT_check(p,pie,ps8name,hfpErrLOG)		DES3_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DES3_RODAT_print(p,    ps8name,hfpErrLOG)		DES3_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DES3_RODAT_cmp   (SIE_DES3_RODAT *p, SIE_DES3_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DES3_RODAT_import(SIE_DES3_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DES3_RODAT_export(SIE_DES3_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DES3_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DES3_CTXDAT
*	@
*		$UINT32  a64Blk  REG  [190]
**********************************************************************************************************************/
#ifdef	h_DES3_CTXDAT
#else
#define	h_DES3_CTXDAT

#define	\
	AR_DES3_CTXDAT \
		190
#define	\
	AB_DES3_CTXDAT \
		10

typedef struct SIE_DES3_CTXDAT {

	#define	RA_DES3_CTXDAT_a64Blk 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_a64Blk			 [190];
					#define	 arr_DES3_CTXDAT_a64Blk 				  190

} SIE_DES3_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DES3_CTXDAT_drvrd (SIE_DES3_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DES3_CTXDAT_drvwr (SIE_DES3_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DES3_CTXDAT_reset (SIE_DES3_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DES3_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		DES3_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DES3_CTXDAT_print(p,    ps8name,hfpErrLOG)		DES3_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DES3_CTXDAT_cmp   (SIE_DES3_CTXDAT *p, SIE_DES3_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DES3_CTXDAT_import(SIE_DES3_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DES3_CTXDAT_export(SIE_DES3_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DES3_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DES_CTXDAT
*	@
*		$UINT32  a64Blk  REG  [190]
*	@
*		$UINT64  puTd0  REG  [64]
*	@
*		$UINT64  puTd1  REG  [64]
*	@
*		$UINT64  puTd2  REG  [64]
*	@
*		$UINT64  puTd3  REG  [64]
*	@
*		$UINT64  puEncKey  REG  [16]
**********************************************************************************************************************/
#ifdef	h_DES_CTXDAT
#else
#define	h_DES_CTXDAT

#define	\
	AR_DES_CTXDAT \
		734
#define	\
	AB_DES_CTXDAT \
		12

typedef struct SIE_DES_CTXDAT {

	#define	RA_DES_CTXDAT_a64Blk 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_a64Blk			 [190];
					#define	 arr_DES_CTXDAT_a64Blk 					  190

	#define	RA_DES_CTXDAT_puTd0 		0x002F8
	/* @'002F8 */	SIE_UINT64 					ie_puTd0			 [64];
					#define	 arr_DES_CTXDAT_puTd0 					  64

	#define	RA_DES_CTXDAT_puTd1 		0x004F8
	/* @'004F8 */	SIE_UINT64 					ie_puTd1			 [64];
					#define	 arr_DES_CTXDAT_puTd1 					  64

	#define	RA_DES_CTXDAT_puTd2 		0x006F8
	/* @'006F8 */	SIE_UINT64 					ie_puTd2			 [64];
					#define	 arr_DES_CTXDAT_puTd2 					  64

	#define	RA_DES_CTXDAT_puTd3 		0x008F8
	/* @'008F8 */	SIE_UINT64 					ie_puTd3			 [64];
					#define	 arr_DES_CTXDAT_puTd3 					  64

	#define	RA_DES_CTXDAT_puEncKey 		0x00AF8
	/* @'00AF8 */	SIE_UINT64 					ie_puEncKey			 [16];
					#define	 arr_DES_CTXDAT_puEncKey 				  16

} SIE_DES_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DES_CTXDAT_drvrd (SIE_DES_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DES_CTXDAT_drvwr (SIE_DES_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DES_CTXDAT_reset (SIE_DES_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DES_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		DES_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DES_CTXDAT_print(p,    ps8name,hfpErrLOG)		DES_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DES_CTXDAT_cmp   (SIE_DES_CTXDAT *p, SIE_DES_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DES_CTXDAT_import(SIE_DES_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DES_CTXDAT_export(SIE_DES_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DES_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: MULT2_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_MULT2_RODAT
#else
#define	h_MULT2_RODAT

#define	\
	AR_MULT2_RODAT \
		1
#define	\
	AB_MULT2_RODAT \
		2

typedef struct SIE_MULT2_RODAT {

	#define	RA_MULT2_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_MULT2_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	MULT2_RODAT_drvrd (SIE_MULT2_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	MULT2_RODAT_drvwr (SIE_MULT2_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	MULT2_RODAT_reset (SIE_MULT2_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	MULT2_RODAT_check(p,pie,ps8name,hfpErrLOG)		MULT2_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	MULT2_RODAT_print(p,    ps8name,hfpErrLOG)		MULT2_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	MULT2_RODAT_cmp   (SIE_MULT2_RODAT *p, SIE_MULT2_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	MULT2_RODAT_import(SIE_MULT2_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	MULT2_RODAT_export(SIE_MULT2_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: MULT2_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: MULT2_CTXDAT
*	@
*		$UINT32  a64Blk  REG  [640]
*						*  *
*						*  The array size is determined by the round number. For round number 128, 640 is ok.
**********************************************************************************************************************/
#ifdef	h_MULT2_CTXDAT
#else
#define	h_MULT2_CTXDAT

#define	\
	AR_MULT2_CTXDAT \
		640
#define	\
	AB_MULT2_CTXDAT \
		12

typedef struct SIE_MULT2_CTXDAT {

	#define	RA_MULT2_CTXDAT_a64Blk 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_a64Blk			 [640];
					#define	 arr_MULT2_CTXDAT_a64Blk 				  640

} SIE_MULT2_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	MULT2_CTXDAT_drvrd (SIE_MULT2_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	MULT2_CTXDAT_drvwr (SIE_MULT2_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	MULT2_CTXDAT_reset (SIE_MULT2_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	MULT2_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		MULT2_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	MULT2_CTXDAT_print(p,    ps8name,hfpErrLOG)		MULT2_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	MULT2_CTXDAT_cmp   (SIE_MULT2_CTXDAT *p, SIE_MULT2_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	MULT2_CTXDAT_import(SIE_MULT2_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	MULT2_CTXDAT_export(SIE_MULT2_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: MULT2_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: C2_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_C2_RODAT
#else
#define	h_C2_RODAT

#define	\
	AR_C2_RODAT \
		1
#define	\
	AB_C2_RODAT \
		2

typedef struct SIE_C2_RODAT {

	#define	RA_C2_RODAT_dummy 			0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_C2_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	C2_RODAT_drvrd (SIE_C2_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	C2_RODAT_drvwr (SIE_C2_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	C2_RODAT_reset (SIE_C2_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	C2_RODAT_check(p,pie,ps8name,hfpErrLOG)		C2_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	C2_RODAT_print(p,    ps8name,hfpErrLOG)		C2_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	C2_RODAT_cmp   (SIE_C2_RODAT *p, SIE_C2_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	C2_RODAT_import(SIE_C2_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	C2_RODAT_export(SIE_C2_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: C2_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: C2_CTXDAT
*	@
*		$UINT32  a64Blk  REG  [360]
**********************************************************************************************************************/
#ifdef	h_C2_CTXDAT
#else
#define	h_C2_CTXDAT

#define	\
	AR_C2_CTXDAT \
		360
#define	\
	AB_C2_CTXDAT \
		11

typedef struct SIE_C2_CTXDAT {

	#define	RA_C2_CTXDAT_a64Blk 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_a64Blk			 [360];
					#define	 arr_C2_CTXDAT_a64Blk 					  360

} SIE_C2_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	C2_CTXDAT_drvrd (SIE_C2_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	C2_CTXDAT_drvwr (SIE_C2_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	C2_CTXDAT_reset (SIE_C2_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	C2_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		C2_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	C2_CTXDAT_print(p,    ps8name,hfpErrLOG)		C2_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	C2_CTXDAT_cmp   (SIE_C2_CTXDAT *p, SIE_C2_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	C2_CTXDAT_import(SIE_C2_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	C2_CTXDAT_export(SIE_C2_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: C2_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: PSS_CTXDAT
*	@
*		$UINT64  puSalt  REG  [3]
*						*  *
*						*  Salt Data
*	@
*		$UINT64  puEM  REG  [16]
*						*  *
*						*  RSA PSS encoded Message data
*	@
*		$UINT64  pudbMask  REG  [16]
*						*  *
*						*  Mask data generated by MGF
*	@
*		$UINT64  pumaskDB  REG  [16]
*						*  *
*	@
*		$UINT64  puHash  REG  [3]
*						*  *
*						*  Hash value of the message
*	@
*		$UINT64  puRcvHash  REG  [3]
*						*  *
*						*  Recovered hash value of the message during the verification process
*	@
*		$UINT32  puPssRet
*						*  *
*						*  RSA PSS signature and verification return value
*						*  *
*						*  RSA_PSS_OK
*						*  0xa
*						*  *
*						*  Process is ok
*						*  *
*						*  RSA_PSS_FAILED
*						*  0xb
*	@
*		$UINT32  reseverd
**********************************************************************************************************************/
#ifdef	h_PSS_CTXDAT
#else
#define	h_PSS_CTXDAT

#define	\
	AR_PSS_CTXDAT \
		116
#define	\
	AB_PSS_CTXDAT \
		9

typedef struct SIE_PSS_CTXDAT {

	#define	RA_PSS_CTXDAT_puSalt 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_puSalt			 [3];
					#define	 arr_PSS_CTXDAT_puSalt 					  3

	#define	RA_PSS_CTXDAT_puEM 			0x00018
	/* @'00018 */	SIE_UINT64 					ie_puEM				 [16];
					#define	 arr_PSS_CTXDAT_puEM 					  16

	#define	RA_PSS_CTXDAT_pudbMask 		0x00098
	/* @'00098 */	SIE_UINT64 					ie_pudbMask			 [16];
					#define	 arr_PSS_CTXDAT_pudbMask 				  16

	#define	RA_PSS_CTXDAT_pumaskDB 		0x00118
	/* @'00118 */	SIE_UINT64 					ie_pumaskDB			 [16];
					#define	 arr_PSS_CTXDAT_pumaskDB 				  16

	#define	RA_PSS_CTXDAT_puHash 		0x00198
	/* @'00198 */	SIE_UINT64 					ie_puHash			 [3];
					#define	 arr_PSS_CTXDAT_puHash 					  3

	#define	RA_PSS_CTXDAT_puRcvHash 	0x001B0
	/* @'001B0 */	SIE_UINT64 					ie_puRcvHash		 [3];
					#define	 arr_PSS_CTXDAT_puRcvHash 				  3

	#define	RA_PSS_CTXDAT_puPssRet 		0x001C8
	/* @'001C8 */	SIE_UINT32 					ie_puPssRet;

	#define	RA_PSS_CTXDAT_reseverd 		0x001CC
	/* @'001CC */	SIE_UINT32 					ie_reseverd;

} SIE_PSS_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	PSS_CTXDAT_drvrd (SIE_PSS_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	PSS_CTXDAT_drvwr (SIE_PSS_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	PSS_CTXDAT_reset (SIE_PSS_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	PSS_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		PSS_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	PSS_CTXDAT_print(p,    ps8name,hfpErrLOG)		PSS_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	PSS_CTXDAT_cmp   (SIE_PSS_CTXDAT *p, SIE_PSS_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	PSS_CTXDAT_import(SIE_PSS_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	PSS_CTXDAT_export(SIE_PSS_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: PSS_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: RSA_RODAT
*	@
*		$UINT32  a64Blk  REG  [80]
**********************************************************************************************************************/
#ifdef	h_RSA_RODAT
#else
#define	h_RSA_RODAT

#define	\
	AR_RSA_RODAT \
		80
#define	\
	AB_RSA_RODAT \
		9

typedef struct SIE_RSA_RODAT {

	#define	RA_RSA_RODAT_a64Blk 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_a64Blk			 [80];
					#define	 arr_RSA_RODAT_a64Blk 					  80

} SIE_RSA_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	RSA_RODAT_drvrd (SIE_RSA_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	RSA_RODAT_drvwr (SIE_RSA_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	RSA_RODAT_reset (SIE_RSA_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	RSA_RODAT_check(p,pie,ps8name,hfpErrLOG)		RSA_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	RSA_RODAT_print(p,    ps8name,hfpErrLOG)		RSA_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	RSA_RODAT_cmp   (SIE_RSA_RODAT *p, SIE_RSA_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	RSA_RODAT_import(SIE_RSA_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	RSA_RODAT_export(SIE_RSA_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: RSA_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: RSA_CTXDAT
*	@
*		$UINT64  pbRsaMod  REG  [16]
*	@
*		$UINT64  pbPwr0  REG  [16]
*						*  *
*	@
*		$UINT64  pbPwr1  REG  [16]
*						*  *
*	@
*		$UINT64  pbPwr2  REG  [16]
*						*  *
*	@
*		$UINT64  pbBufT  REG  [16]
*						*  *
*						*  Temporary buffer store the Expmod result during the MulMod operation
*	@
*		$UINT64  pbBufAdd  REG  [32]
*						*  *
*						*  Addition buffer for the computation of 1024 bits multiply
*	@
*		$UINT32  pbBufDiv  REG  [65]
*						*  *
*						*  Divide or Multiply buffer store the result of multiply of two 1024 bits big numbers
*	@
*		$UINT32  puShift
*						*  *
**********************************************************************************************************************/
#ifdef	h_RSA_CTXDAT
#else
#define	h_RSA_CTXDAT

#define	\
	AR_RSA_CTXDAT \
		290
#define	\
	AB_RSA_CTXDAT \
		11

typedef struct SIE_RSA_CTXDAT {

	#define	RA_RSA_CTXDAT_pbRsaMod 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_pbRsaMod			 [16];
					#define	 arr_RSA_CTXDAT_pbRsaMod 				  16

	#define	RA_RSA_CTXDAT_pbPwr0 		0x00080
	/* @'00080 */	SIE_UINT64 					ie_pbPwr0			 [16];
					#define	 arr_RSA_CTXDAT_pbPwr0 					  16

	#define	RA_RSA_CTXDAT_pbPwr1 		0x00100
	/* @'00100 */	SIE_UINT64 					ie_pbPwr1			 [16];
					#define	 arr_RSA_CTXDAT_pbPwr1 					  16

	#define	RA_RSA_CTXDAT_pbPwr2 		0x00180
	/* @'00180 */	SIE_UINT64 					ie_pbPwr2			 [16];
					#define	 arr_RSA_CTXDAT_pbPwr2 					  16

	#define	RA_RSA_CTXDAT_pbBufT 		0x00200
	/* @'00200 */	SIE_UINT64 					ie_pbBufT			 [16];
					#define	 arr_RSA_CTXDAT_pbBufT 					  16

	#define	RA_RSA_CTXDAT_pbBufAdd 		0x00280
	/* @'00280 */	SIE_UINT64 					ie_pbBufAdd			 [32];
					#define	 arr_RSA_CTXDAT_pbBufAdd 				  32

	#define	RA_RSA_CTXDAT_pbBufDiv 		0x00380
	/* @'00380 */	SIE_UINT32 					ie_pbBufDiv			 [65];
					#define	 arr_RSA_CTXDAT_pbBufDiv 				  65

	#define	RA_RSA_CTXDAT_puShift 		0x00484
	/* @'00484 */	SIE_UINT32 					ie_puShift;

} SIE_RSA_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	RSA_CTXDAT_drvrd (SIE_RSA_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	RSA_CTXDAT_drvwr (SIE_RSA_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	RSA_CTXDAT_reset (SIE_RSA_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	RSA_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		RSA_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	RSA_CTXDAT_print(p,    ps8name,hfpErrLOG)		RSA_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	RSA_CTXDAT_cmp   (SIE_RSA_CTXDAT *p, SIE_RSA_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	RSA_CTXDAT_import(SIE_RSA_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	RSA_CTXDAT_export(SIE_RSA_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: RSA_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CBCMAC_CTXDAT
*	@
*		$UINT64  sum
*	@
*		$UINT64  t
*	@
*		$UINT32  buf  REG  [2]
*	@
*		$UINT32  bufLen
*	@
*		$UINT32  reserved
*	@
*		$UINT64  pbFullMac
*	@
*		$UINT64  pbPartMac
*	@
*		$UINT64  pbCBCKey  REG  [6]
*	@
*		$UINT64  pbiCBCKey  REG  [6]
*	@
*		$UINT64  a64Blk  REG  [70]
**********************************************************************************************************************/
#ifdef	h_CBCMAC_CTXDAT
#else
#define	h_CBCMAC_CTXDAT

#define	\
	AR_CBCMAC_CTXDAT \
		176
#define	\
	AB_CBCMAC_CTXDAT \
		10

typedef struct SIE_CBCMAC_CTXDAT {

	#define	RA_CBCMAC_CTXDAT_sum 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_sum;

	#define	RA_CBCMAC_CTXDAT_t 			0x00008
	/* @'00008 */	SIE_UINT64 					ie_t;

	#define	RA_CBCMAC_CTXDAT_buf 		0x00010
	/* @'00010 */	SIE_UINT32 					ie_buf				 [2];
					#define	 arr_CBCMAC_CTXDAT_buf 					  2

	#define	RA_CBCMAC_CTXDAT_bufLen 	0x00018
	/* @'00018 */	SIE_UINT32 					ie_bufLen;

	#define	RA_CBCMAC_CTXDAT_reserved 	0x0001C
	/* @'0001C */	SIE_UINT32 					ie_reserved;

	#define	RA_CBCMAC_CTXDAT_pbFullMac 	0x00020
	/* @'00020 */	SIE_UINT64 					ie_pbFullMac;

	#define	RA_CBCMAC_CTXDAT_pbPartMac 	0x00028
	/* @'00028 */	SIE_UINT64 					ie_pbPartMac;

	#define	RA_CBCMAC_CTXDAT_pbCBCKey 	0x00030
	/* @'00030 */	SIE_UINT64 					ie_pbCBCKey			 [6];
					#define	 arr_CBCMAC_CTXDAT_pbCBCKey 			  6

	#define	RA_CBCMAC_CTXDAT_pbiCBCKey 	0x00060
	/* @'00060 */	SIE_UINT64 					ie_pbiCBCKey		 [6];
					#define	 arr_CBCMAC_CTXDAT_pbiCBCKey 			  6

	#define	RA_CBCMAC_CTXDAT_a64Blk 	0x00090
	/* @'00090 */	SIE_UINT64 					ie_a64Blk			 [70];
					#define	 arr_CBCMAC_CTXDAT_a64Blk 				  70

} SIE_CBCMAC_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CBCMAC_CTXDAT_drvrd (SIE_CBCMAC_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CBCMAC_CTXDAT_drvwr (SIE_CBCMAC_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CBCMAC_CTXDAT_reset (SIE_CBCMAC_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CBCMAC_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		CBCMAC_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CBCMAC_CTXDAT_print(p,    ps8name,hfpErrLOG)		CBCMAC_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CBCMAC_CTXDAT_cmp   (SIE_CBCMAC_CTXDAT *p, SIE_CBCMAC_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CBCMAC_CTXDAT_import(SIE_CBCMAC_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CBCMAC_CTXDAT_export(SIE_CBCMAC_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CBCMAC_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: RC4_CTXDAT
*	@
*		$UINT64  puState  REG  [64]
*	@
*		%unsigned  16  x
*		%unsigned  16  y
*	@
*		$UINT32  reserved
**********************************************************************************************************************/
#ifdef	h_RC4_CTXDAT
#else
#define	h_RC4_CTXDAT

#define	\
	AR_RC4_CTXDAT \
		130
#define	\
	AB_RC4_CTXDAT \
		10

typedef struct SIE_RC4_CTXDAT {

	#define	RA_RC4_CTXDAT_puState 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_puState			 [64];
					#define	 arr_RC4_CTXDAT_puState 				  64

	#define	RA_RC4_CTXDAT_D128th_ 		ISC_USE_ONLY	0x00200
	#define	w32RC4_CTXDAT_D128th_ 		{										\
					UNSG32				u_x							 : 16;		\
					UNSG32				u_y							 : 16;		\
										}
	/* @'00200 */				struct	w32RC4_CTXDAT_D128th_;

	/* [15: 0] */	#define	  BA_RC4_CTXDAT_x						 0x00200
	/* ---:--- */	#define	    bRC4_CTXDAT_x						   16 /*bit*/
	/* ---:--- */	#define	LSb32RC4_CTXDAT_x						    0 /*:15*/
	/* ---:--- */	#define	MSK32RC4_CTXDAT_x						       0x0000FFFF
	/* ---:--- */	#define	GET32RC4_CTXDAT_x(r32)						 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16RC4_CTXDAT_x(r16)						 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32RC4_CTXDAT_x(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16RC4_CTXDAT_x(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_RC4_CTXDAT_y						 0x00202
	/* ---:--- */	#define	    bRC4_CTXDAT_y						   16 /*bit*/
	/* ---:--- */	#define	LSb32RC4_CTXDAT_y						   16 /*:31*/
	/* ---:--- */	#define	MSK32RC4_CTXDAT_y						       0xFFFF0000
	/* ---:--- */	#define	GET32RC4_CTXDAT_y(r32)						 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16RC4_CTXDAT_y(r16)						 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32RC4_CTXDAT_y(r32,v)					do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16RC4_CTXDAT_y(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_RC4_CTXDAT_reserved 		0x00204
	/* @'00204 */	SIE_UINT32 					ie_reserved;

} SIE_RC4_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	RC4_CTXDAT_drvrd (SIE_RC4_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	RC4_CTXDAT_drvwr (SIE_RC4_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	RC4_CTXDAT_reset (SIE_RC4_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	RC4_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		RC4_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	RC4_CTXDAT_print(p,    ps8name,hfpErrLOG)		RC4_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	RC4_CTXDAT_cmp   (SIE_RC4_CTXDAT *p, SIE_RC4_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	RC4_CTXDAT_import(SIE_RC4_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	RC4_CTXDAT_export(SIE_RC4_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: RC4_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: MD5_CTXDAT
*	@
*		$UINT64  puCount
*						*  *
*						*  Counter
*	@
*		$UINT32  pbBuf  REG  [16]
*						*  *
*						*  Internal buffer
*	@
*		$UINT32  puState  REG  [6]
*						*  *
*						*  Hash state
*	@
*		$UINT64  a64Blk  REG  [70]
**********************************************************************************************************************/
#ifdef	h_MD5_CTXDAT
#else
#define	h_MD5_CTXDAT

#define	\
	AR_MD5_CTXDAT \
		164
#define	\
	AB_MD5_CTXDAT \
		10

typedef struct SIE_MD5_CTXDAT {

	#define	RA_MD5_CTXDAT_puCount 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_puCount;

	#define	RA_MD5_CTXDAT_pbBuf 		0x00008
	/* @'00008 */	SIE_UINT32 					ie_pbBuf			 [16];
					#define	 arr_MD5_CTXDAT_pbBuf 					  16

	#define	RA_MD5_CTXDAT_puState 		0x00048
	/* @'00048 */	SIE_UINT32 					ie_puState			 [6];
					#define	 arr_MD5_CTXDAT_puState 				  6

	#define	RA_MD5_CTXDAT_a64Blk 		0x00060
	/* @'00060 */	SIE_UINT64 					ie_a64Blk			 [70];
					#define	 arr_MD5_CTXDAT_a64Blk 					  70

} SIE_MD5_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	MD5_CTXDAT_drvrd (SIE_MD5_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	MD5_CTXDAT_drvwr (SIE_MD5_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	MD5_CTXDAT_reset (SIE_MD5_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	MD5_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		MD5_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	MD5_CTXDAT_print(p,    ps8name,hfpErrLOG)		MD5_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	MD5_CTXDAT_cmp   (SIE_MD5_CTXDAT *p, SIE_MD5_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	MD5_CTXDAT_import(SIE_MD5_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	MD5_CTXDAT_export(SIE_MD5_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: MD5_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_CMD_TYPE
*	@
*			:  LD_FIGOIMG  0
*						*  *
*						*  Load and verify FIGO image
*	@
*			:  LD_ARMIMG  1
*						*  *
*						*  Load and verify ARM image
*	@
*			:  MK_ARMIMG  2
*						*  *
*						*  Sign and encrypt ARM image, and sign type is default sign type, CMAC
*	@
*			:  MK_ARMIMG_RSAPSS  4
*						*  *
*						*  Sign and encrypt ARM image,and sign type is RSA
*	@
*		%unsigned  32  dummy
**********************************************************************************************************************/
#ifdef	h_DRMROM_CMD_TYPE
#else
#define	h_DRMROM_CMD_TYPE

#define	\
	AR_DRMROM_CMD_TYPE \
		1
#define	\
	AB_DRMROM_CMD_TYPE \
		2

	#define	DRMROM_CMD_TYPE_LD_FIGOIMG 	0x0
	#define	DRMROM_CMD_TYPE_LD_ARMIMG 	0x1
	#define	DRMROM_CMD_TYPE_MK_ARMIMG 	0x2
	#define	DRMROM_CMD_TYPE_MK_ARMIMG_RSAPSS 0x4

typedef struct SIE_DRMROM_CMD_TYPE {

	#define	RA_DRMROM_CMD_TYPE_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRMROM_CMD_TYPE_D0th_ 	{										\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32DRMROM_CMD_TYPE_D0th_;

	/* [31: 0] */	#define	  BA_DRMROM_CMD_TYPE_dummy				 0x00000
	/* ---:--- */	#define	    bDRMROM_CMD_TYPE_dummy				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_TYPE_dummy				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_TYPE_dummy				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_TYPE_dummy(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_TYPE_dummy(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_TYPE_dummy(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_TYPE_dummy(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMROM_CMD_TYPE;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_CMD_TYPE_drvrd (SIE_DRMROM_CMD_TYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_CMD_TYPE_drvwr (SIE_DRMROM_CMD_TYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_CMD_TYPE_reset (SIE_DRMROM_CMD_TYPE *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_CMD_TYPE_check(p,pie,ps8name,hfpErrLOG)		DRMROM_CMD_TYPE_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_CMD_TYPE_print(p,    ps8name,hfpErrLOG)		DRMROM_CMD_TYPE_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_CMD_TYPE_cmp   (SIE_DRMROM_CMD_TYPE *p, SIE_DRMROM_CMD_TYPE *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_CMD_TYPE_import(SIE_DRMROM_CMD_TYPE *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_CMD_TYPE_export(SIE_DRMROM_CMD_TYPE *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_CMD_TYPE
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_CMD
*	@  STAT  (R-W-)  0
*		%unsigned  1  en
*						*  *
*						*  1: Indicate command has been issued by ARM. CMD register contains the command body
*						*  0 : Indicate command has been executed by FIGO . RSP register contains the response body
*	@  CMD_CFG  (W)  0
*		%unsigned  8  tag  0
*						*  *
*						*  Command ordinal, LD_FIGOIMG or LD_ARMIMG
*						*  0
*		%unsigned  8  subKeyID  0
*						*  *
*						*  The ID of key used to encrypt the image
*						*  0
*		%unsigned  16  nonce  0
*						*  *
*						*  Command ID
*						*  0
*	@  CMD_DAT0
*		%unsigned  32  crcCmd32  0
*						*  *
*						*  Command CRC32 value
*	@  CMD_DAT1
*		%unsigned  32  imgSz  0
*						*  *
*						*  Image size of instruction
*						*  0
*	@  CMD_DAT2
*		%unsigned  32  imgSrcAddr  0
*						*  *
*						*  Image source address in DDR. To simplfy the FIGO macrocode design and improve the data transfer performance, imgSrcAddr should be aligned to 32 bytes
*	@  CMD_DAT3
*		%unsigned  32  imgDstAddr  0
*						*  *
*						*  Image destination address aligned to 32 bytes
*	@  RSP_CFG  (R)  0
*		%unsigned  8  tag  0
*						*  *
*						*  Response ordinal, LD_FIGOIMG or LD_ARMIMG
*						*  0
*	@  RSP_DAT0
*		%unsigned  32  crcRsp32  0
*						*  *
*						*  Response CRC32 value calculated with corresponding command nonce value
*						*  0
*	@  RSP_DAT1
*		%unsigned  32  error  0
*						*  *
*						*  Response error code. 0 : Succeed
*						*  0
*	@
*		%unsigned  32  reserved  0
**********************************************************************************************************************/
#ifdef	h_DRMROM_CMD
#else
#define	h_DRMROM_CMD

#define	\
	AR_DRMROM_CMD \
		10
#define	\
	AB_DRMROM_CMD \
		6

typedef struct SIE_DRMROM_CMD {

	#define	RA_DRMROM_CMD_STAT 			0x00000
	#define	w32DRMROM_CMD_STAT 			{										\
					UNSG32				uSTAT_en					 :  1;		\
					UNSG32				_x00000	: 31;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRMROM_CMD_STAT;
								struct	w32DRMROM_CMD_STAT;
										};

	/* [ 0: 0] */	#define	  BA_DRMROM_CMD_STAT_en					 0x00000
	/* ---:--- */	#define	    bDRMROM_CMD_STAT_en					    1 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_STAT_en					    0 /*: 0*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_STAT_en					       0x00000001
	/* ---:--- */	#define	GET32DRMROM_CMD_STAT_en(r32)				 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16DRMROM_CMD_STAT_en(r16)				 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32DRMROM_CMD_STAT_en(r32,v)				do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_STAT_en(r16,v)				do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_CFG 		0x00004
	#define	w32DRMROM_CMD_CMD_CFG 		{										\
					UNSG32				uCMD_CFG_tag				 :  8;		\
					UNSG32				uCMD_CFG_subKeyID			 :  8;		\
					UNSG32				uCMD_CFG_nonce				 : 16;		\
										}
	/* @'00004 */	union {	UNSG32		u32DRMROM_CMD_CMD_CFG;
								struct	w32DRMROM_CMD_CMD_CFG;
										};

	/* [ 7: 0] */	#define	  BA_DRMROM_CMD_CMD_CFG_tag				 0x00004
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_CFG_tag				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_CFG_tag				    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_CFG_tag				       0x000000FF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_CFG_tag(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_CFG_tag(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_CFG_tag(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_CFG_tag(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_DRMROM_CMD_CMD_CFG_subKeyID		 0x00005
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_CFG_subKeyID		    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_CFG_subKeyID		    8 /*:15*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_CFG_subKeyID		       0x0000FF00
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_CFG_subKeyID(r32)		 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_CFG_subKeyID(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_CFG_subKeyID(r32,v)		do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_CFG_subKeyID(r16,v)		do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [31:16] */	#define	  BA_DRMROM_CMD_CMD_CFG_nonce			 0x00006
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_CFG_nonce			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_CFG_nonce			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_CFG_nonce			       0xFFFF0000
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_CFG_nonce(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_CFG_nonce(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_CFG_nonce(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_CFG_nonce(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_DAT0 		0x00008
	#define	w32DRMROM_CMD_CMD_DAT0 		{										\
					UNSG32				uCMD_DAT0_crcCmd32			 : 32;		\
										}
	/* @'00008 */	union {	UNSG32		u32DRMROM_CMD_CMD_DAT0;
								struct	w32DRMROM_CMD_CMD_DAT0;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_CMD_DAT0_crcCmd32		 0x00008
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_DAT0_crcCmd32		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_DAT0_crcCmd32		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_DAT0_crcCmd32		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_DAT0_crcCmd32(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_DAT0_crcCmd32(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_DAT0_crcCmd32(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_DAT0_crcCmd32(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_DAT1 		0x0000C
	#define	w32DRMROM_CMD_CMD_DAT1 		{										\
					UNSG32				uCMD_DAT1_imgSz				 : 32;		\
										}
	/* @'0000C */	union {	UNSG32		u32DRMROM_CMD_CMD_DAT1;
								struct	w32DRMROM_CMD_CMD_DAT1;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_CMD_DAT1_imgSz			 0x0000C
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_DAT1_imgSz			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_DAT1_imgSz			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_DAT1_imgSz			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_DAT1_imgSz(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_DAT1_imgSz(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_DAT1_imgSz(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_DAT1_imgSz(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_DAT2 		0x00010
	#define	w32DRMROM_CMD_CMD_DAT2 		{										\
					UNSG32				uCMD_DAT2_imgSrcAddr		 : 32;		\
										}
	/* @'00010 */	union {	UNSG32		u32DRMROM_CMD_CMD_DAT2;
								struct	w32DRMROM_CMD_CMD_DAT2;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_CMD_DAT2_imgSrcAddr		 0x00010
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_DAT2_imgSrcAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_DAT2_imgSrcAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_DAT2_imgSrcAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_DAT2_imgSrcAddr(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_DAT2_imgSrcAddr(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_DAT2_imgSrcAddr(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_DAT2_imgSrcAddr(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_DAT3 		0x00014
	#define	w32DRMROM_CMD_CMD_DAT3 		{										\
					UNSG32				uCMD_DAT3_imgDstAddr		 : 32;		\
										}
	/* @'00014 */	union {	UNSG32		u32DRMROM_CMD_CMD_DAT3;
								struct	w32DRMROM_CMD_CMD_DAT3;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_CMD_DAT3_imgDstAddr		 0x00014
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_DAT3_imgDstAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_DAT3_imgDstAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_DAT3_imgDstAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_DAT3_imgDstAddr(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_DAT3_imgDstAddr(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_DAT3_imgDstAddr(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_DAT3_imgDstAddr(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_RSP_CFG 		0x00018
	#define	w32DRMROM_CMD_RSP_CFG 		{										\
					UNSG32				uRSP_CFG_tag				 :  8;		\
					UNSG32				_x00018	: 24;							\
										}
	/* @'00018 */	union {	UNSG32		u32DRMROM_CMD_RSP_CFG;
								struct	w32DRMROM_CMD_RSP_CFG;
										};

	/* [ 7: 0] */	#define	  BA_DRMROM_CMD_RSP_CFG_tag				 0x00018
	/* ---:--- */	#define	    bDRMROM_CMD_RSP_CFG_tag				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_RSP_CFG_tag				    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_RSP_CFG_tag				       0x000000FF
	/* ---:--- */	#define	GET32DRMROM_CMD_RSP_CFG_tag(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMROM_CMD_RSP_CFG_tag(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMROM_CMD_RSP_CFG_tag(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_RSP_CFG_tag(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_RSP_DAT0 		0x0001C
	#define	w32DRMROM_CMD_RSP_DAT0 		{										\
					UNSG32				uRSP_DAT0_crcRsp32			 : 32;		\
										}
	/* @'0001C */	union {	UNSG32		u32DRMROM_CMD_RSP_DAT0;
								struct	w32DRMROM_CMD_RSP_DAT0;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_RSP_DAT0_crcRsp32		 0x0001C
	/* ---:--- */	#define	    bDRMROM_CMD_RSP_DAT0_crcRsp32		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_RSP_DAT0_crcRsp32		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_RSP_DAT0_crcRsp32		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_RSP_DAT0_crcRsp32(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_RSP_DAT0_crcRsp32(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_RSP_DAT0_crcRsp32(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_RSP_DAT0_crcRsp32(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_RSP_DAT1 		0x00020
	#define	w32DRMROM_CMD_RSP_DAT1 		{										\
					UNSG32				uRSP_DAT1_error				 : 32;		\
										}
	/* @'00020 */	union {	UNSG32		u32DRMROM_CMD_RSP_DAT1;
								struct	w32DRMROM_CMD_RSP_DAT1;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_RSP_DAT1_error			 0x00020
	/* ---:--- */	#define	    bDRMROM_CMD_RSP_DAT1_error			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_RSP_DAT1_error			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_RSP_DAT1_error			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_RSP_DAT1_error(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_RSP_DAT1_error(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_RSP_DAT1_error(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_RSP_DAT1_error(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_D9th_ 		ISC_USE_ONLY	0x00024
	#define	w32DRMROM_CMD_D9th_ 		{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00024 */				struct	w32DRMROM_CMD_D9th_;

	/* [31: 0] */	#define	  BA_DRMROM_CMD_reserved				 0x00024
	/* ---:--- */	#define	    bDRMROM_CMD_reserved				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_reserved				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_reserved				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_reserved(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_reserved(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMROM_CMD;

	#define	dftDRMROM_CMD_STAT 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_STAT;
										} T32DRMROM_CMD_STAT;
	#define	dftDRMROM_CMD_CMD_CFG 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_CFG;
										} T32DRMROM_CMD_CMD_CFG;
	#define	dftDRMROM_CMD_CMD_DAT0 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_DAT0;
										} T32DRMROM_CMD_CMD_DAT0;
	#define	dftDRMROM_CMD_CMD_DAT1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_DAT1;
										} T32DRMROM_CMD_CMD_DAT1;
	#define	dftDRMROM_CMD_CMD_DAT2 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_DAT2;
										} T32DRMROM_CMD_CMD_DAT2;
	#define	dftDRMROM_CMD_CMD_DAT3 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_DAT3;
										} T32DRMROM_CMD_CMD_DAT3;
	#define	dftDRMROM_CMD_RSP_CFG 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_RSP_CFG;
										} T32DRMROM_CMD_RSP_CFG;
	#define	dftDRMROM_CMD_RSP_DAT0 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_RSP_DAT0;
										} T32DRMROM_CMD_RSP_DAT0;
	#define	dftDRMROM_CMD_RSP_DAT1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_RSP_DAT1;
										} T32DRMROM_CMD_RSP_DAT1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_CMD_drvrd (SIE_DRMROM_CMD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_CMD_drvwr (SIE_DRMROM_CMD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_CMD_reset (SIE_DRMROM_CMD *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_CMD_check(p,pie,ps8name,hfpErrLOG)		DRMROM_CMD_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_CMD_print(p,    ps8name,hfpErrLOG)		DRMROM_CMD_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_CMD_cmp   (SIE_DRMROM_CMD *p, SIE_DRMROM_CMD *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_CMD_import(SIE_DRMROM_CMD *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_CMD_export(SIE_DRMROM_CMD *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_CMD
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_DROM
*	@
*		$AES128_RODAT  aesROData
*						*  *
*						*  AES 128 bits algorithm specific read only data
*	@
*		$HAMMING_RODAT  hamming64RODat
*						*  *
*						*  Hamming 64-7 tables
*	@
*		$CRC32_RODAT  crc32ROData
*						*  *
*						*  CRC32 algorithm specific read only data
*	@
*		$SHA1_RODAT  sha1ROData
*						*  *
*						*  SHA-1 algorithm specific read only data
*	@
*		$RSA_RODAT  rsaROData
*						*  *
*						*  RSA algorithm specific read only data
*	@
*		$UINT128  aesROMKey  REG  [64]
*						*  *
*						*  AES ROM Key data
*	@
*		$UINT128  rsaPrvKey  REG  [8]
*	@
*		$UINT128  rsaPrvMod  REG  [8]
*	@
*		$UINT128  rsaPubKey  REG  [4]
*	@
*		$UINT128  rsaMod  REG  [8]
*						*  *
*						*  RSA Private and Public pair Key Data in ROM
**********************************************************************************************************************/
#ifdef	h_DRM_DROM
#else
#define	h_DRM_DROM

#define	\
	AR_DRM_DROM \
		1828
#define	\
	AB_DRM_DROM \
		13

typedef struct SIE_DRM_DROM {

	#define	RA_DRM_DROM_aesROData 		0x00000
	/* @'00000 */	SIE_AES128_RODAT 			ie_aesROData;

	#define	RA_DRM_DROM_hamming64RODat 	0x00810
	/* @'00810 */	SIE_HAMMING_RODAT 			ie_hamming64RODat;

	#define	RA_DRM_DROM_crc32ROData 	0x00B50
	/* @'00B50 */	SIE_CRC32_RODAT 			ie_crc32ROData;

	#define	RA_DRM_DROM_sha1ROData 		0x00C90
	/* @'00C90 */	SIE_SHA1_RODAT 				ie_sha1ROData;

	#define	RA_DRM_DROM_rsaROData 		0x01590
	/* @'01590 */	SIE_RSA_RODAT 				ie_rsaROData;

	#define	RA_DRM_DROM_aesROMKey 		0x016D0
	/* @'016D0 */	SIE_UINT128 				ie_aesROMKey		 [64];
					#define	 arr_DRM_DROM_aesROMKey 				  64

	#define	RA_DRM_DROM_rsaPrvKey 		0x01AD0
	/* @'01AD0 */	SIE_UINT128 				ie_rsaPrvKey		 [8];
					#define	 arr_DRM_DROM_rsaPrvKey 				  8

	#define	RA_DRM_DROM_rsaPrvMod 		0x01B50
	/* @'01B50 */	SIE_UINT128 				ie_rsaPrvMod		 [8];
					#define	 arr_DRM_DROM_rsaPrvMod 				  8

	#define	RA_DRM_DROM_rsaPubKey 		0x01BD0
	/* @'01BD0 */	SIE_UINT128 				ie_rsaPubKey		 [4];
					#define	 arr_DRM_DROM_rsaPubKey 				  4

	#define	RA_DRM_DROM_rsaMod 			0x01C10
	/* @'01C10 */	SIE_UINT128 				ie_rsaMod			 [8];
					#define	 arr_DRM_DROM_rsaMod 					  8

} SIE_DRM_DROM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_DROM_drvrd (SIE_DRM_DROM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_DROM_drvwr (SIE_DRM_DROM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_DROM_reset (SIE_DRM_DROM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_DROM_check(p,pie,ps8name,hfpErrLOG)		DRM_DROM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_DROM_print(p,    ps8name,hfpErrLOG)		DRM_DROM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_DROM_cmp   (SIE_DRM_DROM *p, SIE_DRM_DROM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_DROM_import(SIE_DRM_DROM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_DROM_export(SIE_DRM_DROM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_DROM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_FIFOIDX
*	@
*			:  DS  0
*						*  *
*						*  DS FIFo IDx
*	@
*		%unsigned  32  dummy
**********************************************************************************************************************/
#ifdef	h_DRMROM_FIFOIDX
#else
#define	h_DRMROM_FIFOIDX

#define	\
	AR_DRMROM_FIFOIDX \
		1
#define	\
	AB_DRMROM_FIFOIDX \
		2

	#define	DRMROM_FIFOIDX_DS 			0x0

typedef struct SIE_DRMROM_FIFOIDX {

	#define	RA_DRMROM_FIFOIDX_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRMROM_FIFOIDX_D0th_ 	{										\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32DRMROM_FIFOIDX_D0th_;

	/* [31: 0] */	#define	  BA_DRMROM_FIFOIDX_dummy				 0x00000
	/* ---:--- */	#define	    bDRMROM_FIFOIDX_dummy				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_FIFOIDX_dummy				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_FIFOIDX_dummy				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_FIFOIDX_dummy(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_FIFOIDX_dummy(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_FIFOIDX_dummy(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_FIFOIDX_dummy(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMROM_FIFOIDX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_FIFOIDX_drvrd (SIE_DRMROM_FIFOIDX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_FIFOIDX_drvwr (SIE_DRMROM_FIFOIDX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_FIFOIDX_reset (SIE_DRMROM_FIFOIDX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_FIFOIDX_check(p,pie,ps8name,hfpErrLOG)		DRMROM_FIFOIDX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_FIFOIDX_print(p,    ps8name,hfpErrLOG)		DRMROM_FIFOIDX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_FIFOIDX_cmp   (SIE_DRMROM_FIFOIDX *p, SIE_DRMROM_FIFOIDX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_FIFOIDX_import(SIE_DRMROM_FIFOIDX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_FIFOIDX_export(SIE_DRMROM_FIFOIDX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_FIFOIDX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_SRAM_RESERVED
*	@
*		$UINT128  reserved  REG  [128]
*						*  *
*						*  Reserved ROM SRAM
**********************************************************************************************************************/
#ifdef	h_DRMROM_SRAM_RESERVED
#else
#define	h_DRMROM_SRAM_RESERVED

#define	\
	AR_DRMROM_SRAM_RESERVED \
		512
#define	\
	AB_DRMROM_SRAM_RESERVED \
		11

typedef struct SIE_DRMROM_SRAM_RESERVED {

	#define	RA_DRMROM_SRAM_RESERVED_reserved 0x00000
	/* @'00000 */	SIE_UINT128 				ie_reserved			 [128];
					#define	 arr_DRMROM_SRAM_RESERVED_reserved 		  128

} SIE_DRMROM_SRAM_RESERVED;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_SRAM_RESERVED_drvrd (SIE_DRMROM_SRAM_RESERVED *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_SRAM_RESERVED_drvwr (SIE_DRMROM_SRAM_RESERVED *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_SRAM_RESERVED_reset (SIE_DRMROM_SRAM_RESERVED *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_SRAM_RESERVED_check(p,pie,ps8name,hfpErrLOG)		DRMROM_SRAM_RESERVED_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_SRAM_RESERVED_print(p,    ps8name,hfpErrLOG)		DRMROM_SRAM_RESERVED_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_SRAM_RESERVED_cmp   (SIE_DRMROM_SRAM_RESERVED *p, SIE_DRMROM_SRAM_RESERVED *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_SRAM_RESERVED_import(SIE_DRMROM_SRAM_RESERVED *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_SRAM_RESERVED_export(SIE_DRMROM_SRAM_RESERVED *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_SRAM_RESERVED
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: USERKEY_CTX
*	@
*		$UINT64  magicNum
*	@
*		$UINT128  aesUserKey  REG  [2]
*	@
*		$UINT128  rsaPubKey  REG  [4]
*	@
*		$UINT128  rsaMod  REG  [8]
*	@
*		$UINT128  rsaPrvKey  REG  [8]
*	@
*		$UINT128  rsaPrvMod  REG  [8]
**********************************************************************************************************************/
#ifdef	h_USERKEY_CTX
#else
#define	h_USERKEY_CTX

#define	\
	AR_USERKEY_CTX \
		122
#define	\
	AB_USERKEY_CTX \
		9

typedef struct SIE_USERKEY_CTX {

	#define	RA_USERKEY_CTX_magicNum 	0x00000
	/* @'00000 */	SIE_UINT64 					ie_magicNum;

	#define	RA_USERKEY_CTX_aesUserKey 	0x00008
	/* @'00008 */	SIE_UINT128 				ie_aesUserKey		 [2];
					#define	 arr_USERKEY_CTX_aesUserKey 			  2

	#define	RA_USERKEY_CTX_rsaPubKey 	0x00028
	/* @'00028 */	SIE_UINT128 				ie_rsaPubKey		 [4];
					#define	 arr_USERKEY_CTX_rsaPubKey 				  4

	#define	RA_USERKEY_CTX_rsaMod 		0x00068
	/* @'00068 */	SIE_UINT128 				ie_rsaMod			 [8];
					#define	 arr_USERKEY_CTX_rsaMod 				  8

	#define	RA_USERKEY_CTX_rsaPrvKey 	0x000E8
	/* @'000E8 */	SIE_UINT128 				ie_rsaPrvKey		 [8];
					#define	 arr_USERKEY_CTX_rsaPrvKey 				  8

	#define	RA_USERKEY_CTX_rsaPrvMod 	0x00168
	/* @'00168 */	SIE_UINT128 				ie_rsaPrvMod		 [8];
					#define	 arr_USERKEY_CTX_rsaPrvMod 				  8

} SIE_USERKEY_CTX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	USERKEY_CTX_drvrd (SIE_USERKEY_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	USERKEY_CTX_drvwr (SIE_USERKEY_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	USERKEY_CTX_reset (SIE_USERKEY_CTX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	USERKEY_CTX_check(p,pie,ps8name,hfpErrLOG)		USERKEY_CTX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	USERKEY_CTX_print(p,    ps8name,hfpErrLOG)		USERKEY_CTX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	USERKEY_CTX_cmp   (SIE_USERKEY_CTX *p, SIE_USERKEY_CTX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	USERKEY_CTX_import(SIE_USERKEY_CTX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	USERKEY_CTX_export(SIE_USERKEY_CTX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: USERKEY_CTX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: USERKEY_MAGICNUM
*	@  DAT
*		%unsigned  16  ID
*			:  magicA  0x06a5
*			:  magicB  0x06a5
*			:  magicC  0x06a5
*			:  magicD  0x06a5
**********************************************************************************************************************/
#ifdef	h_USERKEY_MAGICNUM
#else
#define	h_USERKEY_MAGICNUM

#define	\
	AR_USERKEY_MAGICNUM \
		1
#define	\
	AB_USERKEY_MAGICNUM \
		2

typedef struct SIE_USERKEY_MAGICNUM {

	#define	RA_USERKEY_MAGICNUM_DAT 	0x00000
	#define	w32USERKEY_MAGICNUM_DAT 	{										\
					UNSG32				uDAT_ID						 : 16;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */	union {	UNSG32		u32USERKEY_MAGICNUM_DAT;
								struct	w32USERKEY_MAGICNUM_DAT;
										};

	/* [15: 0] */	#define	  BA_USERKEY_MAGICNUM_DAT_ID			 0x00000
	/* ---:--- */	#define	    bUSERKEY_MAGICNUM_DAT_ID			   16 /*bit*/
	/* ---:--- */	#define	LSb32USERKEY_MAGICNUM_DAT_ID			    0 /*:15*/
	/* ---:--- */	#define	MSK32USERKEY_MAGICNUM_DAT_ID			       0x0000FFFF
	/* ---:--- */	#define	GET32USERKEY_MAGICNUM_DAT_ID(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16USERKEY_MAGICNUM_DAT_ID(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32USERKEY_MAGICNUM_DAT_ID(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16USERKEY_MAGICNUM_DAT_ID(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)
					#define	     USERKEY_MAGICNUM_DAT_ID_magicA				0x6A5
					#define	     USERKEY_MAGICNUM_DAT_ID_magicB				0x6A5
					#define	     USERKEY_MAGICNUM_DAT_ID_magicC				0x6A5
					#define	     USERKEY_MAGICNUM_DAT_ID_magicD				0x6A5

} SIE_USERKEY_MAGICNUM;

	#define	dftUSERKEY_MAGICNUM_DAT 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32USERKEY_MAGICNUM_DAT;
										} T32USERKEY_MAGICNUM_DAT;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	USERKEY_MAGICNUM_drvrd (SIE_USERKEY_MAGICNUM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	USERKEY_MAGICNUM_drvwr (SIE_USERKEY_MAGICNUM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	USERKEY_MAGICNUM_reset (SIE_USERKEY_MAGICNUM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	USERKEY_MAGICNUM_check(p,pie,ps8name,hfpErrLOG)		USERKEY_MAGICNUM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	USERKEY_MAGICNUM_print(p,    ps8name,hfpErrLOG)		USERKEY_MAGICNUM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	USERKEY_MAGICNUM_cmp   (SIE_USERKEY_MAGICNUM *p, SIE_USERKEY_MAGICNUM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	USERKEY_MAGICNUM_import(SIE_USERKEY_MAGICNUM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	USERKEY_MAGICNUM_export(SIE_USERKEY_MAGICNUM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: USERKEY_MAGICNUM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_SRAM
*	@
*		$DRMROM_CMD  cmd
*						*  *
*						*  ROM code command and response buffer
*	@
*		$LocalArea  la
*						*  *
*						*  Local data area
*	@
*		$UINT64  dsFifoDat  REG  [16]
*						*  *
*						*  Data streamer fifo data
*	@
*		$DRM_SYMKEYCTX256_IN  symSignKey
*						*  *
*						*  AES128 based symmetric signature key context
*	@
*		$DRM_RSAKEYCTX1024_IN  asymSignKey
*						*  *
*						*  RSA1924 based asymmetric signature key context
*	@
*		$DRM_SYMKEYCTX256_IN  aesRKEK
*						*  *
*						*  AES128 RKEK key context
*	@
*		$DRM_SYMKEYCTX256_IN  aesSubKey
*						*  *
*						*  AES128 sub key context
*	@
*		$UINT128  rndKeyBuf  REG  [16]
*						*  *
*						*  Temporary buffer for round keys
*	@
*		$UINT32  imgHdrInfo  REG  [32]
*						*  *
*						*  Stored image header information
*	@
*		$UINT32  authDatCtx  REG  [32]
*						*  *
*						*  Stored image header information
*	@
*		$UINT64  otpBits  REG  [40]
*						*  *
*						*  All OTP bits
*	@
*		$OTP_CRC32  otpCrc32
*						*  *
*						*  OTP CRC32 value for three regions of OTP data
*	@  SEC_BITS
*		%unsigned  16  prvkSecBits0
*						*  *
*						*  Private key security bits 0
*		%unsigned  16  prvkSecBits1
*						*  *
*						*  Private key security bits 0
*		%unsigned  16  prvkSecBits2
*						*  *
*						*  Private key security bits 0
*		%unsigned  16  rkekSecBits
*						*  *
*						*  RKEK key security bits 0
*		%unsigned  16  aeskSecBits
*						*  *
*						*  AES key security bits
*	@
*		$OTP_STATUS  otpStatus
*						*  *
*						*  All OTP bits
*	@
*		$SHA1_CTXDAT  shaCtx
*						*  *
*						*  SHA1 Context for RSA PSS signature verification
*	@
*		$USERKEY_CTX  userKeyCtx
*						*  *
*						*  AES User Key data
*	@
*		$RSA_CTXDAT  rsaCtx
*						*  *
*						*  RSA Context for RSA PSS signature verification
*	@
*		$UINT128  bufTmp  MEM
*						*  *
*						*  Temporary Buffer
*	@  0x0ff0
*		$UINT128  stack
*						*  *
*						*  Stack
*	@  0x1000
*		$UINT128  dsTransBuf  REG  [256]
*						*  *
*						*  Transfer memory
**********************************************************************************************************************/
#ifdef	h_DRMROM_SRAM
#else
#define	h_DRMROM_SRAM

#define	\
	AR_DRMROM_SRAM \
		2048
#define	\
	AB_DRMROM_SRAM \
		13

typedef struct SIE_DRMROM_SRAM {

	#define	RA_DRMROM_SRAM_cmd 			0x00000
	/* @'00000 */	SIE_DRMROM_CMD 				ie_cmd;

	#define	RA_DRMROM_SRAM_la 			0x00028
	/* @'00028 */	SIE_LocalArea 				ie_la;

	#define	RA_DRMROM_SRAM_dsFifoDat 	0x00250
	/* @'00250 */	SIE_UINT64 					ie_dsFifoDat		 [16];
					#define	 arr_DRMROM_SRAM_dsFifoDat 				  16

	#define	RA_DRMROM_SRAM_symSignKey 	0x002D0
	/* @'002D0 */	SIE_DRM_SYMKEYCTX256_IN 	ie_symSignKey;

	#define	RA_DRMROM_SRAM_asymSignKey 	0x00330
	/* @'00330 */	SIE_DRM_RSAKEYCTX1024_IN 	ie_asymSignKey;

	#define	RA_DRMROM_SRAM_aesRKEK 		0x003E0
	/* @'003E0 */	SIE_DRM_SYMKEYCTX256_IN 	ie_aesRKEK;

	#define	RA_DRMROM_SRAM_aesSubKey 	0x00440
	/* @'00440 */	SIE_DRM_SYMKEYCTX256_IN 	ie_aesSubKey;

	#define	RA_DRMROM_SRAM_rndKeyBuf 	0x004A0
	/* @'004A0 */	SIE_UINT128 				ie_rndKeyBuf		 [16];
					#define	 arr_DRMROM_SRAM_rndKeyBuf 				  16

	#define	RA_DRMROM_SRAM_imgHdrInfo 	0x005A0
	/* @'005A0 */	SIE_UINT32 					ie_imgHdrInfo		 [32];
					#define	 arr_DRMROM_SRAM_imgHdrInfo 			  32

	#define	RA_DRMROM_SRAM_authDatCtx 	0x00620
	/* @'00620 */	SIE_UINT32 					ie_authDatCtx		 [32];
					#define	 arr_DRMROM_SRAM_authDatCtx 			  32

	#define	RA_DRMROM_SRAM_otpBits 		0x006A0
	/* @'006A0 */	SIE_UINT64 					ie_otpBits			 [40];
					#define	 arr_DRMROM_SRAM_otpBits 				  40

	#define	RA_DRMROM_SRAM_otpCrc32 	0x007E0
	/* @'007E0 */	SIE_OTP_CRC32 				ie_otpCrc32;

	#define	RA_DRMROM_SRAM_SEC_BITS 	0x007F0
	#define	w32DRMROM_SRAM_SEC_BITS 	{										\
					UNSG32				uSEC_BITS_prvkSecBits0		 : 16;		\
					UNSG32				uSEC_BITS_prvkSecBits1		 : 16;		\
										}
	/* @'007F0 */	union {	UNSG32		u32DRMROM_SRAM_SEC_BITS;
								struct	w32DRMROM_SRAM_SEC_BITS;
										};

	/* [15: 0] */	#define	  BA_DRMROM_SRAM_SEC_BITS_prvkSecBits0	 0x007F0
	/* ---:--- */	#define	    bDRMROM_SRAM_SEC_BITS_prvkSecBits0	   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_SRAM_SEC_BITS_prvkSecBits0	    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMROM_SRAM_SEC_BITS_prvkSecBits0	       0x0000FFFF
	/* ---:--- */	#define	GET32DRMROM_SRAM_SEC_BITS_prvkSecBits0(r32)	 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMROM_SRAM_SEC_BITS_prvkSecBits0(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMROM_SRAM_SEC_BITS_prvkSecBits0(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_SRAM_SEC_BITS_prvkSecBits0(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMROM_SRAM_SEC_BITS_prvkSecBits1	 0x007F2
	/* ---:--- */	#define	    bDRMROM_SRAM_SEC_BITS_prvkSecBits1	   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_SRAM_SEC_BITS_prvkSecBits1	   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_SRAM_SEC_BITS_prvkSecBits1	       0xFFFF0000
	/* ---:--- */	#define	GET32DRMROM_SRAM_SEC_BITS_prvkSecBits1(r32)	 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMROM_SRAM_SEC_BITS_prvkSecBits1(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMROM_SRAM_SEC_BITS_prvkSecBits1(r32,v)do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMROM_SRAM_SEC_BITS_prvkSecBits1(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMROM_SRAM_SEC_BITS1 	0x007F4
	#define	w32DRMROM_SRAM_SEC_BITS1 	{										\
					UNSG32				uSEC_BITS_prvkSecBits2		 : 16;		\
					UNSG32				uSEC_BITS_rkekSecBits		 : 16;		\
										}
	/* @'007F4 */	union {	UNSG32		u32DRMROM_SRAM_SEC_BITS1;
								struct	w32DRMROM_SRAM_SEC_BITS1;
										};

	/* [15: 0] */	#define	  BA_DRMROM_SRAM_SEC_BITS_prvkSecBits2	 0x007F4
	/* ---:--- */	#define	    bDRMROM_SRAM_SEC_BITS_prvkSecBits2	   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_SRAM_SEC_BITS_prvkSecBits2	    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMROM_SRAM_SEC_BITS_prvkSecBits2	       0x0000FFFF
	/* ---:--- */	#define	GET32DRMROM_SRAM_SEC_BITS_prvkSecBits2(r32)	 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMROM_SRAM_SEC_BITS_prvkSecBits2(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMROM_SRAM_SEC_BITS_prvkSecBits2(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_SRAM_SEC_BITS_prvkSecBits2(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMROM_SRAM_SEC_BITS_rkekSecBits	 0x007F6
	/* ---:--- */	#define	    bDRMROM_SRAM_SEC_BITS_rkekSecBits	   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_SRAM_SEC_BITS_rkekSecBits	   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_SRAM_SEC_BITS_rkekSecBits	       0xFFFF0000
	/* ---:--- */	#define	GET32DRMROM_SRAM_SEC_BITS_rkekSecBits(r32)	 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMROM_SRAM_SEC_BITS_rkekSecBits(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMROM_SRAM_SEC_BITS_rkekSecBits(r32,v)do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMROM_SRAM_SEC_BITS_rkekSecBits(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMROM_SRAM_SEC_BITS2 	0x007F8
	#define	w32DRMROM_SRAM_SEC_BITS2 	{										\
					UNSG32				uSEC_BITS_aeskSecBits		 : 16;		\
					UNSG32				_x007F8	: 16;							\
										}
	/* @'007F8 */	union {	UNSG32		u32DRMROM_SRAM_SEC_BITS2;
								struct	w32DRMROM_SRAM_SEC_BITS2;
										};

	/* [15: 0] */	#define	  BA_DRMROM_SRAM_SEC_BITS_aeskSecBits	 0x007F8
	/* ---:--- */	#define	    bDRMROM_SRAM_SEC_BITS_aeskSecBits	   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_SRAM_SEC_BITS_aeskSecBits	    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMROM_SRAM_SEC_BITS_aeskSecBits	       0x0000FFFF
	/* ---:--- */	#define	GET32DRMROM_SRAM_SEC_BITS_aeskSecBits(r32)	 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMROM_SRAM_SEC_BITS_aeskSecBits(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMROM_SRAM_SEC_BITS_aeskSecBits(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_SRAM_SEC_BITS_aeskSecBits(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMROM_SRAM_otpStatus 	0x007FC
	/* @'007FC */	SIE_OTP_STATUS 				ie_otpStatus;

	#define	RA_DRMROM_SRAM_shaCtx 		0x00800
	/* @'00800 */	SIE_SHA1_CTXDAT 			ie_shaCtx;

	#define	RA_DRMROM_SRAM_userKeyCtx 	0x00860
	/* @'00860 */	SIE_USERKEY_CTX 			ie_userKeyCtx;

	#define	RA_DRMROM_SRAM_rsaCtx 		0x00A48
	/* @'00A48 */	SIE_RSA_CTXDAT 				ie_rsaCtx;

	#define	RA_DRMROM_SRAM_bufTmp 		0x00ED0
	/* @'00ED0 */	SIE_UINT128 				ie_bufTmp;

	UNSG32	_PAD_000[(0x00FF0-0x00EE0)/4];
	#define	RA_DRMROM_SRAM_stack 		0x00FF0
	/* @'00FF0 */	SIE_UINT128 				ie_stack;

	#define	RA_DRMROM_SRAM_dsTransBuf 	0x01000
	/* @'01000 */	SIE_UINT128 				ie_dsTransBuf		 [256];
					#define	 arr_DRMROM_SRAM_dsTransBuf 			  256

} SIE_DRMROM_SRAM;

	#define	dftDRMROM_SRAM_SEC_BITS 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_SRAM_SEC_BITS;
										} T32DRMROM_SRAM_SEC_BITS;
	#define	dftDRMROM_SRAM_SEC_BITS1 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_SRAM_SEC_BITS1;
										} T32DRMROM_SRAM_SEC_BITS1;
	#define	dftDRMROM_SRAM_SEC_BITS2 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_SRAM_SEC_BITS2;
										} T32DRMROM_SRAM_SEC_BITS2;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_SRAM_drvrd (SIE_DRMROM_SRAM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_SRAM_drvwr (SIE_DRMROM_SRAM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_SRAM_reset (SIE_DRMROM_SRAM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_SRAM_check(p,pie,ps8name,hfpErrLOG)		DRMROM_SRAM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_SRAM_print(p,    ps8name,hfpErrLOG)		DRMROM_SRAM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_SRAM_cmp   (SIE_DRMROM_SRAM *p, SIE_DRMROM_SRAM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_SRAM_import(SIE_DRMROM_SRAM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_SRAM_export(SIE_DRMROM_SRAM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_SRAM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_CMD
*	@  CMD  (W)  0
*		%unsigned  8  tag  0
*						*  *
*						*  Command ordinal, LD_FIGOIMG or LD_ARMIMG
*						*  0
*		%unsigned  24  nonce  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		%unsigned  32  crcCmd32  0
*						*  *
*						*  Command CRC32 value
*	@
*		$UINT32  RET_BODY  [6]
**********************************************************************************************************************/
#ifdef	h_DRM_CMD
#else
#define	h_DRM_CMD

#define	\
	AR_DRM_CMD \
		3
#define	\
	AB_DRM_CMD \
		4

typedef struct SIE_DRM_CMD {

	#define	RA_DRM_CMD_CMD 				0x00000
	#define	w32DRM_CMD_CMD 				{										\
					UNSG32				uCMD_tag					 :  8;		\
					UNSG32				uCMD_nonce					 : 24;		\
										}
	/* @'00000 */	union {	UNSG32		u32DRM_CMD_CMD;
								struct	w32DRM_CMD_CMD;
										};

	/* [ 7: 0] */	#define	  BA_DRM_CMD_CMD_tag					 0x00000
	/* ---:--- */	#define	    bDRM_CMD_CMD_tag					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CMD_CMD_tag					    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_CMD_CMD_tag					       0x000000FF
	/* ---:--- */	#define	GET32DRM_CMD_CMD_tag(r32)					 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_CMD_CMD_tag(r16)					 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_CMD_CMD_tag(r32,v)					do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CMD_CMD_tag(r16,v)					do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31: 8] */	#define	  BA_DRM_CMD_CMD_nonce					 0x00001
	/* ---:--- */	#define	    bDRM_CMD_CMD_nonce					   24 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CMD_CMD_nonce					    8 /*:31*/
	/* ---:--- */	#define	MSK32DRM_CMD_CMD_nonce					       0xFFFFFF00
	/* ---:--- */	#define	GET32DRM_CMD_CMD_nonce(r32)					 (((r32)>> 8)&0xFFFFFF)
	/* ---:--- */	#define	GET16DRM_CMD_CMD_nonce(r16)					 (((r16)>> 8)&0xFFFFFF)
	/* ---:--- */	#define	SET32DRM_CMD_CMD_nonce(r32,v)				do{(r32)&=~(0xFFFFFF<< 8);(r32)|=((v)&0xFFFFFF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRM_CMD_CMD_nonce(r16,v)				do{(r16)&=~(0xFFFFFF<< 8);(r16)|=((v)&0xFFFFFF)<< 8;}while(0)

	#define	RA_DRM_CMD_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DRM_CMD_D1th_ 			{										\
					UNSG32				u_crcCmd32					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_CMD_D1th_;

	/* [31: 0] */	#define	  BA_DRM_CMD_crcCmd32					 0x00004
	/* ---:--- */	#define	    bDRM_CMD_crcCmd32					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CMD_crcCmd32					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_CMD_crcCmd32					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_CMD_crcCmd32(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_CMD_crcCmd32(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_CMD_crcCmd32(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CMD_crcCmd32(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_CMD_RET_BODY 		0x00008
	/* @'00008 */	SIE_UINT32 					ie_RET_BODY;

} SIE_DRM_CMD;

	#define	dftDRM_CMD_CMD 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_CMD_CMD;
										} T32DRM_CMD_CMD;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_CMD_drvrd (SIE_DRM_CMD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_CMD_drvwr (SIE_DRM_CMD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_CMD_reset (SIE_DRM_CMD *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_CMD_check(p,pie,ps8name,hfpErrLOG)		DRM_CMD_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_CMD_print(p,    ps8name,hfpErrLOG)		DRM_CMD_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_CMD_cmp   (SIE_DRM_CMD *p, SIE_DRM_CMD *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_CMD_import(SIE_DRM_CMD *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_CMD_export(SIE_DRM_CMD *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_CMD
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_RSP
*	@  RSP  (R)  0
*		%unsigned  8  tag  0
*						*  *
*						*  Response ordinal, LD_FIGOIMG or LD_ARMIMG
*						*  0
*	@
*		%unsigned  32  crcRsp32  0
*						*  *
*						*  Response CRC32 value calculated with corresponding command nonce value
*						*  0
*	@
*		%unsigned  32  error  0
*						*  *
*						*  Response error code. 0 : Succeed
*						*  0
*	@
*		%unsigned  32  reserved  0
*						*  *
*						*  reserved
*						*  0
**********************************************************************************************************************/
#ifdef	h_DRM_RSP
#else
#define	h_DRM_RSP

#define	\
	AR_DRM_RSP \
		4
#define	\
	AB_DRM_RSP \
		4

typedef struct SIE_DRM_RSP {

	#define	RA_DRM_RSP_RSP 				0x00000
	#define	w32DRM_RSP_RSP 				{										\
					UNSG32				uRSP_tag					 :  8;		\
					UNSG32				_x00000	: 24;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRM_RSP_RSP;
								struct	w32DRM_RSP_RSP;
										};

	/* [ 7: 0] */	#define	  BA_DRM_RSP_RSP_tag					 0x00000
	/* ---:--- */	#define	    bDRM_RSP_RSP_tag					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSP_RSP_tag					    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_RSP_RSP_tag					       0x000000FF
	/* ---:--- */	#define	GET32DRM_RSP_RSP_tag(r32)					 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_RSP_RSP_tag(r16)					 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_RSP_RSP_tag(r32,v)					do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSP_RSP_tag(r16,v)					do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_RSP_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DRM_RSP_D1th_ 			{										\
					UNSG32				u_crcRsp32					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_RSP_D1th_;

	/* [31: 0] */	#define	  BA_DRM_RSP_crcRsp32					 0x00004
	/* ---:--- */	#define	    bDRM_RSP_crcRsp32					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSP_crcRsp32					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSP_crcRsp32					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSP_crcRsp32(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSP_crcRsp32(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSP_crcRsp32(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSP_crcRsp32(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_RSP_D2th_ 			ISC_USE_ONLY	0x00008
	#define	w32DRM_RSP_D2th_ 			{										\
					UNSG32				u_error						 : 32;		\
										}
	/* @'00008 */				struct	w32DRM_RSP_D2th_;

	/* [31: 0] */	#define	  BA_DRM_RSP_error						 0x00008
	/* ---:--- */	#define	    bDRM_RSP_error						   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSP_error						    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSP_error						       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSP_error(r32)						 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSP_error(r16)						 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSP_error(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSP_error(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_RSP_D3th_ 			ISC_USE_ONLY	0x0000C
	#define	w32DRM_RSP_D3th_ 			{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'0000C */				struct	w32DRM_RSP_D3th_;

	/* [31: 0] */	#define	  BA_DRM_RSP_reserved					 0x0000C
	/* ---:--- */	#define	    bDRM_RSP_reserved					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSP_reserved					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSP_reserved					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSP_reserved(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSP_reserved(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSP_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSP_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRM_RSP;

	#define	dftDRM_RSP_RSP 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_RSP_RSP;
										} T32DRM_RSP_RSP;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_RSP_drvrd (SIE_DRM_RSP *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_RSP_drvwr (SIE_DRM_RSP *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_RSP_reset (SIE_DRM_RSP *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_RSP_check(p,pie,ps8name,hfpErrLOG)		DRM_RSP_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_RSP_print(p,    ps8name,hfpErrLOG)		DRM_RSP_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_RSP_cmp   (SIE_DRM_RSP *p, SIE_DRM_RSP *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_RSP_import(SIE_DRM_RSP *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_RSP_export(SIE_DRM_RSP *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_RSP
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMCMD_HASH
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_SHA1_START
*						*  DRMCMD_SHA1_UPDATE
*						*  DRMCMD_SHA1_END.
*						*  DRMCMD_HMAC_START
*						*  DRMCMD_HMAC_UPDATE
*						*  DRMCMD_HMAC_END
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  hashID  0
*						*  *
*						*  Hash conetxt ID
*						*  0
*	@
*		%unsigned  32  datSz  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  32  keyID  0
*						*  *
*						*  Key context ID
*	@
*		%unsigned  32  authDat  0
*						*  *
*						*  Command authentication data
**********************************************************************************************************************/
#ifdef	h_DRMCMD_HASH
#else
#define	h_DRMCMD_HASH

#define	\
	AR_DRMCMD_HASH \
		6
#define	\
	AB_DRMCMD_HASH \
		5

typedef struct SIE_DRMCMD_HASH {

	#define	RA_DRMCMD_HASH_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32DRMCMD_HASH_D0th_ 		{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32DRMCMD_HASH_D0th_;

	/* [ 7: 0] */	#define	  BA_DRMCMD_HASH_cmdCode				 0x00000
	/* ---:--- */	#define	    bDRMCMD_HASH_cmdCode				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_cmdCode				    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_cmdCode				       0x000000FF
	/* ---:--- */	#define	GET32DRMCMD_HASH_cmdCode(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_cmdCode(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_cmdCode(r32,v)				do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_cmdCode(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_DRMCMD_HASH_cmdID					 0x00001
	/* ---:--- */	#define	    bDRMCMD_HASH_cmdID					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_cmdID					    8 /*:15*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_cmdID					       0x0000FF00
	/* ---:--- */	#define	GET32DRMCMD_HASH_cmdID(r32)					 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_cmdID(r16)					 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_cmdID(r32,v)				do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_cmdID(r16,v)				do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_DRMCMD_HASH_hashID 		0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_hashID;

	#define	RA_DRMCMD_HASH_D2th_ 		ISC_USE_ONLY	0x00008
	#define	w32DRMCMD_HASH_D2th_ 		{										\
					UNSG32				u_datSz						 : 32;		\
										}
	/* @'00008 */				struct	w32DRMCMD_HASH_D2th_;

	/* [31: 0] */	#define	  BA_DRMCMD_HASH_datSz					 0x00008
	/* ---:--- */	#define	    bDRMCMD_HASH_datSz					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_datSz					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_datSz					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_HASH_datSz(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_datSz(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_datSz(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_datSz(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_HASH_D3th_ 		ISC_USE_ONLY	0x0000C
	#define	w32DRMCMD_HASH_D3th_ 		{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'0000C */				struct	w32DRMCMD_HASH_D3th_;

	/* [31: 0] */	#define	  BA_DRMCMD_HASH_datSrcAddr				 0x0000C
	/* ---:--- */	#define	    bDRMCMD_HASH_datSrcAddr				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_datSrcAddr				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_datSrcAddr				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_HASH_datSrcAddr(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_datSrcAddr(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_datSrcAddr(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_datSrcAddr(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_HASH_D4th_ 		ISC_USE_ONLY	0x00010
	#define	w32DRMCMD_HASH_D4th_ 		{										\
					UNSG32				u_keyID						 : 32;		\
										}
	/* @'00010 */				struct	w32DRMCMD_HASH_D4th_;

	/* [31: 0] */	#define	  BA_DRMCMD_HASH_keyID					 0x00010
	/* ---:--- */	#define	    bDRMCMD_HASH_keyID					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_keyID					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_keyID					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_HASH_keyID(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_keyID(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_keyID(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_keyID(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_HASH_D5th_ 		ISC_USE_ONLY	0x00014
	#define	w32DRMCMD_HASH_D5th_ 		{										\
					UNSG32				u_authDat					 : 32;		\
										}
	/* @'00014 */				struct	w32DRMCMD_HASH_D5th_;

	/* [31: 0] */	#define	  BA_DRMCMD_HASH_authDat				 0x00014
	/* ---:--- */	#define	    bDRMCMD_HASH_authDat				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_authDat				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_authDat				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_HASH_authDat(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_authDat(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_authDat(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_authDat(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMCMD_HASH;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMCMD_HASH_drvrd (SIE_DRMCMD_HASH *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMCMD_HASH_drvwr (SIE_DRMCMD_HASH *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMCMD_HASH_reset (SIE_DRMCMD_HASH *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMCMD_HASH_check(p,pie,ps8name,hfpErrLOG)		DRMCMD_HASH_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMCMD_HASH_print(p,    ps8name,hfpErrLOG)		DRMCMD_HASH_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMCMD_HASH_cmp   (SIE_DRMCMD_HASH *p, SIE_DRMCMD_HASH *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMCMD_HASH_import(SIE_DRMCMD_HASH *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMCMD_HASH_export(SIE_DRMCMD_HASH *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMCMD_HASH
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMCMD_KEY_ENCDEC
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_AES128_ENC
*						*  DRMCMD_AES128_DEC
*						*  DRMCMD_DES_ENC
*						*  DRMCMD_DES_DEC
*						*  DRMCMD_3xDES_ENC
*						*  DRMCMD_3xDES_DEC
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  keyID  0
*						*  *
*						*  Key context ID
*						*  0
*	@
*		%unsigned  32  datSz  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  1  isSRAMAddr  0
*						*  *
*						*  Flag to indicate whether the destination address belongs to SRAM
*		%unsigned  31  datDstAddr  0
*						*  *
*						*  DDR or SRAM address where the data is stored
*	@
*		%unsigned  32  authDat  0
*						*  *
*						*  Command authentication data
**********************************************************************************************************************/
#ifdef	h_DRMCMD_KEY_ENCDEC
#else
#define	h_DRMCMD_KEY_ENCDEC

#define	\
	AR_DRMCMD_KEY_ENCDEC \
		6
#define	\
	AB_DRMCMD_KEY_ENCDEC \
		5

typedef struct SIE_DRMCMD_KEY_ENCDEC {

	#define	RA_DRMCMD_KEY_ENCDEC_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRMCMD_KEY_ENCDEC_D0th_ 	{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32DRMCMD_KEY_ENCDEC_D0th_;

	/* [ 7: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_cmdCode			 0x00000
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_cmdCode			    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_cmdCode			    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_cmdCode			       0x000000FF
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_cmdCode(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_cmdCode(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_cmdCode(r32,v)		do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_cmdCode(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_DRMCMD_KEY_ENCDEC_cmdID			 0x00001
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_cmdID			    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_cmdID			    8 /*:15*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_cmdID			       0x0000FF00
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_cmdID(r32)			 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_cmdID(r16)			 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_cmdID(r32,v)			do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_cmdID(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_DRMCMD_KEY_ENCDEC_keyID 	0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_keyID;

	#define	RA_DRMCMD_KEY_ENCDEC_D2th_ 	ISC_USE_ONLY	0x00008
	#define	w32DRMCMD_KEY_ENCDEC_D2th_ 	{										\
					UNSG32				u_datSz						 : 32;		\
										}
	/* @'00008 */				struct	w32DRMCMD_KEY_ENCDEC_D2th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_datSz			 0x00008
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_datSz			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_datSz			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_datSz			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_datSz(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_datSz(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_datSz(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_datSz(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_KEY_ENCDEC_D3th_ 	ISC_USE_ONLY	0x0000C
	#define	w32DRMCMD_KEY_ENCDEC_D3th_ 	{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'0000C */				struct	w32DRMCMD_KEY_ENCDEC_D3th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_datSrcAddr		 0x0000C
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_datSrcAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_datSrcAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_datSrcAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_datSrcAddr(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_datSrcAddr(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_datSrcAddr(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_datSrcAddr(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_KEY_ENCDEC_D4th_ 	ISC_USE_ONLY	0x00010
	#define	w32DRMCMD_KEY_ENCDEC_D4th_ 	{										\
					UNSG32				u_isSRAMAddr				 :  1;		\
					UNSG32				u_datDstAddr				 : 31;		\
										}
	/* @'00010 */				struct	w32DRMCMD_KEY_ENCDEC_D4th_;

	/* [ 0: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_isSRAMAddr		 0x00010
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_isSRAMAddr		    1 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_isSRAMAddr		    0 /*: 0*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_isSRAMAddr		       0x00000001
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_isSRAMAddr(r32)		 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_isSRAMAddr(r16)		 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_isSRAMAddr(r32,v)	do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_isSRAMAddr(r16,v)	do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [31: 1] */	#define	  BA_DRMCMD_KEY_ENCDEC_datDstAddr		 0x00010
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_datDstAddr		   31 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_datDstAddr		    1 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_datDstAddr		       0xFFFFFFFE
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_datDstAddr(r32)		 (((r32)>> 1)&0x7FFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_datDstAddr(r16)		 (((r16)>> 1)&0x7FFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_datDstAddr(r32,v)	do{(r32)&=~(0x7FFFFFFF<< 1);(r32)|=((v)&0x7FFFFFFF)<< 1;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_datDstAddr(r16,v)	do{(r16)&=~(0x7FFFFFFF<< 1);(r16)|=((v)&0x7FFFFFFF)<< 1;}while(0)

	#define	RA_DRMCMD_KEY_ENCDEC_D5th_ 	ISC_USE_ONLY	0x00014
	#define	w32DRMCMD_KEY_ENCDEC_D5th_ 	{										\
					UNSG32				u_authDat					 : 32;		\
										}
	/* @'00014 */				struct	w32DRMCMD_KEY_ENCDEC_D5th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_authDat			 0x00014
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_authDat			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_authDat			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_authDat			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_authDat(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_authDat(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_authDat(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_authDat(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMCMD_KEY_ENCDEC;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMCMD_KEY_ENCDEC_drvrd (SIE_DRMCMD_KEY_ENCDEC *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMCMD_KEY_ENCDEC_drvwr (SIE_DRMCMD_KEY_ENCDEC *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMCMD_KEY_ENCDEC_reset (SIE_DRMCMD_KEY_ENCDEC *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMCMD_KEY_ENCDEC_check(p,pie,ps8name,hfpErrLOG)		DRMCMD_KEY_ENCDEC_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMCMD_KEY_ENCDEC_print(p,    ps8name,hfpErrLOG)		DRMCMD_KEY_ENCDEC_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMCMD_KEY_ENCDEC_cmp   (SIE_DRMCMD_KEY_ENCDEC *p, SIE_DRMCMD_KEY_ENCDEC *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMCMD_KEY_ENCDEC_import(SIE_DRMCMD_KEY_ENCDEC *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMCMD_KEY_ENCDEC_export(SIE_DRMCMD_KEY_ENCDEC *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMCMD_KEY_ENCDEC
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMCMD_KEY_TRANS
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_IMPORT_KEY
*						*  DRMCMD_EXPORT_KEY
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  parentKeyID  0
*						*  *
*						*  Parent key context ID. For export operation, it MUST be valid key
*						*  0
*	@
*		$DRM_CTXID  keyID  0
*						*  *
*						*  Destination key context ID
*						*  0
*	@
*		%unsigned  32  datSz  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  32  authDat  0
*						*  *
*						*  Command authentication data
**********************************************************************************************************************/
#ifdef	h_DRMCMD_KEY_TRANS
#else
#define	h_DRMCMD_KEY_TRANS

#define	\
	AR_DRMCMD_KEY_TRANS \
		6
#define	\
	AB_DRMCMD_KEY_TRANS \
		5

typedef struct SIE_DRMCMD_KEY_TRANS {

	#define	RA_DRMCMD_KEY_TRANS_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRMCMD_KEY_TRANS_D0th_ 	{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32DRMCMD_KEY_TRANS_D0th_;

	/* [ 7: 0] */	#define	  BA_DRMCMD_KEY_TRANS_cmdCode			 0x00000
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_cmdCode			    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_cmdCode			    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_cmdCode			       0x000000FF
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_cmdCode(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_cmdCode(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_cmdCode(r32,v)		do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_cmdCode(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_DRMCMD_KEY_TRANS_cmdID				 0x00001
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_cmdID				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_cmdID				    8 /*:15*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_cmdID				       0x0000FF00
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_cmdID(r32)			 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_cmdID(r16)			 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_cmdID(r32,v)			do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_cmdID(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_DRMCMD_KEY_TRANS_parentKeyID 0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_parentKeyID;

	#define	RA_DRMCMD_KEY_TRANS_keyID 	0x00008
	/* @'00008 */	SIE_DRM_CTXID 				ie_keyID;

	#define	RA_DRMCMD_KEY_TRANS_D3th_ 	ISC_USE_ONLY	0x0000C
	#define	w32DRMCMD_KEY_TRANS_D3th_ 	{										\
					UNSG32				u_datSz						 : 32;		\
										}
	/* @'0000C */				struct	w32DRMCMD_KEY_TRANS_D3th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_TRANS_datSz				 0x0000C
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_datSz				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_datSz				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_datSz				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_datSz(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_datSz(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_datSz(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_datSz(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_KEY_TRANS_D4th_ 	ISC_USE_ONLY	0x00010
	#define	w32DRMCMD_KEY_TRANS_D4th_ 	{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'00010 */				struct	w32DRMCMD_KEY_TRANS_D4th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_TRANS_datSrcAddr		 0x00010
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_datSrcAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_datSrcAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_datSrcAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_datSrcAddr(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_datSrcAddr(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_datSrcAddr(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_datSrcAddr(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_KEY_TRANS_D5th_ 	ISC_USE_ONLY	0x00014
	#define	w32DRMCMD_KEY_TRANS_D5th_ 	{										\
					UNSG32				u_authDat					 : 32;		\
										}
	/* @'00014 */				struct	w32DRMCMD_KEY_TRANS_D5th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_TRANS_authDat			 0x00014
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_authDat			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_authDat			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_authDat			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_authDat(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_authDat(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_authDat(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_authDat(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMCMD_KEY_TRANS;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMCMD_KEY_TRANS_drvrd (SIE_DRMCMD_KEY_TRANS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMCMD_KEY_TRANS_drvwr (SIE_DRMCMD_KEY_TRANS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMCMD_KEY_TRANS_reset (SIE_DRMCMD_KEY_TRANS *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMCMD_KEY_TRANS_check(p,pie,ps8name,hfpErrLOG)		DRMCMD_KEY_TRANS_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMCMD_KEY_TRANS_print(p,    ps8name,hfpErrLOG)		DRMCMD_KEY_TRANS_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMCMD_KEY_TRANS_cmp   (SIE_DRMCMD_KEY_TRANS *p, SIE_DRMCMD_KEY_TRANS *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMCMD_KEY_TRANS_import(SIE_DRMCMD_KEY_TRANS *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMCMD_KEY_TRANS_export(SIE_DRMCMD_KEY_TRANS *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMCMD_KEY_TRANS
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CRYPTO_ENGINE_CONST
*	@  CMD
*		%unsigned  8  CODE
*			:  AES128_ENC  0x0
*			:  AES128_DEC  0x1
*			:  RNG_RDDATA  0x2
*			:  SHA1_INIT  0x3
*			:  SHA1_UPDATE  0x4
*			:  SHA1_FINAL  0x5
*			:  RC4_ENC  0x6
*			:  RC4_DEC  0x7
*			:  RC4_SETKEY  0x8  AES
*		%unsigned  8  MODE
*			:  ECB  0x0
*			:  CBC  0x1
*			:  CTR  0x2
*			:  CTS  0x3  ENGINE
*		%unsigned  8  TYPE
*			:  AES  0x01
*			:  HASH  0x02
*			:  RNG  0x03
*			:  RC4  0x04
*			:  READ_OTP  0x05
**********************************************************************************************************************/
#ifdef	h_CRYPTO_ENGINE_CONST
#else
#define	h_CRYPTO_ENGINE_CONST

#define	\
	AR_CRYPTO_ENGINE_CONST \
		1
#define	\
	AB_CRYPTO_ENGINE_CONST \
		2

typedef struct SIE_CRYPTO_ENGINE_CONST {

	#define	RA_CRYPTO_ENGINE_CONST_CMD 	0x00000
	#define	w32CRYPTO_ENGINE_CONST_CMD 	{										\
					UNSG32				uCMD_CODE					 :  8;		\
					UNSG32				uCMD_MODE					 :  8;		\
					UNSG32				uCMD_TYPE					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */	union {	UNSG32		u32CRYPTO_ENGINE_CONST_CMD;
								struct	w32CRYPTO_ENGINE_CONST_CMD;
										};

	/* [ 7: 0] */	#define	  BA_CRYPTO_ENGINE_CONST_CMD_CODE		 0x00000
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CONST_CMD_CODE		    8 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CONST_CMD_CODE		    0 /*: 7*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CONST_CMD_CODE		       0x000000FF
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CONST_CMD_CODE(r32)		 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CONST_CMD_CODE(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CONST_CMD_CODE(r32,v)	do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CONST_CMD_CODE(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_AES128_ENC	0x0
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_AES128_DEC	0x1
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_RNG_RDDATA	0x2
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_SHA1_INIT		0x3
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_SHA1_UPDATE	0x4
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_SHA1_FINAL	0x5
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_RC4_ENC		0x6
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_RC4_DEC		0x7
					#define	     CRYPTO_ENGINE_CONST_CMD_CODE_RC4_SETKEY	0x8

	/* [15: 8] */	#define	  BA_CRYPTO_ENGINE_CONST_CMD_MODE		 0x00001
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CONST_CMD_MODE		    8 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CONST_CMD_MODE		    8 /*:15*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CONST_CMD_MODE		       0x0000FF00
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CONST_CMD_MODE(r32)		 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CONST_CMD_MODE(r16)		 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CONST_CMD_MODE(r32,v)	do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CONST_CMD_MODE(r16,v)	do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)
					#define	     CRYPTO_ENGINE_CONST_CMD_MODE_ECB			0x0
					#define	     CRYPTO_ENGINE_CONST_CMD_MODE_CBC			0x1
					#define	     CRYPTO_ENGINE_CONST_CMD_MODE_CTR			0x2
					#define	     CRYPTO_ENGINE_CONST_CMD_MODE_CTS			0x3

	/* [23:16] */	#define	  BA_CRYPTO_ENGINE_CONST_CMD_TYPE		 0x00002
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CONST_CMD_TYPE		    8 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CONST_CMD_TYPE		   16 /*:23*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CONST_CMD_TYPE		       0x00FF0000
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CONST_CMD_TYPE(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CONST_CMD_TYPE(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CONST_CMD_TYPE(r32,v)	do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CONST_CMD_TYPE(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     CRYPTO_ENGINE_CONST_CMD_TYPE_AES			0x1
					#define	     CRYPTO_ENGINE_CONST_CMD_TYPE_HASH			0x2
					#define	     CRYPTO_ENGINE_CONST_CMD_TYPE_RNG			0x3
					#define	     CRYPTO_ENGINE_CONST_CMD_TYPE_RC4			0x4
					#define	     CRYPTO_ENGINE_CONST_CMD_TYPE_READ_OTP		0x5

} SIE_CRYPTO_ENGINE_CONST;

	#define	dftCRYPTO_ENGINE_CONST_CMD 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CRYPTO_ENGINE_CONST_CMD;
										} T32CRYPTO_ENGINE_CONST_CMD;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CRYPTO_ENGINE_CONST_drvrd (SIE_CRYPTO_ENGINE_CONST *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CRYPTO_ENGINE_CONST_drvwr (SIE_CRYPTO_ENGINE_CONST *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CRYPTO_ENGINE_CONST_reset (SIE_CRYPTO_ENGINE_CONST *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CRYPTO_ENGINE_CONST_check(p,pie,ps8name,hfpErrLOG)		CRYPTO_ENGINE_CONST_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CRYPTO_ENGINE_CONST_print(p,    ps8name,hfpErrLOG)		CRYPTO_ENGINE_CONST_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CRYPTO_ENGINE_CONST_cmp   (SIE_CRYPTO_ENGINE_CONST *p, SIE_CRYPTO_ENGINE_CONST *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CRYPTO_ENGINE_CONST_import(SIE_CRYPTO_ENGINE_CONST *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CRYPTO_ENGINE_CONST_export(SIE_CRYPTO_ENGINE_CONST *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CRYPTO_ENGINE_CONST
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SPHAL_CMD_HASH
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_SHA1_START
*						*  DRMCMD_SHA1_UPDATE
*						*  DRMCMD_SHA1_END.
*						*  DRMCMD_HMAC_START
*						*  DRMCMD_HMAC_UPDATE
*						*  DRMCMD_HMAC_END
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  hashID  0
*						*  *
*						*  Hash conetxt ID
*						*  0
*	@
*		%unsigned  32  datSize  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  32  hashValueAddr  0
*						*  *
*						*  Key context ID
*	@
*		%unsigned  32  reserved  0
**********************************************************************************************************************/
#ifdef	h_SPHAL_CMD_HASH
#else
#define	h_SPHAL_CMD_HASH

#define	\
	AR_SPHAL_CMD_HASH \
		6
#define	\
	AB_SPHAL_CMD_HASH \
		5

typedef struct SIE_SPHAL_CMD_HASH {

	#define	RA_SPHAL_CMD_HASH_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32SPHAL_CMD_HASH_D0th_ 	{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32SPHAL_CMD_HASH_D0th_;

	/* [ 7: 0] */	#define	  BA_SPHAL_CMD_HASH_cmdCode				 0x00000
	/* ---:--- */	#define	    bSPHAL_CMD_HASH_cmdCode				    8 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_HASH_cmdCode				    0 /*: 7*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_HASH_cmdCode				       0x000000FF
	/* ---:--- */	#define	GET32SPHAL_CMD_HASH_cmdCode(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16SPHAL_CMD_HASH_cmdCode(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32SPHAL_CMD_HASH_cmdCode(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_HASH_cmdCode(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_SPHAL_CMD_HASH_cmdID				 0x00001
	/* ---:--- */	#define	    bSPHAL_CMD_HASH_cmdID				    8 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_HASH_cmdID				    8 /*:15*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_HASH_cmdID				       0x0000FF00
	/* ---:--- */	#define	GET32SPHAL_CMD_HASH_cmdID(r32)				 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16SPHAL_CMD_HASH_cmdID(r16)				 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32SPHAL_CMD_HASH_cmdID(r32,v)			do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_HASH_cmdID(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_SPHAL_CMD_HASH_hashID 	0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_hashID;

	#define	RA_SPHAL_CMD_HASH_D2th_ 	ISC_USE_ONLY	0x00008
	#define	w32SPHAL_CMD_HASH_D2th_ 	{										\
					UNSG32				u_datSize					 : 32;		\
										}
	/* @'00008 */				struct	w32SPHAL_CMD_HASH_D2th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_HASH_datSize				 0x00008
	/* ---:--- */	#define	    bSPHAL_CMD_HASH_datSize				   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_HASH_datSize				    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_HASH_datSize				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_HASH_datSize(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_HASH_datSize(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_HASH_datSize(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_HASH_datSize(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_HASH_D3th_ 	ISC_USE_ONLY	0x0000C
	#define	w32SPHAL_CMD_HASH_D3th_ 	{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'0000C */				struct	w32SPHAL_CMD_HASH_D3th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_HASH_datSrcAddr			 0x0000C
	/* ---:--- */	#define	    bSPHAL_CMD_HASH_datSrcAddr			   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_HASH_datSrcAddr			    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_HASH_datSrcAddr			       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_HASH_datSrcAddr(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_HASH_datSrcAddr(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_HASH_datSrcAddr(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_HASH_datSrcAddr(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_HASH_D4th_ 	ISC_USE_ONLY	0x00010
	#define	w32SPHAL_CMD_HASH_D4th_ 	{										\
					UNSG32				u_hashValueAddr				 : 32;		\
										}
	/* @'00010 */				struct	w32SPHAL_CMD_HASH_D4th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_HASH_hashValueAddr		 0x00010
	/* ---:--- */	#define	    bSPHAL_CMD_HASH_hashValueAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_HASH_hashValueAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_HASH_hashValueAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_HASH_hashValueAddr(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_HASH_hashValueAddr(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_HASH_hashValueAddr(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_HASH_hashValueAddr(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_HASH_D5th_ 	ISC_USE_ONLY	0x00014
	#define	w32SPHAL_CMD_HASH_D5th_ 	{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00014 */				struct	w32SPHAL_CMD_HASH_D5th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_HASH_reserved			 0x00014
	/* ---:--- */	#define	    bSPHAL_CMD_HASH_reserved			   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_HASH_reserved			    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_HASH_reserved			       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_HASH_reserved(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_HASH_reserved(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_HASH_reserved(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_HASH_reserved(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_SPHAL_CMD_HASH;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SPHAL_CMD_HASH_drvrd (SIE_SPHAL_CMD_HASH *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SPHAL_CMD_HASH_drvwr (SIE_SPHAL_CMD_HASH *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SPHAL_CMD_HASH_reset (SIE_SPHAL_CMD_HASH *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SPHAL_CMD_HASH_check(p,pie,ps8name,hfpErrLOG)		SPHAL_CMD_HASH_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SPHAL_CMD_HASH_print(p,    ps8name,hfpErrLOG)		SPHAL_CMD_HASH_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SPHAL_CMD_HASH_cmp   (SIE_SPHAL_CMD_HASH *p, SIE_SPHAL_CMD_HASH *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SPHAL_CMD_HASH_import(SIE_SPHAL_CMD_HASH *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SPHAL_CMD_HASH_export(SIE_SPHAL_CMD_HASH *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SPHAL_CMD_HASH
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SPHAL_CMD_ENCDEC
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_AES128_ENC
*						*  DRMCMD_AES128_DEC
*						*  DRMCMD_DES_ENC
*						*  DRMCMD_DES_DEC
*						*  DRMCMD_3xDES_ENC
*						*  DRMCMD_3xDES_DEC
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  keyID  0
*						*  *
*						*  Key context ID
*						*  0
*	@
*		%unsigned  32  datSize  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  32  datDstAddr  0
*						*  *
*						*  DDR or SRAM address where the data is stored
*	@
*		%unsigned  32  reserved  0
**********************************************************************************************************************/
#ifdef	h_SPHAL_CMD_ENCDEC
#else
#define	h_SPHAL_CMD_ENCDEC

#define	\
	AR_SPHAL_CMD_ENCDEC \
		6
#define	\
	AB_SPHAL_CMD_ENCDEC \
		5

typedef struct SIE_SPHAL_CMD_ENCDEC {

	#define	RA_SPHAL_CMD_ENCDEC_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32SPHAL_CMD_ENCDEC_D0th_ 	{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32SPHAL_CMD_ENCDEC_D0th_;

	/* [ 7: 0] */	#define	  BA_SPHAL_CMD_ENCDEC_cmdCode			 0x00000
	/* ---:--- */	#define	    bSPHAL_CMD_ENCDEC_cmdCode			    8 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_ENCDEC_cmdCode			    0 /*: 7*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_ENCDEC_cmdCode			       0x000000FF
	/* ---:--- */	#define	GET32SPHAL_CMD_ENCDEC_cmdCode(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16SPHAL_CMD_ENCDEC_cmdCode(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32SPHAL_CMD_ENCDEC_cmdCode(r32,v)		do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_ENCDEC_cmdCode(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_SPHAL_CMD_ENCDEC_cmdID				 0x00001
	/* ---:--- */	#define	    bSPHAL_CMD_ENCDEC_cmdID				    8 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_ENCDEC_cmdID				    8 /*:15*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_ENCDEC_cmdID				       0x0000FF00
	/* ---:--- */	#define	GET32SPHAL_CMD_ENCDEC_cmdID(r32)			 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16SPHAL_CMD_ENCDEC_cmdID(r16)			 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32SPHAL_CMD_ENCDEC_cmdID(r32,v)			do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_ENCDEC_cmdID(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_SPHAL_CMD_ENCDEC_keyID 	0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_keyID;

	#define	RA_SPHAL_CMD_ENCDEC_D2th_ 	ISC_USE_ONLY	0x00008
	#define	w32SPHAL_CMD_ENCDEC_D2th_ 	{										\
					UNSG32				u_datSize					 : 32;		\
										}
	/* @'00008 */				struct	w32SPHAL_CMD_ENCDEC_D2th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_ENCDEC_datSize			 0x00008
	/* ---:--- */	#define	    bSPHAL_CMD_ENCDEC_datSize			   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_ENCDEC_datSize			    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_ENCDEC_datSize			       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_ENCDEC_datSize(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_ENCDEC_datSize(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_ENCDEC_datSize(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_ENCDEC_datSize(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_ENCDEC_D3th_ 	ISC_USE_ONLY	0x0000C
	#define	w32SPHAL_CMD_ENCDEC_D3th_ 	{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'0000C */				struct	w32SPHAL_CMD_ENCDEC_D3th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_ENCDEC_datSrcAddr		 0x0000C
	/* ---:--- */	#define	    bSPHAL_CMD_ENCDEC_datSrcAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_ENCDEC_datSrcAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_ENCDEC_datSrcAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_ENCDEC_datSrcAddr(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_ENCDEC_datSrcAddr(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_ENCDEC_datSrcAddr(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_ENCDEC_datSrcAddr(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_ENCDEC_D4th_ 	ISC_USE_ONLY	0x00010
	#define	w32SPHAL_CMD_ENCDEC_D4th_ 	{										\
					UNSG32				u_datDstAddr				 : 32;		\
										}
	/* @'00010 */				struct	w32SPHAL_CMD_ENCDEC_D4th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_ENCDEC_datDstAddr		 0x00010
	/* ---:--- */	#define	    bSPHAL_CMD_ENCDEC_datDstAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_ENCDEC_datDstAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_ENCDEC_datDstAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_ENCDEC_datDstAddr(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_ENCDEC_datDstAddr(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_ENCDEC_datDstAddr(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_ENCDEC_datDstAddr(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_ENCDEC_D5th_ 	ISC_USE_ONLY	0x00014
	#define	w32SPHAL_CMD_ENCDEC_D5th_ 	{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00014 */				struct	w32SPHAL_CMD_ENCDEC_D5th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_ENCDEC_reserved			 0x00014
	/* ---:--- */	#define	    bSPHAL_CMD_ENCDEC_reserved			   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_ENCDEC_reserved			    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_ENCDEC_reserved			       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_ENCDEC_reserved(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_ENCDEC_reserved(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_ENCDEC_reserved(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_ENCDEC_reserved(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_SPHAL_CMD_ENCDEC;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SPHAL_CMD_ENCDEC_drvrd (SIE_SPHAL_CMD_ENCDEC *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SPHAL_CMD_ENCDEC_drvwr (SIE_SPHAL_CMD_ENCDEC *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SPHAL_CMD_ENCDEC_reset (SIE_SPHAL_CMD_ENCDEC *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SPHAL_CMD_ENCDEC_check(p,pie,ps8name,hfpErrLOG)		SPHAL_CMD_ENCDEC_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SPHAL_CMD_ENCDEC_print(p,    ps8name,hfpErrLOG)		SPHAL_CMD_ENCDEC_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SPHAL_CMD_ENCDEC_cmp   (SIE_SPHAL_CMD_ENCDEC *p, SIE_SPHAL_CMD_ENCDEC *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SPHAL_CMD_ENCDEC_import(SIE_SPHAL_CMD_ENCDEC *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SPHAL_CMD_ENCDEC_export(SIE_SPHAL_CMD_ENCDEC *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SPHAL_CMD_ENCDEC
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SPHAL_CMD_RNG
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  keyID  0
*						*  *
*						*  Key context ID
*						*  0
*	@
*		%unsigned  32  datSize  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  32  pad  0
*						*  *
*	@
*		%unsigned  32  reserved  0
**********************************************************************************************************************/
#ifdef	h_SPHAL_CMD_RNG
#else
#define	h_SPHAL_CMD_RNG

#define	\
	AR_SPHAL_CMD_RNG \
		6
#define	\
	AB_SPHAL_CMD_RNG \
		5

typedef struct SIE_SPHAL_CMD_RNG {

	#define	RA_SPHAL_CMD_RNG_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32SPHAL_CMD_RNG_D0th_ 		{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32SPHAL_CMD_RNG_D0th_;

	/* [ 7: 0] */	#define	  BA_SPHAL_CMD_RNG_cmdCode				 0x00000
	/* ---:--- */	#define	    bSPHAL_CMD_RNG_cmdCode				    8 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RNG_cmdCode				    0 /*: 7*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RNG_cmdCode				       0x000000FF
	/* ---:--- */	#define	GET32SPHAL_CMD_RNG_cmdCode(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RNG_cmdCode(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RNG_cmdCode(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RNG_cmdCode(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_SPHAL_CMD_RNG_cmdID				 0x00001
	/* ---:--- */	#define	    bSPHAL_CMD_RNG_cmdID				    8 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RNG_cmdID				    8 /*:15*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RNG_cmdID				       0x0000FF00
	/* ---:--- */	#define	GET32SPHAL_CMD_RNG_cmdID(r32)				 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RNG_cmdID(r16)				 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RNG_cmdID(r32,v)				do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RNG_cmdID(r16,v)				do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_SPHAL_CMD_RNG_keyID 		0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_keyID;

	#define	RA_SPHAL_CMD_RNG_D2th_ 		ISC_USE_ONLY	0x00008
	#define	w32SPHAL_CMD_RNG_D2th_ 		{										\
					UNSG32				u_datSize					 : 32;		\
										}
	/* @'00008 */				struct	w32SPHAL_CMD_RNG_D2th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_RNG_datSize				 0x00008
	/* ---:--- */	#define	    bSPHAL_CMD_RNG_datSize				   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RNG_datSize				    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RNG_datSize				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_RNG_datSize(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RNG_datSize(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RNG_datSize(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RNG_datSize(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_RNG_D3th_ 		ISC_USE_ONLY	0x0000C
	#define	w32SPHAL_CMD_RNG_D3th_ 		{										\
					UNSG32				u_datAddr					 : 32;		\
										}
	/* @'0000C */				struct	w32SPHAL_CMD_RNG_D3th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_RNG_datAddr				 0x0000C
	/* ---:--- */	#define	    bSPHAL_CMD_RNG_datAddr				   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RNG_datAddr				    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RNG_datAddr				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_RNG_datAddr(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RNG_datAddr(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RNG_datAddr(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RNG_datAddr(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_RNG_D4th_ 		ISC_USE_ONLY	0x00010
	#define	w32SPHAL_CMD_RNG_D4th_ 		{										\
					UNSG32				u_pad						 : 32;		\
										}
	/* @'00010 */				struct	w32SPHAL_CMD_RNG_D4th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_RNG_pad					 0x00010
	/* ---:--- */	#define	    bSPHAL_CMD_RNG_pad					   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RNG_pad					    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RNG_pad					       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_RNG_pad(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RNG_pad(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RNG_pad(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RNG_pad(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_RNG_D5th_ 		ISC_USE_ONLY	0x00014
	#define	w32SPHAL_CMD_RNG_D5th_ 		{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00014 */				struct	w32SPHAL_CMD_RNG_D5th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_RNG_reserved				 0x00014
	/* ---:--- */	#define	    bSPHAL_CMD_RNG_reserved				   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RNG_reserved				    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RNG_reserved				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_RNG_reserved(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RNG_reserved(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RNG_reserved(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RNG_reserved(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_SPHAL_CMD_RNG;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SPHAL_CMD_RNG_drvrd (SIE_SPHAL_CMD_RNG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SPHAL_CMD_RNG_drvwr (SIE_SPHAL_CMD_RNG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SPHAL_CMD_RNG_reset (SIE_SPHAL_CMD_RNG *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SPHAL_CMD_RNG_check(p,pie,ps8name,hfpErrLOG)		SPHAL_CMD_RNG_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SPHAL_CMD_RNG_print(p,    ps8name,hfpErrLOG)		SPHAL_CMD_RNG_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SPHAL_CMD_RNG_cmp   (SIE_SPHAL_CMD_RNG *p, SIE_SPHAL_CMD_RNG *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SPHAL_CMD_RNG_import(SIE_SPHAL_CMD_RNG *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SPHAL_CMD_RNG_export(SIE_SPHAL_CMD_RNG *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SPHAL_CMD_RNG
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SPHAL_CMD_RC4
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_SHA1_START
*						*  DRMCMD_SHA1_UPDATE
*						*  DRMCMD_SHA1_END.
*						*  DRMCMD_HMAC_START
*						*  DRMCMD_HMAC_UPDATE
*						*  DRMCMD_HMAC_END
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  keyID  0
*						*  *
*						*  Hash conetxt ID
*						*  0
*	@
*		%unsigned  32  datSize  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  32  datDstAddr  0
*						*  *
*						*  Key context ID
*	@
*		%unsigned  32  keyLen  0
*						*  *
*						*  RC4 Key length
**********************************************************************************************************************/
#ifdef	h_SPHAL_CMD_RC4
#else
#define	h_SPHAL_CMD_RC4

#define	\
	AR_SPHAL_CMD_RC4 \
		6
#define	\
	AB_SPHAL_CMD_RC4 \
		5

typedef struct SIE_SPHAL_CMD_RC4 {

	#define	RA_SPHAL_CMD_RC4_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32SPHAL_CMD_RC4_D0th_ 		{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32SPHAL_CMD_RC4_D0th_;

	/* [ 7: 0] */	#define	  BA_SPHAL_CMD_RC4_cmdCode				 0x00000
	/* ---:--- */	#define	    bSPHAL_CMD_RC4_cmdCode				    8 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RC4_cmdCode				    0 /*: 7*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RC4_cmdCode				       0x000000FF
	/* ---:--- */	#define	GET32SPHAL_CMD_RC4_cmdCode(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RC4_cmdCode(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RC4_cmdCode(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RC4_cmdCode(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_SPHAL_CMD_RC4_cmdID				 0x00001
	/* ---:--- */	#define	    bSPHAL_CMD_RC4_cmdID				    8 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RC4_cmdID				    8 /*:15*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RC4_cmdID				       0x0000FF00
	/* ---:--- */	#define	GET32SPHAL_CMD_RC4_cmdID(r32)				 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RC4_cmdID(r16)				 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RC4_cmdID(r32,v)				do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RC4_cmdID(r16,v)				do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_SPHAL_CMD_RC4_keyID 		0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_keyID;

	#define	RA_SPHAL_CMD_RC4_D2th_ 		ISC_USE_ONLY	0x00008
	#define	w32SPHAL_CMD_RC4_D2th_ 		{										\
					UNSG32				u_datSize					 : 32;		\
										}
	/* @'00008 */				struct	w32SPHAL_CMD_RC4_D2th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_RC4_datSize				 0x00008
	/* ---:--- */	#define	    bSPHAL_CMD_RC4_datSize				   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RC4_datSize				    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RC4_datSize				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_RC4_datSize(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RC4_datSize(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RC4_datSize(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RC4_datSize(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_RC4_D3th_ 		ISC_USE_ONLY	0x0000C
	#define	w32SPHAL_CMD_RC4_D3th_ 		{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'0000C */				struct	w32SPHAL_CMD_RC4_D3th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_RC4_datSrcAddr			 0x0000C
	/* ---:--- */	#define	    bSPHAL_CMD_RC4_datSrcAddr			   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RC4_datSrcAddr			    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RC4_datSrcAddr			       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_RC4_datSrcAddr(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RC4_datSrcAddr(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RC4_datSrcAddr(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RC4_datSrcAddr(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_RC4_D4th_ 		ISC_USE_ONLY	0x00010
	#define	w32SPHAL_CMD_RC4_D4th_ 		{										\
					UNSG32				u_datDstAddr				 : 32;		\
										}
	/* @'00010 */				struct	w32SPHAL_CMD_RC4_D4th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_RC4_datDstAddr			 0x00010
	/* ---:--- */	#define	    bSPHAL_CMD_RC4_datDstAddr			   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RC4_datDstAddr			    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RC4_datDstAddr			       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_RC4_datDstAddr(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RC4_datDstAddr(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RC4_datDstAddr(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RC4_datDstAddr(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SPHAL_CMD_RC4_D5th_ 		ISC_USE_ONLY	0x00014
	#define	w32SPHAL_CMD_RC4_D5th_ 		{										\
					UNSG32				u_keyLen					 : 32;		\
										}
	/* @'00014 */				struct	w32SPHAL_CMD_RC4_D5th_;

	/* [31: 0] */	#define	  BA_SPHAL_CMD_RC4_keyLen				 0x00014
	/* ---:--- */	#define	    bSPHAL_CMD_RC4_keyLen				   32 /*bit*/
	/* ---:--- */	#define	LSb32SPHAL_CMD_RC4_keyLen				    0 /*:31*/
	/* ---:--- */	#define	MSK32SPHAL_CMD_RC4_keyLen				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SPHAL_CMD_RC4_keyLen(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SPHAL_CMD_RC4_keyLen(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SPHAL_CMD_RC4_keyLen(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SPHAL_CMD_RC4_keyLen(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_SPHAL_CMD_RC4;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SPHAL_CMD_RC4_drvrd (SIE_SPHAL_CMD_RC4 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SPHAL_CMD_RC4_drvwr (SIE_SPHAL_CMD_RC4 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SPHAL_CMD_RC4_reset (SIE_SPHAL_CMD_RC4 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SPHAL_CMD_RC4_check(p,pie,ps8name,hfpErrLOG)		SPHAL_CMD_RC4_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SPHAL_CMD_RC4_print(p,    ps8name,hfpErrLOG)		SPHAL_CMD_RC4_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SPHAL_CMD_RC4_cmp   (SIE_SPHAL_CMD_RC4 *p, SIE_SPHAL_CMD_RC4 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SPHAL_CMD_RC4_import(SIE_SPHAL_CMD_RC4 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SPHAL_CMD_RC4_export(SIE_SPHAL_CMD_RC4 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SPHAL_CMD_RC4
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: OTP_INFO_CTX
*	@
*		$UINT64  rkekCRC
*						*  *
*						*  Row 35
*		$UINT64  bindInfo
*						*  *
*						*  Row 36
*	@
*		$UINT64  userInfo0
*						*  *
*						*  Row 37
*	@
*		$UINT64  userInfo1
*						*  *
*						*  Row 38
*	@
*		$UINT64  serialId
*						*  *
*						*  Row 39
*	@
*		$UINT64  userInfo2
*						*  *
*						*  Row 3
*	@
*		$UINT64  userInfo3
*						*  *
*						*  Row 31 (byte 2 to byte 7)
**********************************************************************************************************************/
#ifdef	h_OTP_INFO_CTX
#else
#define	h_OTP_INFO_CTX

#define	\
	AR_OTP_INFO_CTX \
		14
#define	\
	AB_OTP_INFO_CTX \
		6

typedef struct SIE_OTP_INFO_CTX {

	#define	RA_OTP_INFO_CTX_rkekCRC 	0x00000
	/* @'00000 */	SIE_UINT64 					ie_rkekCRC;

	#define	RA_OTP_INFO_CTX_bindInfo 	0x00008
	/* @'00008 */	SIE_UINT64 					ie_bindInfo;

	#define	RA_OTP_INFO_CTX_userInfo0 	0x00010
	/* @'00010 */	SIE_UINT64 					ie_userInfo0;

	#define	RA_OTP_INFO_CTX_userInfo1 	0x00018
	/* @'00018 */	SIE_UINT64 					ie_userInfo1;

	#define	RA_OTP_INFO_CTX_serialId 	0x00020
	/* @'00020 */	SIE_UINT64 					ie_serialId;

	#define	RA_OTP_INFO_CTX_userInfo2 	0x00028
	/* @'00028 */	SIE_UINT64 					ie_userInfo2;

	#define	RA_OTP_INFO_CTX_userInfo3 	0x00030
	/* @'00030 */	SIE_UINT64 					ie_userInfo3;

} SIE_OTP_INFO_CTX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	OTP_INFO_CTX_drvrd (SIE_OTP_INFO_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	OTP_INFO_CTX_drvwr (SIE_OTP_INFO_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	OTP_INFO_CTX_reset (SIE_OTP_INFO_CTX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	OTP_INFO_CTX_check(p,pie,ps8name,hfpErrLOG)		OTP_INFO_CTX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	OTP_INFO_CTX_print(p,    ps8name,hfpErrLOG)		OTP_INFO_CTX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	OTP_INFO_CTX_cmp   (SIE_OTP_INFO_CTX *p, SIE_OTP_INFO_CTX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	OTP_INFO_CTX_import(SIE_OTP_INFO_CTX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	OTP_INFO_CTX_export(SIE_OTP_INFO_CTX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: OTP_INFO_CTX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CRYPTO_ENGINE_CTX
*	@
*		%unsigned  16  engineState
*						*  *
*						*  State of Crypto Engine
*						*  00: Engine is idle
*						*  01: Cmd is ready
*		%unsigned  16  padding
*		%unsigned  8  engineType
*		%unsigned  8  mode
*		%unsigned  8  isKeyReady
*						*  *
*						*  0: key is not ready
*						*  1: key data is ready
*						*  2: use internal key, keyId used as index
*		%unsigned  8  keyId
*	@
*		$UINT64  cmdBuf  REG  [3]
*	@
*		$UINT64  keyDat  REG  [4]
*	@
*		$SHA1_CTXDAT  shaCtx
*	@
*		$RC4_CTXDAT  rc4Ctx
*	@
*		$UINT64  IV  REG  [2]
*	@
*		$UINT64  pRndKey  REG  [32]
*	@
*		$UINT64  pRootKey  REG  [4]
**********************************************************************************************************************/
#ifdef	h_CRYPTO_ENGINE_CTX
#else
#define	h_CRYPTO_ENGINE_CTX

#define	\
	AR_CRYPTO_ENGINE_CTX \
		246
#define	\
	AB_CRYPTO_ENGINE_CTX \
		10

typedef struct SIE_CRYPTO_ENGINE_CTX {

	#define	RA_CRYPTO_ENGINE_CTX_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32CRYPTO_ENGINE_CTX_D0th_ 	{										\
					UNSG32				u_engineState				 : 16;		\
					UNSG32				u_padding					 : 16;		\
										}
	/* @'00000 */				struct	w32CRYPTO_ENGINE_CTX_D0th_;

	/* [15: 0] */	#define	  BA_CRYPTO_ENGINE_CTX_engineState		 0x00000
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CTX_engineState		   16 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CTX_engineState		    0 /*:15*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CTX_engineState		       0x0000FFFF
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CTX_engineState(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CTX_engineState(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CTX_engineState(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CTX_engineState(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_CRYPTO_ENGINE_CTX_padding			 0x00002
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CTX_padding			   16 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CTX_padding			   16 /*:31*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CTX_padding			       0xFFFF0000
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CTX_padding(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CTX_padding(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CTX_padding(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CTX_padding(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_CRYPTO_ENGINE_CTX_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32CRYPTO_ENGINE_CTX_D1th_ 	{										\
					UNSG32				u_engineType				 :  8;		\
					UNSG32				u_mode						 :  8;		\
					UNSG32				u_isKeyReady				 :  8;		\
					UNSG32				u_keyId						 :  8;		\
										}
	/* @'00004 */				struct	w32CRYPTO_ENGINE_CTX_D1th_;

	/* [ 7: 0] */	#define	  BA_CRYPTO_ENGINE_CTX_engineType		 0x00004
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CTX_engineType		    8 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CTX_engineType		    0 /*: 7*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CTX_engineType		       0x000000FF
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CTX_engineType(r32)		 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CTX_engineType(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CTX_engineType(r32,v)	do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CTX_engineType(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_CRYPTO_ENGINE_CTX_mode				 0x00005
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CTX_mode				    8 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CTX_mode				    8 /*:15*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CTX_mode				       0x0000FF00
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CTX_mode(r32)			 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CTX_mode(r16)			 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CTX_mode(r32,v)			do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CTX_mode(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	/* [23:16] */	#define	  BA_CRYPTO_ENGINE_CTX_isKeyReady		 0x00006
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CTX_isKeyReady		    8 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CTX_isKeyReady		   16 /*:23*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CTX_isKeyReady		       0x00FF0000
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CTX_isKeyReady(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CTX_isKeyReady(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CTX_isKeyReady(r32,v)	do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CTX_isKeyReady(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31:24] */	#define	  BA_CRYPTO_ENGINE_CTX_keyId			 0x00007
	/* ---:--- */	#define	    bCRYPTO_ENGINE_CTX_keyId			    8 /*bit*/
	/* ---:--- */	#define	LSb32CRYPTO_ENGINE_CTX_keyId			   24 /*:31*/
	/* ---:--- */	#define	MSK32CRYPTO_ENGINE_CTX_keyId			       0xFF000000
	/* ---:--- */	#define	GET32CRYPTO_ENGINE_CTX_keyId(r32)			 (((r32)>>24)&0x00FF)
	/* ---:--- */	#define	GET16CRYPTO_ENGINE_CTX_keyId(r16)			 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32CRYPTO_ENGINE_CTX_keyId(r32,v)			do{(r32)&=~(0x00FF<<24);(r32)|=((v)&0x00FF)<<24;}while(0)
	/* ---:--- */	#define	SET16CRYPTO_ENGINE_CTX_keyId(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_CRYPTO_ENGINE_CTX_cmdBuf 0x00008
	/* @'00008 */	SIE_UINT64 					ie_cmdBuf			 [3];
					#define	 arr_CRYPTO_ENGINE_CTX_cmdBuf 			  3

	#define	RA_CRYPTO_ENGINE_CTX_keyDat 0x00020
	/* @'00020 */	SIE_UINT64 					ie_keyDat			 [4];
					#define	 arr_CRYPTO_ENGINE_CTX_keyDat 			  4

	#define	RA_CRYPTO_ENGINE_CTX_shaCtx 0x00040
	/* @'00040 */	SIE_SHA1_CTXDAT 			ie_shaCtx;

	#define	RA_CRYPTO_ENGINE_CTX_rc4Ctx 0x000A0
	/* @'000A0 */	SIE_RC4_CTXDAT 				ie_rc4Ctx;

	#define	RA_CRYPTO_ENGINE_CTX_IV 	0x002A8
	/* @'002A8 */	SIE_UINT64 					ie_IV				 [2];
					#define	 arr_CRYPTO_ENGINE_CTX_IV 				  2

	#define	RA_CRYPTO_ENGINE_CTX_pRndKey 0x002B8
	/* @'002B8 */	SIE_UINT64 					ie_pRndKey			 [32];
					#define	 arr_CRYPTO_ENGINE_CTX_pRndKey 			  32

	#define	RA_CRYPTO_ENGINE_CTX_pRootKey 0x003B8
	/* @'003B8 */	SIE_UINT64 					ie_pRootKey			 [4];
					#define	 arr_CRYPTO_ENGINE_CTX_pRootKey 		  4

} SIE_CRYPTO_ENGINE_CTX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CRYPTO_ENGINE_CTX_drvrd (SIE_CRYPTO_ENGINE_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CRYPTO_ENGINE_CTX_drvwr (SIE_CRYPTO_ENGINE_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CRYPTO_ENGINE_CTX_reset (SIE_CRYPTO_ENGINE_CTX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CRYPTO_ENGINE_CTX_check(p,pie,ps8name,hfpErrLOG)		CRYPTO_ENGINE_CTX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CRYPTO_ENGINE_CTX_print(p,    ps8name,hfpErrLOG)		CRYPTO_ENGINE_CTX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CRYPTO_ENGINE_CTX_cmp   (SIE_CRYPTO_ENGINE_CTX *p, SIE_CRYPTO_ENGINE_CTX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CRYPTO_ENGINE_CTX_import(SIE_CRYPTO_ENGINE_CTX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CRYPTO_ENGINE_CTX_export(SIE_CRYPTO_ENGINE_CTX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CRYPTO_ENGINE_CTX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMDiagCryptoEngineCtx
*	@
*		$DRMROM_CMD  cmd
*						*  *
*						*  ROM code command and response buffer
*	@  LA_START
*		$LocalArea  la
*						*  *
*						*  Local data area
*	@
*		$UINT64  dsCmdFifo  REG  [16]
*						*  *
*						*  Data streamer fifo data
*	@  0x1000
*		$CRYPTO_ENGINE_CTX  engineCtx
*						*  *
*	@
*		$UINT64  datBuf  REG  [256]
*	@  DTCMSIZE
*		$UINT64  uTotalSize  REG
*	@  IMG_END
*		$UINT128  resserved  REG
**********************************************************************************************************************/
#ifdef	h_DRMDiagCryptoEngineCtx
#else
#define	h_DRMDiagCryptoEngineCtx

#define	\
	AR_DRMDiagCryptoEngineCtx \
		1788
#define	\
	AB_DRMDiagCryptoEngineCtx \
		13

typedef struct SIE_DRMDiagCryptoEngineCtx {

	#define	RA_DRMDiagCryptoEngineCtx_cmd 0x00000
	/* @'00000 */	SIE_DRMROM_CMD 				ie_cmd;

	#define	RA_DRMDiagCryptoEngineCtx_LA_START 0x00028
	/* @'00028 */	SIE_LocalArea 				ie_la;

	#define	RA_DRMDiagCryptoEngineCtx_dsCmdFifo 0x00250
	/* @'00250 */	SIE_UINT64 					ie_dsCmdFifo		 [16];
					#define	 arr_DRMDiagCryptoEngineCtx_dsCmdFifo 	  16

	UNSG32	_PAD_000[(0x01000-0x002D0)/4];
	#define	RA_DRMDiagCryptoEngineCtx_engineCtx 0x01000
	/* @'01000 */	SIE_CRYPTO_ENGINE_CTX 		ie_engineCtx;

	#define	RA_DRMDiagCryptoEngineCtx_datBuf 0x013D8
	/* @'013D8 */	SIE_UINT64 					ie_datBuf			 [256];
					#define	 arr_DRMDiagCryptoEngineCtx_datBuf 		  256

	#define	RA_DRMDiagCryptoEngineCtx_DTCMSIZE 0x01BD8
	/* @'01BD8 */	SIE_UINT64 					ie_uTotalSize;

	#define	RA_DRMDiagCryptoEngineCtx_IMG_END 0x01BE0
	/* @'01BE0 */	SIE_UINT128 				ie_resserved;

} SIE_DRMDiagCryptoEngineCtx;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMDiagCryptoEngineCtx_drvrd (SIE_DRMDiagCryptoEngineCtx *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMDiagCryptoEngineCtx_drvwr (SIE_DRMDiagCryptoEngineCtx *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMDiagCryptoEngineCtx_reset (SIE_DRMDiagCryptoEngineCtx *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMDiagCryptoEngineCtx_check(p,pie,ps8name,hfpErrLOG)		DRMDiagCryptoEngineCtx_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMDiagCryptoEngineCtx_print(p,    ps8name,hfpErrLOG)		DRMDiagCryptoEngineCtx_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMDiagCryptoEngineCtx_cmp   (SIE_DRMDiagCryptoEngineCtx *p, SIE_DRMDiagCryptoEngineCtx *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMDiagCryptoEngineCtx_import(SIE_DRMDiagCryptoEngineCtx *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMDiagCryptoEngineCtx_export(SIE_DRMDiagCryptoEngineCtx *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMDiagCryptoEngineCtx
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMCONST
*	@
*			:  BD_PACKET_SIZE  6144
*						*  *
*						*  Blu-ray DVD packet size
*	@
*			:  BD_TSPACKET_SIZE  192
*						*  *
*						*  Blu-ray DVD packet size
*			:  BD_BE_PACK_SIZE  2048
*						*  *
*						*  Bus encrytion block size
*	@
*		%unsigned  32  dummy
*						*  *
**********************************************************************************************************************/
#ifdef	h_DRMCONST
#else
#define	h_DRMCONST

#define	\
	AR_DRMCONST \
		1
#define	\
	AB_DRMCONST \
		2

	#define	DRMCONST_BD_PACKET_SIZE 	0x1800
	#define	DRMCONST_BD_TSPACKET_SIZE 	0xC0
	#define	DRMCONST_BD_BE_PACK_SIZE 	0x800

typedef struct SIE_DRMCONST {

	#define	RA_DRMCONST_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32DRMCONST_D0th_ 			{										\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32DRMCONST_D0th_;

	/* [31: 0] */	#define	  BA_DRMCONST_dummy						 0x00000
	/* ---:--- */	#define	    bDRMCONST_dummy						   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCONST_dummy						    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCONST_dummy						       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCONST_dummy(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCONST_dummy(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCONST_dummy(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCONST_dummy(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMCONST;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMCONST_drvrd (SIE_DRMCONST *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMCONST_drvwr (SIE_DRMCONST *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMCONST_reset (SIE_DRMCONST *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMCONST_check(p,pie,ps8name,hfpErrLOG)		DRMCONST_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMCONST_print(p,    ps8name,hfpErrLOG)		DRMCONST_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMCONST_cmp   (SIE_DRMCONST *p, SIE_DRMCONST *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMCONST_import(SIE_DRMCONST *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMCONST_export(SIE_DRMCONST *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMCONST
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: WrapperTK
*	@
*		$UINT64  TKHeader
*	@
*		$UINT64  tk  REG  [3]
**********************************************************************************************************************/
#ifdef	h_WrapperTK
#else
#define	h_WrapperTK

#define	\
	AR_WrapperTK \
		8
#define	\
	AB_WrapperTK \
		5

typedef struct SIE_WrapperTK {

	#define	RA_WrapperTK_TKHeader 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_TKHeader;

	#define	RA_WrapperTK_tk 			0x00008
	/* @'00008 */	SIE_UINT64 					ie_tk				 [3];
					#define	 arr_WrapperTK_tk 						  3

} SIE_WrapperTK;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	WrapperTK_drvrd (SIE_WrapperTK *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	WrapperTK_drvwr (SIE_WrapperTK *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	WrapperTK_reset (SIE_WrapperTK *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	WrapperTK_check(p,pie,ps8name,hfpErrLOG)		WrapperTK_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	WrapperTK_print(p,    ps8name,hfpErrLOG)		WrapperTK_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	WrapperTK_cmp   (SIE_WrapperTK *p, SIE_WrapperTK *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	WrapperTK_import(SIE_WrapperTK *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	WrapperTK_export(SIE_WrapperTK *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: WrapperTK
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: FIGOCTRLUpdateTK
*	@
*		$FIGOCtrl  figoCtrl
*	@
*		$UINT128  tk  REG  [2]
**********************************************************************************************************************/
#ifdef	h_FIGOCTRLUpdateTK
#else
#define	h_FIGOCTRLUpdateTK

#define	\
	AR_FIGOCTRLUpdateTK \
		10
#define	\
	AB_FIGOCTRLUpdateTK \
		6

typedef struct SIE_FIGOCTRLUpdateTK {

	#define	RA_FIGOCTRLUpdateTK_figoCtrl 0x00000
	/* @'00000 */	SIE_FIGOCtrl 				ie_figoCtrl;

	#define	RA_FIGOCTRLUpdateTK_tk 		0x00008
	/* @'00008 */	SIE_UINT128 				ie_tk				 [2];
					#define	 arr_FIGOCTRLUpdateTK_tk 				  2

} SIE_FIGOCTRLUpdateTK;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	FIGOCTRLUpdateTK_drvrd (SIE_FIGOCTRLUpdateTK *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	FIGOCTRLUpdateTK_drvwr (SIE_FIGOCTRLUpdateTK *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	FIGOCTRLUpdateTK_reset (SIE_FIGOCTRLUpdateTK *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	FIGOCTRLUpdateTK_check(p,pie,ps8name,hfpErrLOG)		FIGOCTRLUpdateTK_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	FIGOCTRLUpdateTK_print(p,    ps8name,hfpErrLOG)		FIGOCTRLUpdateTK_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	FIGOCTRLUpdateTK_cmp   (SIE_FIGOCTRLUpdateTK *p, SIE_FIGOCTRLUpdateTK *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	FIGOCTRLUpdateTK_import(SIE_FIGOCTRLUpdateTK *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	FIGOCTRLUpdateTK_export(SIE_FIGOCTRLUpdateTK *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: FIGOCTRLUpdateTK
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: FIGOCTRLUpdateBK
*	@
*		$FIGOCtrl  figoCtrl
*	@
*		$UINT64  bk  REG  [3]
**********************************************************************************************************************/
#ifdef	h_FIGOCTRLUpdateBK
#else
#define	h_FIGOCTRLUpdateBK

#define	\
	AR_FIGOCTRLUpdateBK \
		8
#define	\
	AB_FIGOCTRLUpdateBK \
		5

typedef struct SIE_FIGOCTRLUpdateBK {

	#define	RA_FIGOCTRLUpdateBK_figoCtrl 0x00000
	/* @'00000 */	SIE_FIGOCtrl 				ie_figoCtrl;

	#define	RA_FIGOCTRLUpdateBK_bk 		0x00008
	/* @'00008 */	SIE_UINT64 					ie_bk				 [3];
					#define	 arr_FIGOCTRLUpdateBK_bk 				  3

} SIE_FIGOCTRLUpdateBK;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	FIGOCTRLUpdateBK_drvrd (SIE_FIGOCTRLUpdateBK *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	FIGOCTRLUpdateBK_drvwr (SIE_FIGOCTRLUpdateBK *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	FIGOCTRLUpdateBK_reset (SIE_FIGOCTRLUpdateBK *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	FIGOCTRLUpdateBK_check(p,pie,ps8name,hfpErrLOG)		FIGOCTRLUpdateBK_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	FIGOCTRLUpdateBK_print(p,    ps8name,hfpErrLOG)		FIGOCTRLUpdateBK_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	FIGOCTRLUpdateBK_cmp   (SIE_FIGOCTRLUpdateBK *p, SIE_FIGOCTRLUpdateBK *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	FIGOCTRLUpdateBK_import(SIE_FIGOCTRLUpdateBK *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	FIGOCTRLUpdateBK_export(SIE_FIGOCTRLUpdateBK *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: FIGOCTRLUpdateBK
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: KeySeed
*	@
*		%unsigned  32  syncPoint
*		%unsigned  32  reserved
*	@
*		$UINT64  ksDat
**********************************************************************************************************************/
#ifdef	h_KeySeed
#else
#define	h_KeySeed

#define	\
	AR_KeySeed \
		4
#define	\
	AB_KeySeed \
		4

typedef struct SIE_KeySeed {

	#define	RA_KeySeed_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32KeySeed_D0th_ 			{										\
					UNSG32				u_syncPoint					 : 32;		\
										}
	/* @'00000 */				struct	w32KeySeed_D0th_;

	/* [31: 0] */	#define	  BA_KeySeed_syncPoint					 0x00000
	/* ---:--- */	#define	    bKeySeed_syncPoint					   32 /*bit*/
	/* ---:--- */	#define	LSb32KeySeed_syncPoint					    0 /*:31*/
	/* ---:--- */	#define	MSK32KeySeed_syncPoint					       0xFFFFFFFF
	/* ---:--- */	#define	GET32KeySeed_syncPoint(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16KeySeed_syncPoint(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32KeySeed_syncPoint(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16KeySeed_syncPoint(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_KeySeed_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32KeySeed_D1th_ 			{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00004 */				struct	w32KeySeed_D1th_;

	/* [31: 0] */	#define	  BA_KeySeed_reserved					 0x00004
	/* ---:--- */	#define	    bKeySeed_reserved					   32 /*bit*/
	/* ---:--- */	#define	LSb32KeySeed_reserved					    0 /*:31*/
	/* ---:--- */	#define	MSK32KeySeed_reserved					       0xFFFFFFFF
	/* ---:--- */	#define	GET32KeySeed_reserved(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16KeySeed_reserved(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32KeySeed_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16KeySeed_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_KeySeed_ksDat 			0x00008
	/* @'00008 */	SIE_UINT64 					ie_ksDat;

} SIE_KeySeed;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	KeySeed_drvrd (SIE_KeySeed *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	KeySeed_drvwr (SIE_KeySeed *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	KeySeed_reset (SIE_KeySeed *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	KeySeed_check(p,pie,ps8name,hfpErrLOG)		KeySeed_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	KeySeed_print(p,    ps8name,hfpErrLOG)		KeySeed_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	KeySeed_cmp   (SIE_KeySeed *p, SIE_KeySeed *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	KeySeed_import(SIE_KeySeed *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	KeySeed_export(SIE_KeySeed *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: KeySeed
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: BusKeyCtx
*	@
*		%unsigned  16  uRndKeyReady
*						*  *
*						*  Flag to indicate whether the round key ready
*	@
*		%unsigned  16  reserved
*	@
*		$UINT64  32  busReserved
*	@
*		$UINT128  rndKey  REG  [11]
*						*  *
*						*  Round key for Bus encryption key
**********************************************************************************************************************/
#ifdef	h_BusKeyCtx
#else
#define	h_BusKeyCtx

#define	\
	AR_BusKeyCtx \
		48
#define	\
	AB_BusKeyCtx \
		8

typedef struct SIE_BusKeyCtx {

	#define	RA_BusKeyCtx_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32BusKeyCtx_D0th_ 			{										\
					UNSG32				u_uRndKeyReady				 : 16;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32BusKeyCtx_D0th_;

	/* [15: 0] */	#define	  BA_BusKeyCtx_uRndKeyReady				 0x00000
	/* ---:--- */	#define	    bBusKeyCtx_uRndKeyReady				   16 /*bit*/
	/* ---:--- */	#define	LSb32BusKeyCtx_uRndKeyReady				    0 /*:15*/
	/* ---:--- */	#define	MSK32BusKeyCtx_uRndKeyReady				       0x0000FFFF
	/* ---:--- */	#define	GET32BusKeyCtx_uRndKeyReady(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16BusKeyCtx_uRndKeyReady(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BusKeyCtx_uRndKeyReady(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BusKeyCtx_uRndKeyReady(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_BusKeyCtx_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32BusKeyCtx_D1th_ 			{										\
					UNSG32				u_reserved					 : 16;		\
					UNSG32				_x00004	: 16;							\
										}
	/* @'00004 */				struct	w32BusKeyCtx_D1th_;

	/* [15: 0] */	#define	  BA_BusKeyCtx_reserved					 0x00004
	/* ---:--- */	#define	    bBusKeyCtx_reserved					   16 /*bit*/
	/* ---:--- */	#define	LSb32BusKeyCtx_reserved					    0 /*:15*/
	/* ---:--- */	#define	MSK32BusKeyCtx_reserved					       0x0000FFFF
	/* ---:--- */	#define	GET32BusKeyCtx_reserved(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16BusKeyCtx_reserved(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BusKeyCtx_reserved(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BusKeyCtx_reserved(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_BusKeyCtx_32 			0x00008
	/* @'00008 */	SIE_UINT64 					ie_32;

	#define	RA_BusKeyCtx_rndKey 		0x00010
	/* @'00010 */	SIE_UINT128 				ie_rndKey			 [11];
					#define	 arr_BusKeyCtx_rndKey 					  11

} SIE_BusKeyCtx;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	BusKeyCtx_drvrd (SIE_BusKeyCtx *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	BusKeyCtx_drvwr (SIE_BusKeyCtx *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	BusKeyCtx_reset (SIE_BusKeyCtx *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	BusKeyCtx_check(p,pie,ps8name,hfpErrLOG)		BusKeyCtx_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	BusKeyCtx_print(p,    ps8name,hfpErrLOG)		BusKeyCtx_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	BusKeyCtx_cmp   (SIE_BusKeyCtx *p, SIE_BusKeyCtx *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	BusKeyCtx_import(SIE_BusKeyCtx *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	BusKeyCtx_export(SIE_BusKeyCtx *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: BusKeyCtx
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMBDFilter
*	@  HDR
*		%unsigned  16  filterFunc
*		%unsigned  8  filterState
*			:  INACTIVE  0
*			:  STOPPED  1
*			:  STOPPING  2
*			:  RUNNING  3
*			:  FLUSHING  4
*			:  PAUSING  5
*			:  PAUSED  6
*		%unsigned  1  isByPassMode
*		%unsigned  1  isEncrypted
*		%unsigned  1  isBusEncOn
*	@  IO
*		%unsigned  16  strmInPtr
*						*  *
*						*  Address of the input data FIFO pointer
*						*  *
*						*  Size to read next time
*		%unsigned  16  strmOutPtr
*						*  *
*						*  Address of the output data FIFO pointer
*	@
*		%unsigned  16  datBase
*						*  *
*						*  Internal data buffer
*		%unsigned  16  ctrlBase
*						*  *
*						*  Internal control buffer
*	@
*		%unsigned  16  datMaxSize
*						*  *
*						*  Size of the internal data buffer
*		%unsigned  16  ctrlMaxSize
*						*  *
*						*  Size of the internal control buffer
*	@
*		%unsigned  16  packStartOffset
*						*  *
*						*  Bytes left in the current BD packet
*		%unsigned  16  packSizeToRd
*	@  CTR
*		%unsigned  32  strmCtrIn
*						*  *
*						*  Input stream counter
*	@
*		$UINT128  tkIn  REG
*						*  *
*						*  Title Key plain text
*	@
*		$UINT128  rndKey  REG  [11]
*						*  *
*						*  Packet round keys
*	@
*		$UINT128  pbBEIV  MEM
*						*  *
*						*  Bus dncryption Packet Initial Vector
*	@
*		$UINT128  pbIV  MEM
*						*  *
*						*  Packet decryption Initial Vector
*	@
*		$UINT128  pbAACSConstIV  MEM
*						*  *
*						*  AACS Constant IV
*	@
*		%unsigned  16  beBlockCnt
*						*  *
*						*  Bus Encryption Block Counter
*		%unsigned  16  beReserved
*						*  *
*						*  Bus Encryption reserved area
*	@
*		%unsigned  16  busKeyCtxAddr
*						*  *
*						*  Bus encryption Key context address
*		%unsigned  16  BEpackSizeToRd
*						*  *
*						*  Bytes left in the Bus encryption block (2K bytes)
*	@  UINT64  uPadding
**********************************************************************************************************************/
#ifdef	h_DRMBDFilter
#else
#define	h_DRMBDFilter

#define	\
	AR_DRMBDFilter \
		72
#define	\
	AB_DRMBDFilter \
		9

typedef struct SIE_DRMBDFilter {

	#define	RA_DRMBDFilter_HDR 			0x00000
	#define	w32DRMBDFilter_HDR 			{										\
					UNSG32				uHDR_filterFunc				 : 16;		\
					UNSG32				uHDR_filterState			 :  8;		\
					UNSG32				uHDR_isByPassMode			 :  1;		\
					UNSG32				uHDR_isEncrypted			 :  1;		\
					UNSG32				uHDR_isBusEncOn				 :  1;		\
					UNSG32				_x00000	:  5;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRMBDFilter_HDR;
								struct	w32DRMBDFilter_HDR;
										};

	/* [15: 0] */	#define	  BA_DRMBDFilter_HDR_filterFunc			 0x00000
	/* ---:--- */	#define	    bDRMBDFilter_HDR_filterFunc			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_HDR_filterFunc			    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMBDFilter_HDR_filterFunc			       0x0000FFFF
	/* ---:--- */	#define	GET32DRMBDFilter_HDR_filterFunc(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_HDR_filterFunc(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_HDR_filterFunc(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_HDR_filterFunc(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRMBDFilter_HDR_filterState		 0x00002
	/* ---:--- */	#define	    bDRMBDFilter_HDR_filterState		    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_HDR_filterState		   16 /*:23*/
	/* ---:--- */	#define	MSK32DRMBDFilter_HDR_filterState		       0x00FF0000
	/* ---:--- */	#define	GET32DRMBDFilter_HDR_filterState(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRMBDFilter_HDR_filterState(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMBDFilter_HDR_filterState(r32,v)		do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_HDR_filterState(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRMBDFilter_HDR_filterState_INACTIVE		0x0
					#define	     DRMBDFilter_HDR_filterState_STOPPED		0x1
					#define	     DRMBDFilter_HDR_filterState_STOPPING		0x2
					#define	     DRMBDFilter_HDR_filterState_RUNNING		0x3
					#define	     DRMBDFilter_HDR_filterState_FLUSHING		0x4
					#define	     DRMBDFilter_HDR_filterState_PAUSING		0x5
					#define	     DRMBDFilter_HDR_filterState_PAUSED			0x6

	/* [24:24] */	#define	  BA_DRMBDFilter_HDR_isByPassMode		 0x00003
	/* ---:--- */	#define	    bDRMBDFilter_HDR_isByPassMode		    1 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_HDR_isByPassMode		   24 /*:24*/
	/* ---:--- */	#define	MSK32DRMBDFilter_HDR_isByPassMode		       0x01000000
	/* ---:--- */	#define	GET32DRMBDFilter_HDR_isByPassMode(r32)		 (((r32)>>24)&0x0001)
	/* ---:--- */	#define	GET16DRMBDFilter_HDR_isByPassMode(r16)		 (((r16)>> 8)&0x0001)
	/* ---:--- */	#define	SET32DRMBDFilter_HDR_isByPassMode(r32,v)	do{(r32)&=~(0x0001<<24);(r32)|=((v)&0x0001)<<24;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_HDR_isByPassMode(r16,v)	do{(r16)&=~(0x0001<< 8);(r16)|=((v)&0x0001)<< 8;}while(0)

	/* [25:25] */	#define	  BA_DRMBDFilter_HDR_isEncrypted		 0x00003
	/* ---:--- */	#define	    bDRMBDFilter_HDR_isEncrypted		    1 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_HDR_isEncrypted		   25 /*:25*/
	/* ---:--- */	#define	MSK32DRMBDFilter_HDR_isEncrypted		       0x02000000
	/* ---:--- */	#define	GET32DRMBDFilter_HDR_isEncrypted(r32)		 (((r32)>>25)&0x0001)
	/* ---:--- */	#define	GET16DRMBDFilter_HDR_isEncrypted(r16)		 (((r16)>> 9)&0x0001)
	/* ---:--- */	#define	SET32DRMBDFilter_HDR_isEncrypted(r32,v)		do{(r32)&=~(0x0001<<25);(r32)|=((v)&0x0001)<<25;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_HDR_isEncrypted(r16,v)		do{(r16)&=~(0x0001<< 9);(r16)|=((v)&0x0001)<< 9;}while(0)

	/* [26:26] */	#define	  BA_DRMBDFilter_HDR_isBusEncOn			 0x00003
	/* ---:--- */	#define	    bDRMBDFilter_HDR_isBusEncOn			    1 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_HDR_isBusEncOn			   26 /*:26*/
	/* ---:--- */	#define	MSK32DRMBDFilter_HDR_isBusEncOn			       0x04000000
	/* ---:--- */	#define	GET32DRMBDFilter_HDR_isBusEncOn(r32)		 (((r32)>>26)&0x0001)
	/* ---:--- */	#define	GET16DRMBDFilter_HDR_isBusEncOn(r16)		 (((r16)>>10)&0x0001)
	/* ---:--- */	#define	SET32DRMBDFilter_HDR_isBusEncOn(r32,v)		do{(r32)&=~(0x0001<<26);(r32)|=((v)&0x0001)<<26;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_HDR_isBusEncOn(r16,v)		do{(r16)&=~(0x0001<<10);(r16)|=((v)&0x0001)<<10;}while(0)

	#define	RA_DRMBDFilter_IO 			0x00004
	#define	w32DRMBDFilter_IO 			{										\
					UNSG32				uIO_strmInPtr				 : 16;		\
					UNSG32				uIO_strmOutPtr				 : 16;		\
										}
	/* @'00004 */	union {	UNSG32		u32DRMBDFilter_IO;
								struct	w32DRMBDFilter_IO;
										};

	/* [15: 0] */	#define	  BA_DRMBDFilter_IO_strmInPtr			 0x00004
	/* ---:--- */	#define	    bDRMBDFilter_IO_strmInPtr			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_IO_strmInPtr			    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMBDFilter_IO_strmInPtr			       0x0000FFFF
	/* ---:--- */	#define	GET32DRMBDFilter_IO_strmInPtr(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_IO_strmInPtr(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_IO_strmInPtr(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_IO_strmInPtr(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMBDFilter_IO_strmOutPtr			 0x00006
	/* ---:--- */	#define	    bDRMBDFilter_IO_strmOutPtr			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_IO_strmOutPtr			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMBDFilter_IO_strmOutPtr			       0xFFFF0000
	/* ---:--- */	#define	GET32DRMBDFilter_IO_strmOutPtr(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_IO_strmOutPtr(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_IO_strmOutPtr(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_IO_strmOutPtr(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMBDFilter_D2th_ 		ISC_USE_ONLY	0x00008
	#define	w32DRMBDFilter_D2th_ 		{										\
					UNSG32				u_datBase					 : 16;		\
					UNSG32				u_ctrlBase					 : 16;		\
										}
	/* @'00008 */				struct	w32DRMBDFilter_D2th_;

	/* [15: 0] */	#define	  BA_DRMBDFilter_datBase				 0x00008
	/* ---:--- */	#define	    bDRMBDFilter_datBase				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_datBase				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMBDFilter_datBase				       0x0000FFFF
	/* ---:--- */	#define	GET32DRMBDFilter_datBase(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_datBase(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_datBase(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_datBase(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMBDFilter_ctrlBase				 0x0000A
	/* ---:--- */	#define	    bDRMBDFilter_ctrlBase				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_ctrlBase				   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMBDFilter_ctrlBase				       0xFFFF0000
	/* ---:--- */	#define	GET32DRMBDFilter_ctrlBase(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_ctrlBase(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_ctrlBase(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_ctrlBase(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMBDFilter_D3th_ 		ISC_USE_ONLY	0x0000C
	#define	w32DRMBDFilter_D3th_ 		{										\
					UNSG32				u_datMaxSize				 : 16;		\
					UNSG32				u_ctrlMaxSize				 : 16;		\
										}
	/* @'0000C */				struct	w32DRMBDFilter_D3th_;

	/* [15: 0] */	#define	  BA_DRMBDFilter_datMaxSize				 0x0000C
	/* ---:--- */	#define	    bDRMBDFilter_datMaxSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_datMaxSize				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMBDFilter_datMaxSize				       0x0000FFFF
	/* ---:--- */	#define	GET32DRMBDFilter_datMaxSize(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_datMaxSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_datMaxSize(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_datMaxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMBDFilter_ctrlMaxSize			 0x0000E
	/* ---:--- */	#define	    bDRMBDFilter_ctrlMaxSize			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_ctrlMaxSize			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMBDFilter_ctrlMaxSize			       0xFFFF0000
	/* ---:--- */	#define	GET32DRMBDFilter_ctrlMaxSize(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_ctrlMaxSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_ctrlMaxSize(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_ctrlMaxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMBDFilter_D4th_ 		ISC_USE_ONLY	0x00010
	#define	w32DRMBDFilter_D4th_ 		{										\
					UNSG32				u_packStartOffset			 : 16;		\
					UNSG32				u_packSizeToRd				 : 16;		\
										}
	/* @'00010 */				struct	w32DRMBDFilter_D4th_;

	/* [15: 0] */	#define	  BA_DRMBDFilter_packStartOffset		 0x00010
	/* ---:--- */	#define	    bDRMBDFilter_packStartOffset		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_packStartOffset		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMBDFilter_packStartOffset		       0x0000FFFF
	/* ---:--- */	#define	GET32DRMBDFilter_packStartOffset(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_packStartOffset(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_packStartOffset(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_packStartOffset(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMBDFilter_packSizeToRd			 0x00012
	/* ---:--- */	#define	    bDRMBDFilter_packSizeToRd			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_packSizeToRd			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMBDFilter_packSizeToRd			       0xFFFF0000
	/* ---:--- */	#define	GET32DRMBDFilter_packSizeToRd(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_packSizeToRd(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_packSizeToRd(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_packSizeToRd(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMBDFilter_CTR 			0x00014
	#define	w32DRMBDFilter_CTR 			{										\
					UNSG32				uCTR_strmCtrIn				 : 32;		\
										}
	/* @'00014 */	union {	UNSG32		u32DRMBDFilter_CTR;
								struct	w32DRMBDFilter_CTR;
										};

	/* [31: 0] */	#define	  BA_DRMBDFilter_CTR_strmCtrIn			 0x00014
	/* ---:--- */	#define	    bDRMBDFilter_CTR_strmCtrIn			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_CTR_strmCtrIn			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMBDFilter_CTR_strmCtrIn			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMBDFilter_CTR_strmCtrIn(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_CTR_strmCtrIn(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_CTR_strmCtrIn(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_CTR_strmCtrIn(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMBDFilter_tkIn 		0x00018
	/* @'00018 */	SIE_UINT128 				ie_tkIn;

	#define	RA_DRMBDFilter_rndKey 		0x00028
	/* @'00028 */	SIE_UINT128 				ie_rndKey			 [11];
					#define	 arr_DRMBDFilter_rndKey 				  11

	UNSG32	_PAD_000[(0x000E0-0x000D8)/4];
	#define	RA_DRMBDFilter_pbBEIV 		0x000E0
	/* @'000E0 */	SIE_UINT128 				ie_pbBEIV;

	#define	RA_DRMBDFilter_pbIV 		0x000F0
	/* @'000F0 */	SIE_UINT128 				ie_pbIV;

	#define	RA_DRMBDFilter_pbAACSConstIV 0x00100
	/* @'00100 */	SIE_UINT128 				ie_pbAACSConstIV;

	#define	RA_DRMBDFilter_D68th_ 		ISC_USE_ONLY	0x00110
	#define	w32DRMBDFilter_D68th_ 		{										\
					UNSG32				u_beBlockCnt				 : 16;		\
					UNSG32				u_beReserved				 : 16;		\
										}
	/* @'00110 */				struct	w32DRMBDFilter_D68th_;

	/* [15: 0] */	#define	  BA_DRMBDFilter_beBlockCnt				 0x00110
	/* ---:--- */	#define	    bDRMBDFilter_beBlockCnt				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_beBlockCnt				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMBDFilter_beBlockCnt				       0x0000FFFF
	/* ---:--- */	#define	GET32DRMBDFilter_beBlockCnt(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_beBlockCnt(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_beBlockCnt(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_beBlockCnt(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMBDFilter_beReserved				 0x00112
	/* ---:--- */	#define	    bDRMBDFilter_beReserved				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_beReserved				   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMBDFilter_beReserved				       0xFFFF0000
	/* ---:--- */	#define	GET32DRMBDFilter_beReserved(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_beReserved(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_beReserved(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_beReserved(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMBDFilter_D69th_ 		ISC_USE_ONLY	0x00114
	#define	w32DRMBDFilter_D69th_ 		{										\
					UNSG32				u_busKeyCtxAddr				 : 16;		\
					UNSG32				u_BEpackSizeToRd			 : 16;		\
										}
	/* @'00114 */				struct	w32DRMBDFilter_D69th_;

	/* [15: 0] */	#define	  BA_DRMBDFilter_busKeyCtxAddr			 0x00114
	/* ---:--- */	#define	    bDRMBDFilter_busKeyCtxAddr			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_busKeyCtxAddr			    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMBDFilter_busKeyCtxAddr			       0x0000FFFF
	/* ---:--- */	#define	GET32DRMBDFilter_busKeyCtxAddr(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_busKeyCtxAddr(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_busKeyCtxAddr(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_busKeyCtxAddr(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMBDFilter_BEpackSizeToRd			 0x00116
	/* ---:--- */	#define	    bDRMBDFilter_BEpackSizeToRd			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMBDFilter_BEpackSizeToRd			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMBDFilter_BEpackSizeToRd			       0xFFFF0000
	/* ---:--- */	#define	GET32DRMBDFilter_BEpackSizeToRd(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMBDFilter_BEpackSizeToRd(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMBDFilter_BEpackSizeToRd(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMBDFilter_BEpackSizeToRd(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	UNSG32	_PAD_001[(0x00120-0x00118)/4];
} SIE_DRMBDFilter;

	#define	dftDRMBDFilter_HDR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMBDFilter_HDR;
										} T32DRMBDFilter_HDR;
	#define	dftDRMBDFilter_IO 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMBDFilter_IO;
										} T32DRMBDFilter_IO;
	#define	dftDRMBDFilter_CTR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMBDFilter_CTR;
										} T32DRMBDFilter_CTR;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMBDFilter_drvrd (SIE_DRMBDFilter *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMBDFilter_drvwr (SIE_DRMBDFilter *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMBDFilter_reset (SIE_DRMBDFilter *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMBDFilter_check(p,pie,ps8name,hfpErrLOG)		DRMBDFilter_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMBDFilter_print(p,    ps8name,hfpErrLOG)		DRMBDFilter_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMBDFilter_cmp   (SIE_DRMBDFilter *p, SIE_DRMBDFilter *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMBDFilter_import(SIE_DRMBDFilter *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMBDFilter_export(SIE_DRMBDFilter *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMBDFilter
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CtrlFIFOData
*	@
*		$UINT64  uData  REG  [8]
*						*  *
**********************************************************************************************************************/
#ifdef	h_CtrlFIFOData
#else
#define	h_CtrlFIFOData

#define	\
	AR_CtrlFIFOData \
		16
#define	\
	AB_CtrlFIFOData \
		6

typedef struct SIE_CtrlFIFOData {

	#define	RA_CtrlFIFOData_uData 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_uData			 [8];
					#define	 arr_CtrlFIFOData_uData 				  8

} SIE_CtrlFIFOData;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CtrlFIFOData_drvrd (SIE_CtrlFIFOData *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CtrlFIFOData_drvwr (SIE_CtrlFIFOData *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CtrlFIFOData_reset (SIE_CtrlFIFOData *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CtrlFIFOData_check(p,pie,ps8name,hfpErrLOG)		CtrlFIFOData_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CtrlFIFOData_print(p,    ps8name,hfpErrLOG)		CtrlFIFOData_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CtrlFIFOData_cmp   (SIE_CtrlFIFOData *p, SIE_CtrlFIFOData *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CtrlFIFOData_import(SIE_CtrlFIFOData *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CtrlFIFOData_export(SIE_CtrlFIFOData *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CtrlFIFOData
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: KeySeedData
*	@
*		$UINT64  uData  REG  [8]
*						*  *
**********************************************************************************************************************/
#ifdef	h_KeySeedData
#else
#define	h_KeySeedData

#define	\
	AR_KeySeedData \
		16
#define	\
	AB_KeySeedData \
		6

typedef struct SIE_KeySeedData {

	#define	RA_KeySeedData_uData 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_uData			 [8];
					#define	 arr_KeySeedData_uData 					  8

} SIE_KeySeedData;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	KeySeedData_drvrd (SIE_KeySeedData *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	KeySeedData_drvwr (SIE_KeySeedData *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	KeySeedData_reset (SIE_KeySeedData *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	KeySeedData_check(p,pie,ps8name,hfpErrLOG)		KeySeedData_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	KeySeedData_print(p,    ps8name,hfpErrLOG)		KeySeedData_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	KeySeedData_cmp   (SIE_KeySeedData *p, SIE_KeySeedData *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	KeySeedData_import(SIE_KeySeedData *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	KeySeedData_export(SIE_KeySeedData *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: KeySeedData
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UpTKCtrlFIFO
*	@
*		$UINT128  uData  REG  [2]
*						*  *
*	@
*		$UINT128  RKEK
*						*  *
*	@
*		$UINT128  A
*						*  *
*	@
*		$UINT128  B
*						*  *
*	@
*		$UINT128  R
*						*  *
*	@
*		$UINT128  Reserved  REG  [2]
**********************************************************************************************************************/
#ifdef	h_UpTKCtrlFIFO
#else
#define	h_UpTKCtrlFIFO

#define	\
	AR_UpTKCtrlFIFO \
		32
#define	\
	AB_UpTKCtrlFIFO \
		7

typedef struct SIE_UpTKCtrlFIFO {

	#define	RA_UpTKCtrlFIFO_uData 		0x00000
	/* @'00000 */	SIE_UINT128 				ie_uData			 [2];
					#define	 arr_UpTKCtrlFIFO_uData 				  2

	#define	RA_UpTKCtrlFIFO_RKEK 		0x00020
	/* @'00020 */	SIE_UINT128 				ie_RKEK;

	#define	RA_UpTKCtrlFIFO_A 			0x00030
	/* @'00030 */	SIE_UINT128 				ie_A;

	#define	RA_UpTKCtrlFIFO_B 			0x00040
	/* @'00040 */	SIE_UINT128 				ie_B;

	#define	RA_UpTKCtrlFIFO_R 			0x00050
	/* @'00050 */	SIE_UINT128 				ie_R;

	#define	RA_UpTKCtrlFIFO_Reserved 	0x00060
	/* @'00060 */	SIE_UINT128 				ie_Reserved			 [2];
					#define	 arr_UpTKCtrlFIFO_Reserved 				  2

} SIE_UpTKCtrlFIFO;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UpTKCtrlFIFO_drvrd (SIE_UpTKCtrlFIFO *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UpTKCtrlFIFO_drvwr (SIE_UpTKCtrlFIFO *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UpTKCtrlFIFO_reset (SIE_UpTKCtrlFIFO *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UpTKCtrlFIFO_check(p,pie,ps8name,hfpErrLOG)		UpTKCtrlFIFO_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UpTKCtrlFIFO_print(p,    ps8name,hfpErrLOG)		UpTKCtrlFIFO_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UpTKCtrlFIFO_cmp   (SIE_UpTKCtrlFIFO *p, SIE_UpTKCtrlFIFO *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UpTKCtrlFIFO_import(SIE_UpTKCtrlFIFO *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UpTKCtrlFIFO_export(SIE_UpTKCtrlFIFO *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UpTKCtrlFIFO
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMDiagMultiBDCtx
*	@
*		$AES128_CTXDAT  aesCtx  REG
*	@  0x620
*		$BusKeyCtx  busKeyCtx  REG
*						*  *
*						*  Bus key context
*	@  0x800  DAT_START
*		$UINT128  datStart  REG
*		$UINT64  dsCmdFifo  REG  [16]
*						*  *
*						*  Data streamer command FIFO
*		$UINT128  blkStart  REG
*						*  *
*						*  Transfer Data Area
*	@  0x2C00  LA_START
*		$LocalArea  la
*						*  *
*						*  Local area
*	@  CTX_START
*		$DTCMBlkPool  datInMemPool
*						*  *
*						*  Data memory pool
*		$DTCMBlkPool  datOutMemPool
*						*  *
*						*  Data memory pool
*	@  STREAMS
*		$DSStreamIn  datStrmIn  REG  [4]
*						*  *
*						*  DS Input stream
*		$CtrlFIFOData  datCtrlFifo  REG  [4]
*						*  *
*						*  Control FIFO data
*		$DSStreamOut  datStrmOut  REG  [4]
*						*  *
*						*  DS Ouput stream
*		$DSStreamOutModule  datStrmOutModule
*	@  FILTERS
*		$DRMBDFilter  bdFilterList  REG  [4]
*						*  *
*						*  Blue Ray DVD Context
*		$UINT128  datFilterBuf  REG  [96]
*						*  *
*						*  Temp buffer for Filter data
*		$UINT128  ctrlFilterBuf  REG  [8]
*						*  *
*						*  Temp buffer for Filter Control
*	@  DTCMSIZE
*		%unsigned  16  uTotalSize  REG
*	@  IMG_END
*		$UINT128  resserved  REG
**********************************************************************************************************************/
#ifdef	h_DRMDiagMultiBDCtx
#else
#define	h_DRMDiagMultiBDCtx

#define	\
	AR_DRMDiagMultiBDCtx \
		3980
#define	\
	AB_DRMDiagMultiBDCtx \
		14

typedef struct SIE_DRMDiagMultiBDCtx {

	#define	RA_DRMDiagMultiBDCtx_aesCtx 0x00000
	/* @'00000 */	SIE_AES128_CTXDAT 			ie_aesCtx;

	UNSG32	_PAD_000[(0x00620-0x00618)/4];
	#define	RA_DRMDiagMultiBDCtx_busKeyCtx 0x00620
	/* @'00620 */	SIE_BusKeyCtx 				ie_busKeyCtx;

	UNSG32	_PAD_001[(0x00800-0x006E0)/4];
	#define	RA_DRMDiagMultiBDCtx_DAT_START 0x00800
	/* @'00800 */	SIE_UINT128 				ie_datStart;

	#define	RA_DRMDiagMultiBDCtx_dsCmdFifo 0x00810
	/* @'00810 */	SIE_UINT64 					ie_dsCmdFifo		 [16];
					#define	 arr_DRMDiagMultiBDCtx_dsCmdFifo 		  16

	#define	RA_DRMDiagMultiBDCtx_blkStart 0x00890
	/* @'00890 */	SIE_UINT128 				ie_blkStart;

	UNSG32	_PAD_002[(0x02C00-0x008A0)/4];
	#define	RA_DRMDiagMultiBDCtx_LA_START 0x02C00
	/* @'02C00 */	SIE_LocalArea 				ie_la;

	#define	RA_DRMDiagMultiBDCtx_CTX_START 0x02E28
	/* @'02E28 */	SIE_DTCMBlkPool 			ie_datInMemPool;

	#define	RA_DRMDiagMultiBDCtx_datOutMemPool 0x02F50
	/* @'02F50 */	SIE_DTCMBlkPool 			ie_datOutMemPool;

	#define	RA_DRMDiagMultiBDCtx_STREAMS 0x03078
	/* @'03078 */	SIE_DSStreamIn 				ie_datStrmIn		 [4];
					#define	 arr_DRMDiagMultiBDCtx_datStrmIn 		  4

	#define	RA_DRMDiagMultiBDCtx_datCtrlFifo 0x03198
	/* @'03198 */	SIE_CtrlFIFOData 			ie_datCtrlFifo		 [4];
					#define	 arr_DRMDiagMultiBDCtx_datCtrlFifo 		  4

	#define	RA_DRMDiagMultiBDCtx_datStrmOut 0x03298
	/* @'03298 */	SIE_DSStreamOut 			ie_datStrmOut		 [4];
					#define	 arr_DRMDiagMultiBDCtx_datStrmOut 		  4

	#define	RA_DRMDiagMultiBDCtx_datStrmOutModule 0x032F8
	/* @'032F8 */	SIE_DSStreamOutModule 		ie_datStrmOutModule;

	#define	RA_DRMDiagMultiBDCtx_FILTERS 0x03310
	/* @'03310 */	SIE_DRMBDFilter 			ie_bdFilterList		 [4];
					#define	 arr_DRMDiagMultiBDCtx_bdFilterList 	  4

	#define	RA_DRMDiagMultiBDCtx_datFilterBuf 0x03790
	/* @'03790 */	SIE_UINT128 				ie_datFilterBuf		 [96];
					#define	 arr_DRMDiagMultiBDCtx_datFilterBuf 	  96

	#define	RA_DRMDiagMultiBDCtx_ctrlFilterBuf 0x03D90
	/* @'03D90 */	SIE_UINT128 				ie_ctrlFilterBuf	 [8];
					#define	 arr_DRMDiagMultiBDCtx_ctrlFilterBuf 	  8

	#define	RA_DRMDiagMultiBDCtx_DTCMSIZE 0x03E10
	#define	w32DRMDiagMultiBDCtx_DTCMSIZE {										\
					UNSG32				uDTCMSIZE_uTotalSize		 : 16;		\
					UNSG32				_x03E10	: 16;							\
										}
	/* @'03E10 */	union {	UNSG32		u32DRMDiagMultiBDCtx_DTCMSIZE;
								struct	w32DRMDiagMultiBDCtx_DTCMSIZE;
										};

	/* [15: 0] */	#define	  BA_DRMDiagMultiBDCtx_DTCMSIZE_uTotalSize 0x03E10
	/* ---:--- */	#define	    bDRMDiagMultiBDCtx_DTCMSIZE_uTotalSize   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMDiagMultiBDCtx_DTCMSIZE_uTotalSize    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMDiagMultiBDCtx_DTCMSIZE_uTotalSize       0x0000FFFF
	/* ---:--- */	#define	GET32DRMDiagMultiBDCtx_DTCMSIZE_uTotalSize(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMDiagMultiBDCtx_DTCMSIZE_uTotalSize(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMDiagMultiBDCtx_DTCMSIZE_uTotalSize(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMDiagMultiBDCtx_DTCMSIZE_uTotalSize(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMDiagMultiBDCtx_IMG_END 0x03E14
	/* @'03E14 */	SIE_UINT128 				ie_resserved;

	UNSG32	_PAD_003[(0x03E30-0x03E24)/4];
} SIE_DRMDiagMultiBDCtx;

	#define	dftDRMDiagMultiBDCtx_DTCMSIZE 0x0000CCCC
			typedef	union {	UNSG32		u32;
								struct	w32DRMDiagMultiBDCtx_DTCMSIZE;
										} T32DRMDiagMultiBDCtx_DTCMSIZE;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMDiagMultiBDCtx_drvrd (SIE_DRMDiagMultiBDCtx *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMDiagMultiBDCtx_drvwr (SIE_DRMDiagMultiBDCtx *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMDiagMultiBDCtx_reset (SIE_DRMDiagMultiBDCtx *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMDiagMultiBDCtx_check(p,pie,ps8name,hfpErrLOG)		DRMDiagMultiBDCtx_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMDiagMultiBDCtx_print(p,    ps8name,hfpErrLOG)		DRMDiagMultiBDCtx_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMDiagMultiBDCtx_cmp   (SIE_DRMDiagMultiBDCtx *p, SIE_DRMDiagMultiBDCtx *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMDiagMultiBDCtx_import(SIE_DRMDiagMultiBDCtx *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMDiagMultiBDCtx_export(SIE_DRMDiagMultiBDCtx *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMDiagMultiBDCtx
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMWMFilter
*	@  HDR
*		%unsigned  16  filterFunc
*		%unsigned  8  filterState
*			:  INACTIVE  0
*			:  STOPPED  1
*			:  STOPPING  2
*			:  RUNNING  3
*			:  FLUSHING  4
*			:  PAUSING  5
*			:  PAUSED  6
*		%unsigned  1  isByPassMode
*	@  IO
*		%unsigned  16  strmInPtr
*						*  *
*						*  Address of the input data FIFO pointer
*						*  *
*						*  Size to read next time
*		%unsigned  16  strmOutPtr
*						*  *
*						*  Address of the output data FIFO pointer
*	@
*		%unsigned  16  datBase
*						*  *
*						*  Internal data buffer
*		%unsigned  16  ctrlBase
*						*  *
*						*  Internal control buffer
*	@
*		%unsigned  16  datMaxSize
*						*  *
*						*  Size of the internal data buffer
*		%unsigned  16  ctrlMaxSize
*						*  *
*						*  Size of the internal control buffer
*	@
*		%unsigned  16  payLoadSize
*						*  *
*						*  Bytes left in the current BD packet
*		%unsigned  16  payLoadToRead
*						*  *
*						*  Bytes left in the current payLoad packet
*	@  CTR
*		%unsigned  32  strmCtrIn
*						*  *
*						*  Input stream counter
*	@
*		$DTCMFifo  keySeedFifo
*						*  *
*						*  DTCM FIFO Context for key seed, the depth of the FIFO is depend on Input Buffer Size
*	@
*		$UINT64  pbKeySeed
*	@
*		$UINT64  pbDESKey
*						*  *
*						*  DES key which is the last 8 byte of HASH value of Content Key
*	@
*		$UINT64  pbRC4Key  REG  [2]
*						*  *
*						*  RC4 Key which is generated during process the payload of WM DRM
*	@
*		$UINT64  pbFilterKey  REG  [8]
*						*  *
*						*  Filter Key data including CBC MAC key, next8byte and last8byte
*	@
*		%unsigned  16  isKeySet
*		%unsigned  16  isKSeedOK
*	@
*		%unsigned  16  pbDESCtx
*		%unsigned  16  reserved
**********************************************************************************************************************/
#ifdef	h_DRMWMFilter
#else
#define	h_DRMWMFilter

#define	\
	AR_DRMWMFilter \
		34
#define	\
	AB_DRMWMFilter \
		8

typedef struct SIE_DRMWMFilter {

	#define	RA_DRMWMFilter_HDR 			0x00000
	#define	w32DRMWMFilter_HDR 			{										\
					UNSG32				uHDR_filterFunc				 : 16;		\
					UNSG32				uHDR_filterState			 :  8;		\
					UNSG32				uHDR_isByPassMode			 :  1;		\
					UNSG32				_x00000	:  7;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRMWMFilter_HDR;
								struct	w32DRMWMFilter_HDR;
										};

	/* [15: 0] */	#define	  BA_DRMWMFilter_HDR_filterFunc			 0x00000
	/* ---:--- */	#define	    bDRMWMFilter_HDR_filterFunc			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_HDR_filterFunc			    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMWMFilter_HDR_filterFunc			       0x0000FFFF
	/* ---:--- */	#define	GET32DRMWMFilter_HDR_filterFunc(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_HDR_filterFunc(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_HDR_filterFunc(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_HDR_filterFunc(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRMWMFilter_HDR_filterState		 0x00002
	/* ---:--- */	#define	    bDRMWMFilter_HDR_filterState		    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_HDR_filterState		   16 /*:23*/
	/* ---:--- */	#define	MSK32DRMWMFilter_HDR_filterState		       0x00FF0000
	/* ---:--- */	#define	GET32DRMWMFilter_HDR_filterState(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRMWMFilter_HDR_filterState(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMWMFilter_HDR_filterState(r32,v)		do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_HDR_filterState(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRMWMFilter_HDR_filterState_INACTIVE		0x0
					#define	     DRMWMFilter_HDR_filterState_STOPPED		0x1
					#define	     DRMWMFilter_HDR_filterState_STOPPING		0x2
					#define	     DRMWMFilter_HDR_filterState_RUNNING		0x3
					#define	     DRMWMFilter_HDR_filterState_FLUSHING		0x4
					#define	     DRMWMFilter_HDR_filterState_PAUSING		0x5
					#define	     DRMWMFilter_HDR_filterState_PAUSED			0x6

	/* [24:24] */	#define	  BA_DRMWMFilter_HDR_isByPassMode		 0x00003
	/* ---:--- */	#define	    bDRMWMFilter_HDR_isByPassMode		    1 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_HDR_isByPassMode		   24 /*:24*/
	/* ---:--- */	#define	MSK32DRMWMFilter_HDR_isByPassMode		       0x01000000
	/* ---:--- */	#define	GET32DRMWMFilter_HDR_isByPassMode(r32)		 (((r32)>>24)&0x0001)
	/* ---:--- */	#define	GET16DRMWMFilter_HDR_isByPassMode(r16)		 (((r16)>> 8)&0x0001)
	/* ---:--- */	#define	SET32DRMWMFilter_HDR_isByPassMode(r32,v)	do{(r32)&=~(0x0001<<24);(r32)|=((v)&0x0001)<<24;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_HDR_isByPassMode(r16,v)	do{(r16)&=~(0x0001<< 8);(r16)|=((v)&0x0001)<< 8;}while(0)

	#define	RA_DRMWMFilter_IO 			0x00004
	#define	w32DRMWMFilter_IO 			{										\
					UNSG32				uIO_strmInPtr				 : 16;		\
					UNSG32				uIO_strmOutPtr				 : 16;		\
										}
	/* @'00004 */	union {	UNSG32		u32DRMWMFilter_IO;
								struct	w32DRMWMFilter_IO;
										};

	/* [15: 0] */	#define	  BA_DRMWMFilter_IO_strmInPtr			 0x00004
	/* ---:--- */	#define	    bDRMWMFilter_IO_strmInPtr			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_IO_strmInPtr			    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMWMFilter_IO_strmInPtr			       0x0000FFFF
	/* ---:--- */	#define	GET32DRMWMFilter_IO_strmInPtr(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_IO_strmInPtr(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_IO_strmInPtr(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_IO_strmInPtr(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMWMFilter_IO_strmOutPtr			 0x00006
	/* ---:--- */	#define	    bDRMWMFilter_IO_strmOutPtr			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_IO_strmOutPtr			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMWMFilter_IO_strmOutPtr			       0xFFFF0000
	/* ---:--- */	#define	GET32DRMWMFilter_IO_strmOutPtr(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_IO_strmOutPtr(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_IO_strmOutPtr(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_IO_strmOutPtr(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMWMFilter_D2th_ 		ISC_USE_ONLY	0x00008
	#define	w32DRMWMFilter_D2th_ 		{										\
					UNSG32				u_datBase					 : 16;		\
					UNSG32				u_ctrlBase					 : 16;		\
										}
	/* @'00008 */				struct	w32DRMWMFilter_D2th_;

	/* [15: 0] */	#define	  BA_DRMWMFilter_datBase				 0x00008
	/* ---:--- */	#define	    bDRMWMFilter_datBase				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_datBase				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMWMFilter_datBase				       0x0000FFFF
	/* ---:--- */	#define	GET32DRMWMFilter_datBase(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_datBase(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_datBase(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_datBase(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMWMFilter_ctrlBase				 0x0000A
	/* ---:--- */	#define	    bDRMWMFilter_ctrlBase				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_ctrlBase				   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMWMFilter_ctrlBase				       0xFFFF0000
	/* ---:--- */	#define	GET32DRMWMFilter_ctrlBase(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_ctrlBase(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_ctrlBase(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_ctrlBase(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMWMFilter_D3th_ 		ISC_USE_ONLY	0x0000C
	#define	w32DRMWMFilter_D3th_ 		{										\
					UNSG32				u_datMaxSize				 : 16;		\
					UNSG32				u_ctrlMaxSize				 : 16;		\
										}
	/* @'0000C */				struct	w32DRMWMFilter_D3th_;

	/* [15: 0] */	#define	  BA_DRMWMFilter_datMaxSize				 0x0000C
	/* ---:--- */	#define	    bDRMWMFilter_datMaxSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_datMaxSize				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMWMFilter_datMaxSize				       0x0000FFFF
	/* ---:--- */	#define	GET32DRMWMFilter_datMaxSize(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_datMaxSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_datMaxSize(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_datMaxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMWMFilter_ctrlMaxSize			 0x0000E
	/* ---:--- */	#define	    bDRMWMFilter_ctrlMaxSize			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_ctrlMaxSize			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMWMFilter_ctrlMaxSize			       0xFFFF0000
	/* ---:--- */	#define	GET32DRMWMFilter_ctrlMaxSize(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_ctrlMaxSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_ctrlMaxSize(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_ctrlMaxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMWMFilter_D4th_ 		ISC_USE_ONLY	0x00010
	#define	w32DRMWMFilter_D4th_ 		{										\
					UNSG32				u_payLoadSize				 : 16;		\
					UNSG32				u_payLoadToRead				 : 16;		\
										}
	/* @'00010 */				struct	w32DRMWMFilter_D4th_;

	/* [15: 0] */	#define	  BA_DRMWMFilter_payLoadSize			 0x00010
	/* ---:--- */	#define	    bDRMWMFilter_payLoadSize			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_payLoadSize			    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMWMFilter_payLoadSize			       0x0000FFFF
	/* ---:--- */	#define	GET32DRMWMFilter_payLoadSize(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_payLoadSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_payLoadSize(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_payLoadSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMWMFilter_payLoadToRead			 0x00012
	/* ---:--- */	#define	    bDRMWMFilter_payLoadToRead			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_payLoadToRead			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMWMFilter_payLoadToRead			       0xFFFF0000
	/* ---:--- */	#define	GET32DRMWMFilter_payLoadToRead(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_payLoadToRead(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_payLoadToRead(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_payLoadToRead(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMWMFilter_CTR 			0x00014
	#define	w32DRMWMFilter_CTR 			{										\
					UNSG32				uCTR_strmCtrIn				 : 32;		\
										}
	/* @'00014 */	union {	UNSG32		u32DRMWMFilter_CTR;
								struct	w32DRMWMFilter_CTR;
										};

	/* [31: 0] */	#define	  BA_DRMWMFilter_CTR_strmCtrIn			 0x00014
	/* ---:--- */	#define	    bDRMWMFilter_CTR_strmCtrIn			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_CTR_strmCtrIn			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMWMFilter_CTR_strmCtrIn			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMWMFilter_CTR_strmCtrIn(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_CTR_strmCtrIn(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_CTR_strmCtrIn(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_CTR_strmCtrIn(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMWMFilter_keySeedFifo 	0x00018
	/* @'00018 */	SIE_DTCMFifo 				ie_keySeedFifo;

	#define	RA_DRMWMFilter_pbKeySeed 	0x00020
	/* @'00020 */	SIE_UINT64 					ie_pbKeySeed;

	#define	RA_DRMWMFilter_pbDESKey 	0x00028
	/* @'00028 */	SIE_UINT64 					ie_pbDESKey;

	#define	RA_DRMWMFilter_pbRC4Key 	0x00030
	/* @'00030 */	SIE_UINT64 					ie_pbRC4Key			 [2];
					#define	 arr_DRMWMFilter_pbRC4Key 				  2

	#define	RA_DRMWMFilter_pbFilterKey 	0x00040
	/* @'00040 */	SIE_UINT64 					ie_pbFilterKey		 [8];
					#define	 arr_DRMWMFilter_pbFilterKey 			  8

	#define	RA_DRMWMFilter_D32th_ 		ISC_USE_ONLY	0x00080
	#define	w32DRMWMFilter_D32th_ 		{										\
					UNSG32				u_isKeySet					 : 16;		\
					UNSG32				u_isKSeedOK					 : 16;		\
										}
	/* @'00080 */				struct	w32DRMWMFilter_D32th_;

	/* [15: 0] */	#define	  BA_DRMWMFilter_isKeySet				 0x00080
	/* ---:--- */	#define	    bDRMWMFilter_isKeySet				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_isKeySet				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMWMFilter_isKeySet				       0x0000FFFF
	/* ---:--- */	#define	GET32DRMWMFilter_isKeySet(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_isKeySet(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_isKeySet(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_isKeySet(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMWMFilter_isKSeedOK				 0x00082
	/* ---:--- */	#define	    bDRMWMFilter_isKSeedOK				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_isKSeedOK				   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMWMFilter_isKSeedOK				       0xFFFF0000
	/* ---:--- */	#define	GET32DRMWMFilter_isKSeedOK(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_isKSeedOK(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_isKSeedOK(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_isKSeedOK(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMWMFilter_D33th_ 		ISC_USE_ONLY	0x00084
	#define	w32DRMWMFilter_D33th_ 		{										\
					UNSG32				u_pbDESCtx					 : 16;		\
					UNSG32				u_reserved					 : 16;		\
										}
	/* @'00084 */				struct	w32DRMWMFilter_D33th_;

	/* [15: 0] */	#define	  BA_DRMWMFilter_pbDESCtx				 0x00084
	/* ---:--- */	#define	    bDRMWMFilter_pbDESCtx				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_pbDESCtx				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMWMFilter_pbDESCtx				       0x0000FFFF
	/* ---:--- */	#define	GET32DRMWMFilter_pbDESCtx(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_pbDESCtx(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_pbDESCtx(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_pbDESCtx(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMWMFilter_reserved				 0x00086
	/* ---:--- */	#define	    bDRMWMFilter_reserved				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMWMFilter_reserved				   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMWMFilter_reserved				       0xFFFF0000
	/* ---:--- */	#define	GET32DRMWMFilter_reserved(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMWMFilter_reserved(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMWMFilter_reserved(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMWMFilter_reserved(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_DRMWMFilter;

	#define	dftDRMWMFilter_HDR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMWMFilter_HDR;
										} T32DRMWMFilter_HDR;
	#define	dftDRMWMFilter_IO 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMWMFilter_IO;
										} T32DRMWMFilter_IO;
	#define	dftDRMWMFilter_CTR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMWMFilter_CTR;
										} T32DRMWMFilter_CTR;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMWMFilter_drvrd (SIE_DRMWMFilter *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMWMFilter_drvwr (SIE_DRMWMFilter *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMWMFilter_reset (SIE_DRMWMFilter *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMWMFilter_check(p,pie,ps8name,hfpErrLOG)		DRMWMFilter_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMWMFilter_print(p,    ps8name,hfpErrLOG)		DRMWMFilter_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMWMFilter_cmp   (SIE_DRMWMFilter *p, SIE_DRMWMFilter *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMWMFilter_import(SIE_DRMWMFilter *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMWMFilter_export(SIE_DRMWMFilter *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMWMFilter
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMDiagWMFilterCtx
*	@  DAT_START
*		$UINT128  datStart  REG
*		$UINT64  dsCmdFifo  REG  [16]
*						*  *
*						*  Data streamer command FIFO
*		$UINT128  blkStart  REG
*						*  *
*						*  Transfer Data Area
*	@  0x2000  LA_START
*		$LocalArea  la
*						*  *
*						*  Local area
*	@  CTX_START
*		$DTCMBlkPool  datInMemPool
*						*  *
*						*  Data memory pool
*		$DTCMBlkPool  datOutMemPool
*						*  *
*						*  Data memory pool
*	@  STREAMS
*		$DSStreamIn  datStrmIn  REG  [2]
*						*  *
*						*  DS Input stream
*		$CtrlFIFOData  datCtrlFifo  REG  [2]
*						*  *
*						*  Control FIFO data
*		$KeySeedData  keySeedFifo  REG  [2]
*						*  *
*						*  Key Seed FIFO data
*		$DSStreamOut  datStrmOut  REG  [2]
*						*  *
*						*  DS Ouput stream
*		$DSStreamOutModule  datStrmOutModule
*	@  FILTERS
*		$DRMWMFilter  wmFilterList  REG  [1]
*						*  *
*						*  Blue Ray DVD Context
*		$UINT128  datFilterBuf  REG  [16]
*						*  *
*						*  Temp buffer for Filter data
*		$UINT128  ctrlFilterBuf  REG  [8]
*						*  *
*						*  Temp buffer for Filter Control
*	@
*		$RC4_CTXDAT  rc4Ctx
*						*  *
*						*  RC4 Context
*	@
*		$DES_CTXDAT  desCtx
*						*  *
*						*  DES Context
*	@
*		$CBCMAC_CTXDAT  cbcCtx
*						*  *
*						*  CBC MAC Context
*	@  DTCMSIZE
*		%unsigned  16  uTotalSize  REG
*	@
*		%unsigned  16  padding  REG  [5]
*	@  IMG_END
*		$UINT128  resserved  REG
**********************************************************************************************************************/
#ifdef	h_DRMDiagWMFilterCtx
#else
#define	h_DRMDiagWMFilterCtx

#define	\
	AR_DRMDiagWMFilterCtx \
		3630
#define	\
	AB_DRMDiagWMFilterCtx \
		14

typedef struct SIE_DRMDiagWMFilterCtx {

	#define	RA_DRMDiagWMFilterCtx_DAT_START 0x00000
	/* @'00000 */	SIE_UINT128 				ie_datStart;

	#define	RA_DRMDiagWMFilterCtx_dsCmdFifo 0x00010
	/* @'00010 */	SIE_UINT64 					ie_dsCmdFifo		 [16];
					#define	 arr_DRMDiagWMFilterCtx_dsCmdFifo 		  16

	#define	RA_DRMDiagWMFilterCtx_blkStart 0x00090
	/* @'00090 */	SIE_UINT128 				ie_blkStart;

	UNSG32	_PAD_000[(0x02000-0x000A0)/4];
	#define	RA_DRMDiagWMFilterCtx_LA_START 0x02000
	/* @'02000 */	SIE_LocalArea 				ie_la;

	#define	RA_DRMDiagWMFilterCtx_CTX_START 0x02228
	/* @'02228 */	SIE_DTCMBlkPool 			ie_datInMemPool;

	#define	RA_DRMDiagWMFilterCtx_datOutMemPool 0x02350
	/* @'02350 */	SIE_DTCMBlkPool 			ie_datOutMemPool;

	#define	RA_DRMDiagWMFilterCtx_STREAMS 0x02478
	/* @'02478 */	SIE_DSStreamIn 				ie_datStrmIn		 [2];
					#define	 arr_DRMDiagWMFilterCtx_datStrmIn 		  2

	#define	RA_DRMDiagWMFilterCtx_datCtrlFifo 0x02508
	/* @'02508 */	SIE_CtrlFIFOData 			ie_datCtrlFifo		 [2];
					#define	 arr_DRMDiagWMFilterCtx_datCtrlFifo 	  2

	#define	RA_DRMDiagWMFilterCtx_keySeedFifo 0x02588
	/* @'02588 */	SIE_KeySeedData 			ie_keySeedFifo		 [2];
					#define	 arr_DRMDiagWMFilterCtx_keySeedFifo 	  2

	#define	RA_DRMDiagWMFilterCtx_datStrmOut 0x02608
	/* @'02608 */	SIE_DSStreamOut 			ie_datStrmOut		 [2];
					#define	 arr_DRMDiagWMFilterCtx_datStrmOut 		  2

	#define	RA_DRMDiagWMFilterCtx_datStrmOutModule 0x02638
	/* @'02638 */	SIE_DSStreamOutModule 		ie_datStrmOutModule;

	#define	RA_DRMDiagWMFilterCtx_FILTERS 0x02650
	/* @'02650 */	SIE_DRMWMFilter 			ie_wmFilterList;

	#define	RA_DRMDiagWMFilterCtx_datFilterBuf 0x026D8
	/* @'026D8 */	SIE_UINT128 				ie_datFilterBuf		 [16];
					#define	 arr_DRMDiagWMFilterCtx_datFilterBuf 	  16

	#define	RA_DRMDiagWMFilterCtx_ctrlFilterBuf 0x027D8
	/* @'027D8 */	SIE_UINT128 				ie_ctrlFilterBuf	 [8];
					#define	 arr_DRMDiagWMFilterCtx_ctrlFilterBuf 	  8

	#define	RA_DRMDiagWMFilterCtx_rc4Ctx 0x02858
	/* @'02858 */	SIE_RC4_CTXDAT 				ie_rc4Ctx;

	#define	RA_DRMDiagWMFilterCtx_desCtx 0x02A60
	/* @'02A60 */	SIE_DES_CTXDAT 				ie_desCtx;

	#define	RA_DRMDiagWMFilterCtx_cbcCtx 0x035D8
	/* @'035D8 */	SIE_CBCMAC_CTXDAT 			ie_cbcCtx;

	#define	RA_DRMDiagWMFilterCtx_DTCMSIZE 0x03898
	#define	w32DRMDiagWMFilterCtx_DTCMSIZE {									\
					UNSG32				uDTCMSIZE_uTotalSize		 : 16;		\
					UNSG32				_x03898	: 16;							\
										}
	/* @'03898 */	union {	UNSG32		u32DRMDiagWMFilterCtx_DTCMSIZE;
								struct	w32DRMDiagWMFilterCtx_DTCMSIZE;
										};

	/* [15: 0] */	#define	  BA_DRMDiagWMFilterCtx_DTCMSIZE_uTotalSize 0x03898
	/* ---:--- */	#define	    bDRMDiagWMFilterCtx_DTCMSIZE_uTotalSize   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMDiagWMFilterCtx_DTCMSIZE_uTotalSize    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMDiagWMFilterCtx_DTCMSIZE_uTotalSize       0x0000FFFF
	/* ---:--- */	#define	GET32DRMDiagWMFilterCtx_DTCMSIZE_uTotalSize(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMDiagWMFilterCtx_DTCMSIZE_uTotalSize(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMDiagWMFilterCtx_DTCMSIZE_uTotalSize(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMDiagWMFilterCtx_DTCMSIZE_uTotalSize(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMDiagWMFilterCtx_D3623th_ ISC_USE_ONLY	0x0389C
	#define	w32DRMDiagWMFilterCtx_D3623th_ {									\
					UNSG32				u_padding_0i				 : 16;		\
					UNSG32				u_padding_1i				 : 16;		\
										}
	/* @'0389C */				struct	w32DRMDiagWMFilterCtx_D3623th_;

	/* [15: 0] */	#define	  BA_DRMDiagWMFilterCtx_padding_0i		 0x0389C
	/* ---:--- */	#define	    bDRMDiagWMFilterCtx_padding_0i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMDiagWMFilterCtx_padding_0i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMDiagWMFilterCtx_padding_0i		       0x0000FFFF
	/* ---:--- */	#define	GET32DRMDiagWMFilterCtx_padding_0i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMDiagWMFilterCtx_padding_0i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMDiagWMFilterCtx_padding_0i(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMDiagWMFilterCtx_padding_0i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMDiagWMFilterCtx_padding_1i		 0x0389E
	/* ---:--- */	#define	    bDRMDiagWMFilterCtx_padding_1i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMDiagWMFilterCtx_padding_1i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMDiagWMFilterCtx_padding_1i		       0xFFFF0000
	/* ---:--- */	#define	GET32DRMDiagWMFilterCtx_padding_1i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMDiagWMFilterCtx_padding_1i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMDiagWMFilterCtx_padding_1i(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMDiagWMFilterCtx_padding_1i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMDiagWMFilterCtx_D3624th_ ISC_USE_ONLY	0x038A0
	#define	w32DRMDiagWMFilterCtx_D3624th_ {									\
					UNSG32				u_padding_2i				 : 16;		\
					UNSG32				u_padding_3i				 : 16;		\
										}
	/* @'038A0 */				struct	w32DRMDiagWMFilterCtx_D3624th_;

	/* [15: 0] */	#define	  BA_DRMDiagWMFilterCtx_padding_2i		 0x038A0
	/* ---:--- */	#define	    bDRMDiagWMFilterCtx_padding_2i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMDiagWMFilterCtx_padding_2i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMDiagWMFilterCtx_padding_2i		       0x0000FFFF
	/* ---:--- */	#define	GET32DRMDiagWMFilterCtx_padding_2i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMDiagWMFilterCtx_padding_2i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMDiagWMFilterCtx_padding_2i(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMDiagWMFilterCtx_padding_2i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRMDiagWMFilterCtx_padding_3i		 0x038A2
	/* ---:--- */	#define	    bDRMDiagWMFilterCtx_padding_3i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMDiagWMFilterCtx_padding_3i		   16 /*:31*/
	/* ---:--- */	#define	MSK32DRMDiagWMFilterCtx_padding_3i		       0xFFFF0000
	/* ---:--- */	#define	GET32DRMDiagWMFilterCtx_padding_3i(r32)		 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRMDiagWMFilterCtx_padding_3i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMDiagWMFilterCtx_padding_3i(r32,v)	do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRMDiagWMFilterCtx_padding_3i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMDiagWMFilterCtx_D3625th_ ISC_USE_ONLY	0x038A4
	#define	w32DRMDiagWMFilterCtx_D3625th_ {									\
					UNSG32				u_padding_4i				 : 16;		\
					UNSG32				_x038A4	: 16;							\
										}
	/* @'038A4 */				struct	w32DRMDiagWMFilterCtx_D3625th_;

	/* [15: 0] */	#define	  BA_DRMDiagWMFilterCtx_padding_4i		 0x038A4
	/* ---:--- */	#define	    bDRMDiagWMFilterCtx_padding_4i		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRMDiagWMFilterCtx_padding_4i		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRMDiagWMFilterCtx_padding_4i		       0x0000FFFF
	/* ---:--- */	#define	GET32DRMDiagWMFilterCtx_padding_4i(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRMDiagWMFilterCtx_padding_4i(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRMDiagWMFilterCtx_padding_4i(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMDiagWMFilterCtx_padding_4i(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRMDiagWMFilterCtx_IMG_END 0x038A8
	/* @'038A8 */	SIE_UINT128 				ie_resserved;

} SIE_DRMDiagWMFilterCtx;

	#define	dftDRMDiagWMFilterCtx_DTCMSIZE 0x0000CCCC
			typedef	union {	UNSG32		u32;
								struct	w32DRMDiagWMFilterCtx_DTCMSIZE;
										} T32DRMDiagWMFilterCtx_DTCMSIZE;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMDiagWMFilterCtx_drvrd (SIE_DRMDiagWMFilterCtx *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMDiagWMFilterCtx_drvwr (SIE_DRMDiagWMFilterCtx *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMDiagWMFilterCtx_reset (SIE_DRMDiagWMFilterCtx *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMDiagWMFilterCtx_check(p,pie,ps8name,hfpErrLOG)		DRMDiagWMFilterCtx_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMDiagWMFilterCtx_print(p,    ps8name,hfpErrLOG)		DRMDiagWMFilterCtx_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMDiagWMFilterCtx_cmp   (SIE_DRMDiagWMFilterCtx *p, SIE_DRMDiagWMFilterCtx *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMDiagWMFilterCtx_import(SIE_DRMDiagWMFilterCtx *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMDiagWMFilterCtx_export(SIE_DRMDiagWMFilterCtx *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMDiagWMFilterCtx
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: ROM_RSAK_CTX
*	@
*		$UINT128  rsaPubKey  REG  [4]
*	@
*		$UINT128  rsaMod  REG  [8]
**********************************************************************************************************************/
#ifdef	h_ROM_RSAK_CTX
#else
#define	h_ROM_RSAK_CTX

#define	\
	AR_ROM_RSAK_CTX \
		48
#define	\
	AB_ROM_RSAK_CTX \
		8

typedef struct SIE_ROM_RSAK_CTX {

	#define	RA_ROM_RSAK_CTX_rsaPubKey 	0x00000
	/* @'00000 */	SIE_UINT128 				ie_rsaPubKey		 [4];
					#define	 arr_ROM_RSAK_CTX_rsaPubKey 			  4

	#define	RA_ROM_RSAK_CTX_rsaMod 		0x00040
	/* @'00040 */	SIE_UINT128 				ie_rsaMod			 [8];
					#define	 arr_ROM_RSAK_CTX_rsaMod 				  8

} SIE_ROM_RSAK_CTX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	ROM_RSAK_CTX_drvrd (SIE_ROM_RSAK_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	ROM_RSAK_CTX_drvwr (SIE_ROM_RSAK_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	ROM_RSAK_CTX_reset (SIE_ROM_RSAK_CTX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	ROM_RSAK_CTX_check(p,pie,ps8name,hfpErrLOG)		ROM_RSAK_CTX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	ROM_RSAK_CTX_print(p,    ps8name,hfpErrLOG)		ROM_RSAK_CTX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	ROM_RSAK_CTX_cmp   (SIE_ROM_RSAK_CTX *p, SIE_ROM_RSAK_CTX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	ROM_RSAK_CTX_import(SIE_ROM_RSAK_CTX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	ROM_RSAK_CTX_export(SIE_ROM_RSAK_CTX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: ROM_RSAK_CTX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_BG2_DROM
*	@
*		$AES128_RODAT  aesROData
*						*  *
*						*  AES 128 bits algorithm specific read only data
*	@
*		$HAMMING_RODAT  hamming64RODat
*						*  *
*						*  Hamming 64-7 tables
*	@
*		$CRC32_RODAT  crc32ROData
*						*  *
*						*  CRC32 algorithm specific read only data
*	@
*		$SHA1_RODAT  sha1ROData
*						*  *
*						*  SHA-1 algorithm specific read only data
*	@
*		$RSA_RODAT  rsaROData
*						*  *
*						*  RSA algorithm specific read only data
*	@
*		$UINT128  aesROMKey  REG  [64]
*						*  *
*						*  AES ROM Key data
*						*  Only support 32 ROM AES Key.
*	@
*		$ROM_RSAK_CTX  rsaROMKey  REG  [2]
*						*  *
*						*  ROM RSA Key data
**********************************************************************************************************************/
#ifdef	h_DRM_BG2_DROM
#else
#define	h_DRM_BG2_DROM

#define	\
	AR_DRM_BG2_DROM \
		1812
#define	\
	AB_DRM_BG2_DROM \
		13

typedef struct SIE_DRM_BG2_DROM {

	#define	RA_DRM_BG2_DROM_aesROData 	0x00000
	/* @'00000 */	SIE_AES128_RODAT 			ie_aesROData;

	#define	RA_DRM_BG2_DROM_hamming64RODat 0x00810
	/* @'00810 */	SIE_HAMMING_RODAT 			ie_hamming64RODat;

	#define	RA_DRM_BG2_DROM_crc32ROData 0x00B50
	/* @'00B50 */	SIE_CRC32_RODAT 			ie_crc32ROData;

	#define	RA_DRM_BG2_DROM_sha1ROData 	0x00C90
	/* @'00C90 */	SIE_SHA1_RODAT 				ie_sha1ROData;

	#define	RA_DRM_BG2_DROM_rsaROData 	0x01590
	/* @'01590 */	SIE_RSA_RODAT 				ie_rsaROData;

	#define	RA_DRM_BG2_DROM_aesROMKey 	0x016D0
	/* @'016D0 */	SIE_UINT128 				ie_aesROMKey		 [64];
					#define	 arr_DRM_BG2_DROM_aesROMKey 			  64

	#define	RA_DRM_BG2_DROM_rsaROMKey 	0x01AD0
	/* @'01AD0 */	SIE_ROM_RSAK_CTX 			ie_rsaROMKey		 [2];
					#define	 arr_DRM_BG2_DROM_rsaROMKey 			  2

} SIE_DRM_BG2_DROM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_BG2_DROM_drvrd (SIE_DRM_BG2_DROM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_BG2_DROM_drvwr (SIE_DRM_BG2_DROM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_BG2_DROM_reset (SIE_DRM_BG2_DROM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_BG2_DROM_check(p,pie,ps8name,hfpErrLOG)		DRM_BG2_DROM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_BG2_DROM_print(p,    ps8name,hfpErrLOG)		DRM_BG2_DROM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_BG2_DROM_cmp   (SIE_DRM_BG2_DROM *p, SIE_DRM_BG2_DROM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_BG2_DROM_import(SIE_DRM_BG2_DROM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_BG2_DROM_export(SIE_DRM_BG2_DROM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_BG2_DROM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CUSTKEY_CTX
*	@
*		$UINT128  custKheader
*	@
*		$UINT128  aesCustKey  REG  [2]
*	@
*		$UINT128  rsaCustKey  REG  [12]
*						*  *
*						*  CUST RSA key's PUB + MOD
**********************************************************************************************************************/
#ifdef	h_CUSTKEY_CTX
#else
#define	h_CUSTKEY_CTX

#define	\
	AR_CUSTKEY_CTX \
		60
#define	\
	AB_CUSTKEY_CTX \
		8

typedef struct SIE_CUSTKEY_CTX {

	#define	RA_CUSTKEY_CTX_custKheader 	0x00000
	/* @'00000 */	SIE_UINT128 				ie_custKheader;

	#define	RA_CUSTKEY_CTX_aesCustKey 	0x00010
	/* @'00010 */	SIE_UINT128 				ie_aesCustKey		 [2];
					#define	 arr_CUSTKEY_CTX_aesCustKey 			  2

	#define	RA_CUSTKEY_CTX_rsaCustKey 	0x00030
	/* @'00030 */	SIE_UINT128 				ie_rsaCustKey		 [12];
					#define	 arr_CUSTKEY_CTX_rsaCustKey 			  12

} SIE_CUSTKEY_CTX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CUSTKEY_CTX_drvrd (SIE_CUSTKEY_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CUSTKEY_CTX_drvwr (SIE_CUSTKEY_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CUSTKEY_CTX_reset (SIE_CUSTKEY_CTX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CUSTKEY_CTX_check(p,pie,ps8name,hfpErrLOG)		CUSTKEY_CTX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CUSTKEY_CTX_print(p,    ps8name,hfpErrLOG)		CUSTKEY_CTX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CUSTKEY_CTX_cmp   (SIE_CUSTKEY_CTX *p, SIE_CUSTKEY_CTX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CUSTKEY_CTX_import(SIE_CUSTKEY_CTX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CUSTKEY_CTX_export(SIE_CUSTKEY_CTX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CUSTKEY_CTX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CUSTKEY_MAGICNUM
*	@  DAT
*		%unsigned  16  ID
*			:  magicA  0x00de
*			:  magicB  0x0088
*			:  magicC  0x00de
*			:  magicD  0x0088
**********************************************************************************************************************/
#ifdef	h_CUSTKEY_MAGICNUM
#else
#define	h_CUSTKEY_MAGICNUM

#define	\
	AR_CUSTKEY_MAGICNUM \
		1
#define	\
	AB_CUSTKEY_MAGICNUM \
		2

typedef struct SIE_CUSTKEY_MAGICNUM {

	#define	RA_CUSTKEY_MAGICNUM_DAT 	0x00000
	#define	w32CUSTKEY_MAGICNUM_DAT 	{										\
					UNSG32				uDAT_ID						 : 16;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */	union {	UNSG32		u32CUSTKEY_MAGICNUM_DAT;
								struct	w32CUSTKEY_MAGICNUM_DAT;
										};

	/* [15: 0] */	#define	  BA_CUSTKEY_MAGICNUM_DAT_ID			 0x00000
	/* ---:--- */	#define	    bCUSTKEY_MAGICNUM_DAT_ID			   16 /*bit*/
	/* ---:--- */	#define	LSb32CUSTKEY_MAGICNUM_DAT_ID			    0 /*:15*/
	/* ---:--- */	#define	MSK32CUSTKEY_MAGICNUM_DAT_ID			       0x0000FFFF
	/* ---:--- */	#define	GET32CUSTKEY_MAGICNUM_DAT_ID(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16CUSTKEY_MAGICNUM_DAT_ID(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32CUSTKEY_MAGICNUM_DAT_ID(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CUSTKEY_MAGICNUM_DAT_ID(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)
					#define	     CUSTKEY_MAGICNUM_DAT_ID_magicA				0xDE
					#define	     CUSTKEY_MAGICNUM_DAT_ID_magicB				0x88
					#define	     CUSTKEY_MAGICNUM_DAT_ID_magicC				0xDE
					#define	     CUSTKEY_MAGICNUM_DAT_ID_magicD				0x88

} SIE_CUSTKEY_MAGICNUM;

	#define	dftCUSTKEY_MAGICNUM_DAT 	0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CUSTKEY_MAGICNUM_DAT;
										} T32CUSTKEY_MAGICNUM_DAT;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CUSTKEY_MAGICNUM_drvrd (SIE_CUSTKEY_MAGICNUM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CUSTKEY_MAGICNUM_drvwr (SIE_CUSTKEY_MAGICNUM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CUSTKEY_MAGICNUM_reset (SIE_CUSTKEY_MAGICNUM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CUSTKEY_MAGICNUM_check(p,pie,ps8name,hfpErrLOG)		CUSTKEY_MAGICNUM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CUSTKEY_MAGICNUM_print(p,    ps8name,hfpErrLOG)		CUSTKEY_MAGICNUM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CUSTKEY_MAGICNUM_cmp   (SIE_CUSTKEY_MAGICNUM *p, SIE_CUSTKEY_MAGICNUM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CUSTKEY_MAGICNUM_import(SIE_CUSTKEY_MAGICNUM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CUSTKEY_MAGICNUM_export(SIE_CUSTKEY_MAGICNUM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CUSTKEY_MAGICNUM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: BG2_SIGNK_CTX
*	@
*		$UINT128  rsaKeyPub  REG  [8]
*	@
*		$UINT128  rsaKeyMod  REG  [8]
**********************************************************************************************************************/
#ifdef	h_BG2_SIGNK_CTX
#else
#define	h_BG2_SIGNK_CTX

#define	\
	AR_BG2_SIGNK_CTX \
		64
#define	\
	AB_BG2_SIGNK_CTX \
		8

typedef struct SIE_BG2_SIGNK_CTX {

	#define	RA_BG2_SIGNK_CTX_rsaKeyPub 	0x00000
	/* @'00000 */	SIE_UINT128 				ie_rsaKeyPub		 [8];
					#define	 arr_BG2_SIGNK_CTX_rsaKeyPub 			  8

	#define	RA_BG2_SIGNK_CTX_rsaKeyMod 	0x00080
	/* @'00080 */	SIE_UINT128 				ie_rsaKeyMod		 [8];
					#define	 arr_BG2_SIGNK_CTX_rsaKeyMod 			  8

} SIE_BG2_SIGNK_CTX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	BG2_SIGNK_CTX_drvrd (SIE_BG2_SIGNK_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	BG2_SIGNK_CTX_drvwr (SIE_BG2_SIGNK_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	BG2_SIGNK_CTX_reset (SIE_BG2_SIGNK_CTX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	BG2_SIGNK_CTX_check(p,pie,ps8name,hfpErrLOG)		BG2_SIGNK_CTX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	BG2_SIGNK_CTX_print(p,    ps8name,hfpErrLOG)		BG2_SIGNK_CTX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	BG2_SIGNK_CTX_cmp   (SIE_BG2_SIGNK_CTX *p, SIE_BG2_SIGNK_CTX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	BG2_SIGNK_CTX_import(SIE_BG2_SIGNK_CTX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	BG2_SIGNK_CTX_export(SIE_BG2_SIGNK_CTX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: BG2_SIGNK_CTX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_BG2_SRAM
*	@
*		$DRMROM_CMD  cmd
*						*  *
*						*  ROM code command and response buffer
*	@
*		$LocalArea  la
*						*  *
*						*  Local data area
*	@
*		$UINT64  dsFifoDat  REG  [16]
*						*  *
*						*  Data streamer fifo data
*	@
*		$DRM_SYMKEYCTX256_IN  symSignKey
*						*  *
*						*  AES128 based symmetric signature key context
*	@
*		$DRM_RSAKEYCTX1024_IN  asymSignKey
*						*  *
*						*  RSA1024 based asymmetric signature key context
*	@
*		$DRM_SYMKEYCTX256_IN  aesRKEK
*						*  *
*						*  AES128 RKEK key context
*	@
*		$DRM_SYMKEYCTX256_IN  aesSubKey
*						*  *
*						*  AES128 sub key context
*	@
*		$UINT128  rndKeyBuf  REG  [16]
*						*  *
*						*  Temporary buffer for round keys
*	@
*		$UINT32  imgHdrInfo  REG  [32]
*						*  *
*						*  Stored image header information
*	@
*		$UINT32  authDatCtx  REG  [32]
*						*  *
*						*  Stored image header information
*	@
*		$UINT64  otpBits  REG  [64]
*						*  *
*						*  All OTP bits
*	@
*		$BG2_OTP_CRC32  otpCrc32
*						*  *
*						*  OTP CRC32 value for three regions of OTP data
*	@
*		$UINT64  OtpTestBits  REG  [2]
*						*  *
*						*  Content for the first redundant column
*	@
*		$UINT64  otpSecBits
*						*  *
*						*  Otp Security Bits
*	@
*		$BG2_OTP_STATUS  otpStatus
*						*  *
*						*  All OTP bits
*	@
*		$UINT32  padding4ShaCtx
*						*  *
*						*  Padding for SHA-1 Ctx. SHA CTX should be 64-bit alignment.
*	@
*		$UINT64  otpBlankFlag
*						*  *
*						*  Bit mask flag for each entry. If bit[n]=1, entry[n] is not blank. If bit[n]=0, entry[n] is blank.
*	@
*		$SHA1_CTXDAT  shaCtx
*						*  *
*						*  SHA1 Context for RSA PSS signature verification
*	@
*		$CUSTKEY_CTX  custKeyCtx
*						*  *
*						*  AES Cust Key data
*	@
*		$UINT64  stageFlag
*						*  *
*						*  Stage flag to trace whether the H/W register setting is done or not
*	@
*		$RSA_CTXDAT  rsaCtx
*						*  *
*						*  RSA Context for RSA PSS signature verification
*	@
*		$UINT64  isIMG2
*						*  *
*						*  Flag to indicate the image's type. If the isIMG2 =1, the image to be loaded is IMG2, otherwise, it is a normal ARM image
*	@
*		$UINT128  bufTmp  MEM
*						*  *
*						*  Temporary Buffer
*	@  0x0ff0
*		$UINT128  stack
*						*  *
*						*  Stack
*	@  0x1000
*		$UINT128  dsTransBuf  REG  [256]
*						*  *
*						*  Transfer memory
**********************************************************************************************************************/
#ifdef	h_DRMROM_BG2_SRAM
#else
#define	h_DRMROM_BG2_SRAM

#define	\
	AR_DRMROM_BG2_SRAM \
		2048
#define	\
	AB_DRMROM_BG2_SRAM \
		13

typedef struct SIE_DRMROM_BG2_SRAM {

	#define	RA_DRMROM_BG2_SRAM_cmd 		0x00000
	/* @'00000 */	SIE_DRMROM_CMD 				ie_cmd;

	#define	RA_DRMROM_BG2_SRAM_la 		0x00028
	/* @'00028 */	SIE_LocalArea 				ie_la;

	#define	RA_DRMROM_BG2_SRAM_dsFifoDat 0x00250
	/* @'00250 */	SIE_UINT64 					ie_dsFifoDat		 [16];
					#define	 arr_DRMROM_BG2_SRAM_dsFifoDat 			  16

	#define	RA_DRMROM_BG2_SRAM_symSignKey 0x002D0
	/* @'002D0 */	SIE_DRM_SYMKEYCTX256_IN 	ie_symSignKey;

	#define	RA_DRMROM_BG2_SRAM_asymSignKey 0x00330
	/* @'00330 */	SIE_DRM_RSAKEYCTX1024_IN 	ie_asymSignKey;

	#define	RA_DRMROM_BG2_SRAM_aesRKEK 	0x003E0
	/* @'003E0 */	SIE_DRM_SYMKEYCTX256_IN 	ie_aesRKEK;

	#define	RA_DRMROM_BG2_SRAM_aesSubKey 0x00440
	/* @'00440 */	SIE_DRM_SYMKEYCTX256_IN 	ie_aesSubKey;

	#define	RA_DRMROM_BG2_SRAM_rndKeyBuf 0x004A0
	/* @'004A0 */	SIE_UINT128 				ie_rndKeyBuf		 [16];
					#define	 arr_DRMROM_BG2_SRAM_rndKeyBuf 			  16

	#define	RA_DRMROM_BG2_SRAM_imgHdrInfo 0x005A0
	/* @'005A0 */	SIE_UINT32 					ie_imgHdrInfo		 [32];
					#define	 arr_DRMROM_BG2_SRAM_imgHdrInfo 		  32

	#define	RA_DRMROM_BG2_SRAM_authDatCtx 0x00620
	/* @'00620 */	SIE_UINT32 					ie_authDatCtx		 [32];
					#define	 arr_DRMROM_BG2_SRAM_authDatCtx 		  32

	#define	RA_DRMROM_BG2_SRAM_otpBits 	0x006A0
	/* @'006A0 */	SIE_UINT64 					ie_otpBits			 [64];
					#define	 arr_DRMROM_BG2_SRAM_otpBits 			  64

	#define	RA_DRMROM_BG2_SRAM_otpCrc32 0x008A0
	/* @'008A0 */	SIE_BG2_OTP_CRC32 			ie_otpCrc32;

	#define	RA_DRMROM_BG2_SRAM_OtpTestBits 0x008B0
	/* @'008B0 */	SIE_UINT64 					ie_OtpTestBits		 [2];
					#define	 arr_DRMROM_BG2_SRAM_OtpTestBits 		  2

	#define	RA_DRMROM_BG2_SRAM_otpSecBits 0x008C0
	/* @'008C0 */	SIE_UINT64 					ie_otpSecBits;

	#define	RA_DRMROM_BG2_SRAM_otpStatus 0x008C8
	/* @'008C8 */	SIE_BG2_OTP_STATUS 			ie_otpStatus;

	#define	RA_DRMROM_BG2_SRAM_padding4ShaCtx 0x008CC
	/* @'008CC */	SIE_UINT32 					ie_padding4ShaCtx;

	#define	RA_DRMROM_BG2_SRAM_otpBlankFlag 0x008D0
	/* @'008D0 */	SIE_UINT64 					ie_otpBlankFlag;

	#define	RA_DRMROM_BG2_SRAM_shaCtx 	0x008D8
	/* @'008D8 */	SIE_SHA1_CTXDAT 			ie_shaCtx;

	#define	RA_DRMROM_BG2_SRAM_custKeyCtx 0x00938
	/* @'00938 */	SIE_CUSTKEY_CTX 			ie_custKeyCtx;

	#define	RA_DRMROM_BG2_SRAM_stageFlag 0x00A28
	/* @'00A28 */	SIE_UINT64 					ie_stageFlag;

	#define	RA_DRMROM_BG2_SRAM_rsaCtx 	0x00A30
	/* @'00A30 */	SIE_RSA_CTXDAT 				ie_rsaCtx;

	#define	RA_DRMROM_BG2_SRAM_isIMG2 	0x00EB8
	/* @'00EB8 */	SIE_UINT64 					ie_isIMG2;

	#define	RA_DRMROM_BG2_SRAM_bufTmp 	0x00EC0
	/* @'00EC0 */	SIE_UINT128 				ie_bufTmp;

	UNSG32	_PAD_000[(0x00FF0-0x00ED0)/4];
	#define	RA_DRMROM_BG2_SRAM_stack 	0x00FF0
	/* @'00FF0 */	SIE_UINT128 				ie_stack;

	#define	RA_DRMROM_BG2_SRAM_dsTransBuf 0x01000
	/* @'01000 */	SIE_UINT128 				ie_dsTransBuf		 [256];
					#define	 arr_DRMROM_BG2_SRAM_dsTransBuf 		  256

} SIE_DRMROM_BG2_SRAM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_BG2_SRAM_drvrd (SIE_DRMROM_BG2_SRAM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_BG2_SRAM_drvwr (SIE_DRMROM_BG2_SRAM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_BG2_SRAM_reset (SIE_DRMROM_BG2_SRAM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_BG2_SRAM_check(p,pie,ps8name,hfpErrLOG)		DRMROM_BG2_SRAM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_BG2_SRAM_print(p,    ps8name,hfpErrLOG)		DRMROM_BG2_SRAM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_BG2_SRAM_cmp   (SIE_DRMROM_BG2_SRAM *p, SIE_DRMROM_BG2_SRAM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_BG2_SRAM_import(SIE_DRMROM_BG2_SRAM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_BG2_SRAM_export(SIE_DRMROM_BG2_SRAM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_BG2_SRAM
**********************************************************************************************************************/



#pragma	pack()

#ifdef	__cplusplus
	}
#endif

#endif	/* _drm_sw_spec_h */
/**********************************************************************************************************************
*	ENDOFFILE (by "Interface Specification Compiler" ver-1.0): drm_sw_spec.h
**********************************************************************************************************************/

