/**********************************************************************************************************************
*	DO NOT EDIT! Automatically generated by "Interface Specification Compiler" ver-1.0
*			<ansi-c> :    avioDmaReg.h
**********************************************************************************************************************/
#ifdef	_avioDmaReg_h
#else
#define	_avioDmaReg_h					"       avioDmaReg_h >>>    "
#include	"ctypes.h"

#pragma	pack(4)

#ifdef	__cplusplus
	extern	"C"
	{
#endif



/**********************************************************************************************************************
*	INTERFACE: CH
*	`  Defines the Registers common to all types of Channels.
*	@  CTRL  (P)
*	`  Defines the various control bits associated with a Channel.
*			%unsigned  1  CPR  0
*						*  					*  *
*						*  					*  Channel Priority. 1 – High, 0 – Low.
*						*  					*  Priority Encoding – 2-level priority, with round-robin in the same level.
*			%unsigned  1  FLUSH  0
*						*  					*  *
*						*  					*  Channel FIFO Flush.
*						*  					*  Stop the channel as soon as the current data in the channel FIFO is transfered out. DMA clears the FLUSH bit as soon as it finishes the flush process.
*						*  					*  Flush procedure:-
*						*  					*  1. Disable the connection to source Hardware Device (by writing to HW_CTRL register) in case of H2M, and H2H channels.
*						*  					*  *Set CH_CTRL.FLUSH
*						*  					*  *Poll for CH_INTSTS.DONE bit
*						*  					*  *Clear CH_CTRL.FLUSH
*						*  					*  NOT IMPLEMNTED.
*			%unsigned  1  DISCARD  0
*						*  					*  *
*						*  					*  Channel FIFO Discard.
*						*  					*  Stop the channel as soon as possible. Data in channel FIFO may be lost when DISCARD is issued. DMA clears the DISCARD bit as soon as it finishes the discard process.
*						*  					*  Discard procedure:-
*						*  					*  1. Disable the connection to source Hardware Device (by writing to HW_CTRL register) in case of H2M, and H2H channels.
*						*  					*  2. Set CH_CTRL.DISCARD
*						*  					*  *Poll for CH_INTSTS.DONE bit
*						*  					*  *Clear CH_CTRL.DISCARD
*						*  					*  DMA makes sure that there are no pending transactions on OCPf, and AXI bus for this channel before executing the discard.
*	@  STS  (R)
*	`  Contains the various status bits associated with a channel
*			%unsigned  3  CTYPE  0
*					:  M2M  0
*					:  M2H  1
*					:  H2M  2
*					:  H2H  3
*					:  C2M  4
*					:  M2C  5
*						*  					*  *
*						*  					*  The configured Channel Type. Read only field indicating the design-configured channel type.
*						*  					*  0x0 – Memory to Memory (M2M)
*						*  					*  0x1 – Memory to Hardware (M2H)
*						*  					*  0x2 – Hardware to Memory (H2M)
*						*  					*  0x3 – Hardware to Hardware (H2H)
*						*  					*  0x4 - CPU to Memory (C2M)1
*						*  					*  0x5 – Memory to CPU (M2C)2
*						*  					*  Note: 1) C2M is same as H2M with no hardware device attached to the channel
*						*  					*  2) M2C is same as M2H with no hardware device attached to the channel.
*						*  					*  C2M, and M2C are not supported for TC1.
*			%unsigned  1  EMPTY  1
*						*  					*  *
*						*  					*  Channel FIFO empty status
*						*  					*  1 – Channel FIFO is empty
*						*  					*  0 – Channel FIFO is not empty
*			%unsigned  1  FULL  0
*						*  					*  *
*						*  					*  Channel FIFO full status
*						*  					*  1 – Channel FIFO is full
*						*  					*  0 – Channel FIFO is not full
*	@  BASE  (P)
*	`  Defines the base address of a Channel in Shared SRAM.
*			%unsigned  16  BASE  0x0000
*						*  					*  *
*						*  					*  Base address of a Channel in the Shared SRAM. A Channel's Read Pointer/Write Pointer will be added to this “BASE” to get the exact location of Shared SRAM.
*						*  					*  “BASE” is the byte address. However, BASE must be aligned to (2*DW/8).
*						*  					*  Note:- BASE of a channel shall only be modified when both the connected Hardware device, and the channel's DMA are disabled & idle.
*	@  SIZE  (P)
*	`  Defines the size of a Channel in Shared SRAM.
*			%unsigned  16  SIZE  0x0000
*						*  					*  *
*						*  					*  Size of a Channel in the Shared SRAM. The Channel FIFO Controller uses “SIZE” to generate Read/Write pointers and empty/full signals of the channel.
*						*  					*  “SIZE” is in terms of bytes. However, SIZE must be an integer multiple of (2*DW/8).
*						*  					*  Note:- (1) SIZE of a channel shall only be modified when both the connected Hardware device, and the channel's DMA are disabled & idle.
*						*  					*  (2) SIZE of a channel MUSTNOT be programmed in such a way that it wraps the physical SRAM used.
**********************************************************************************************************************/
#ifdef	h_CH
#else
#define	h_CH

#define	\
	AR_CH \
		4
#define	\
	AB_CH \
		4

typedef struct SIE_CH {

	#define	RA_CH_CTRL 					0x00000
	#define	w32CH_CTRL 					{										\
					UNSG32				uCTRL_CPR					 :  1;		\
					UNSG32				uCTRL_FLUSH					 :  1;		\
					UNSG32				uCTRL_DISCARD				 :  1;		\
					UNSG32				_x00000	: 29;							\
										}
	/* @'00000 */	union {	UNSG32		u32CH_CTRL;
								struct	w32CH_CTRL;
										};

	/* [ 0: 0] */	#define	  BA_CH_CTRL_CPR						 0x00000
	/* ---:--- */	#define	    bCH_CTRL_CPR						    1 /*bit*/
	/* ---:--- */	#define	LSb32CH_CTRL_CPR						    0 /*: 0*/
	/* ---:--- */	#define	MSK32CH_CTRL_CPR						       0x00000001
	/* ---:--- */	#define	GET32CH_CTRL_CPR(r32)						 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16CH_CTRL_CPR(r16)						 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32CH_CTRL_CPR(r32,v)						do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16CH_CTRL_CPR(r16,v)						do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [ 1: 1] */	#define	  BA_CH_CTRL_FLUSH						 0x00000
	/* ---:--- */	#define	    bCH_CTRL_FLUSH						    1 /*bit*/
	/* ---:--- */	#define	LSb32CH_CTRL_FLUSH						    1 /*: 1*/
	/* ---:--- */	#define	MSK32CH_CTRL_FLUSH						       0x00000002
	/* ---:--- */	#define	GET32CH_CTRL_FLUSH(r32)						 (((r32)>> 1)&0x0001)
	/* ---:--- */	#define	GET16CH_CTRL_FLUSH(r16)						 (((r16)>> 1)&0x0001)
	/* ---:--- */	#define	SET32CH_CTRL_FLUSH(r32,v)					do{(r32)&=~(0x0001<< 1);(r32)|=((v)&0x0001)<< 1;}while(0)
	/* ---:--- */	#define	SET16CH_CTRL_FLUSH(r16,v)					do{(r16)&=~(0x0001<< 1);(r16)|=((v)&0x0001)<< 1;}while(0)

	/* [ 2: 2] */	#define	  BA_CH_CTRL_DISCARD					 0x00000
	/* ---:--- */	#define	    bCH_CTRL_DISCARD					    1 /*bit*/
	/* ---:--- */	#define	LSb32CH_CTRL_DISCARD					    2 /*: 2*/
	/* ---:--- */	#define	MSK32CH_CTRL_DISCARD					       0x00000004
	/* ---:--- */	#define	GET32CH_CTRL_DISCARD(r32)					 (((r32)>> 2)&0x0001)
	/* ---:--- */	#define	GET16CH_CTRL_DISCARD(r16)					 (((r16)>> 2)&0x0001)
	/* ---:--- */	#define	SET32CH_CTRL_DISCARD(r32,v)					do{(r32)&=~(0x0001<< 2);(r32)|=((v)&0x0001)<< 2;}while(0)
	/* ---:--- */	#define	SET16CH_CTRL_DISCARD(r16,v)					do{(r16)&=~(0x0001<< 2);(r16)|=((v)&0x0001)<< 2;}while(0)

	#define	RA_CH_STS 					0x00004
	#define	w32CH_STS 					{										\
					UNSG32				uSTS_CTYPE					 :  3;		\
					UNSG32				uSTS_EMPTY					 :  1;		\
					UNSG32				uSTS_FULL					 :  1;		\
					UNSG32				_x00004	: 27;							\
										}
	/* @'00004 */	union {	UNSG32		u32CH_STS;
								struct	w32CH_STS;
										};

	/* [ 2: 0] */	#define	  BA_CH_STS_CTYPE						 0x00004
	/* ---:--- */	#define	    bCH_STS_CTYPE						    3 /*bit*/
	/* ---:--- */	#define	LSb32CH_STS_CTYPE						    0 /*: 2*/
	/* ---:--- */	#define	MSK32CH_STS_CTYPE						       0x00000007
	/* ---:--- */	#define	GET32CH_STS_CTYPE(r32)						 (((r32)>> 0)&0x0007)
	/* ---:--- */	#define	GET16CH_STS_CTYPE(r16)						 (((r16)>> 0)&0x0007)
	/* ---:--- */	#define	SET32CH_STS_CTYPE(r32,v)					do{(r32)&=~(0x0007<< 0);(r32)|=((v)&0x0007)<< 0;}while(0)
	/* ---:--- */	#define	SET16CH_STS_CTYPE(r16,v)					do{(r16)&=~(0x0007<< 0);(r16)|=((v)&0x0007)<< 0;}while(0)
					#define	     CH_STS_CTYPE_M2M							0x0
					#define	     CH_STS_CTYPE_M2H							0x1
					#define	     CH_STS_CTYPE_H2M							0x2
					#define	     CH_STS_CTYPE_H2H							0x3
					#define	     CH_STS_CTYPE_C2M							0x4
					#define	     CH_STS_CTYPE_M2C							0x5

	/* [ 3: 3] */	#define	  BA_CH_STS_EMPTY						 0x00004
	/* ---:--- */	#define	    bCH_STS_EMPTY						    1 /*bit*/
	/* ---:--- */	#define	LSb32CH_STS_EMPTY						    3 /*: 3*/
	/* ---:--- */	#define	MSK32CH_STS_EMPTY						       0x00000008
	/* ---:--- */	#define	GET32CH_STS_EMPTY(r32)						 (((r32)>> 3)&0x0001)
	/* ---:--- */	#define	GET16CH_STS_EMPTY(r16)						 (((r16)>> 3)&0x0001)
	/* ---:--- */	#define	SET32CH_STS_EMPTY(r32,v)					do{(r32)&=~(0x0001<< 3);(r32)|=((v)&0x0001)<< 3;}while(0)
	/* ---:--- */	#define	SET16CH_STS_EMPTY(r16,v)					do{(r16)&=~(0x0001<< 3);(r16)|=((v)&0x0001)<< 3;}while(0)

	/* [ 4: 4] */	#define	  BA_CH_STS_FULL						 0x00004
	/* ---:--- */	#define	    bCH_STS_FULL						    1 /*bit*/
	/* ---:--- */	#define	LSb32CH_STS_FULL						    4 /*: 4*/
	/* ---:--- */	#define	MSK32CH_STS_FULL						       0x00000010
	/* ---:--- */	#define	GET32CH_STS_FULL(r32)						 (((r32)>> 4)&0x0001)
	/* ---:--- */	#define	GET16CH_STS_FULL(r16)						 (((r16)>> 4)&0x0001)
	/* ---:--- */	#define	SET32CH_STS_FULL(r32,v)						do{(r32)&=~(0x0001<< 4);(r32)|=((v)&0x0001)<< 4;}while(0)
	/* ---:--- */	#define	SET16CH_STS_FULL(r16,v)						do{(r16)&=~(0x0001<< 4);(r16)|=((v)&0x0001)<< 4;}while(0)

	#define	RA_CH_BASE 					0x00008
	#define	w32CH_BASE 					{										\
					UNSG32				uBASE_BASE					 : 16;		\
					UNSG32				_x00008	: 16;							\
										}
	/* @'00008 */	union {	UNSG32		u32CH_BASE;
								struct	w32CH_BASE;
										};

	/* [15: 0] */	#define	  BA_CH_BASE_BASE						 0x00008
	/* ---:--- */	#define	    bCH_BASE_BASE						   16 /*bit*/
	/* ---:--- */	#define	LSb32CH_BASE_BASE						    0 /*:15*/
	/* ---:--- */	#define	MSK32CH_BASE_BASE						       0x0000FFFF
	/* ---:--- */	#define	GET32CH_BASE_BASE(r32)						 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16CH_BASE_BASE(r16)						 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32CH_BASE_BASE(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CH_BASE_BASE(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_CH_SIZE 					0x0000C
	#define	w32CH_SIZE 					{										\
					UNSG32				uSIZE_SIZE					 : 16;		\
					UNSG32				_x0000C	: 16;							\
										}
	/* @'0000C */	union {	UNSG32		u32CH_SIZE;
								struct	w32CH_SIZE;
										};

	/* [15: 0] */	#define	  BA_CH_SIZE_SIZE						 0x0000C
	/* ---:--- */	#define	    bCH_SIZE_SIZE						   16 /*bit*/
	/* ---:--- */	#define	LSb32CH_SIZE_SIZE						    0 /*:15*/
	/* ---:--- */	#define	MSK32CH_SIZE_SIZE						       0x0000FFFF
	/* ---:--- */	#define	GET32CH_SIZE_SIZE(r32)						 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16CH_SIZE_SIZE(r16)						 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32CH_SIZE_SIZE(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CH_SIZE_SIZE(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_CH;

	#define	dftCH_CTRL 					0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CH_CTRL;
										} T32CH_CTRL;
	#define	dftCH_STS 					0x00000008
			typedef	union {	UNSG32		u32;
								struct	w32CH_STS;
										} T32CH_STS;
	#define	dftCH_BASE 					0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CH_BASE;
										} T32CH_BASE;
	#define	dftCH_SIZE 					0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CH_SIZE;
										} T32CH_SIZE;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CH_drvrd (SIE_CH *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CH_drvwr (SIE_CH *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CH_reset (SIE_CH *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CH_check(p,pie,ps8name,hfpErrLOG)		CH_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CH_print(p,    ps8name,hfpErrLOG)		CH_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CH_cmp   (SIE_CH *p, SIE_CH *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CH_import(SIE_CH *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CH_export(SIE_CH *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CH
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: BD
*	`  Defines the registers common to the DMA channels.
*	@  CTRL  (P)
*	`  Defines the various control bits associated with a DMA channel.
*			%unsigned  3  MTU  0
*					:  BEAT2  0
*					:  BEAT4  1
*					:  BEAT8  2
*					:  BEAT16  3
*					:  BEAT32  4
*						*  					*  *
*						*  					*  Defines the burst limit on OCPm Bus. Always, DMA Engine tries to request MTU (Maximum Transaction Unit) size burst on OCPm, if it can.
*						*  					*  Note: The MTU size MUST be smaller than or equal to the Channel FIFO size defined by SIZE register.
*						*  					*  As the maximum burst size on AXI is 16-beat, the legal values for MTU are 0, 1, 2, and 3.
*			%unsigned  1  BMODE  0
*						*  					*  *
*						*  					*  Buffer Mode
*						*  					*  0 – Linear buffer mode. The total transfer size is {Y,X} bytes.
*						*  					*  1 – 2D Buffer mode, after transferring X bytes, the memory address is loaded with “Address+ADELTAn”. The above process is repeated Y-1 times.
*			%unsigned  3  FCNT  0
*						*  					*  *
*						*  					*  Indicate the no. of invalid bytes in
*						*  					*  (1) the first beat transfer for this buffer (linear mode)
*						*  					*  (2) the first beat transfer of every line for this buffer (2D mode)
*						*  					*  Encoding - 0 means no byte is invalid (i.e., all the bytes are valid), and 7 means 7-bytes are invalid.
*						*  					*  The following shows the byte enables from DMA for various FCNT values (Little Endian convention)
*						*  					*  0 causes DMA to drive mDataByteEn = 0xFF
*						*  					*  1 causes DMA to drive mDataByteEn = 0xFE
*						*  					*  ..
*						*  					*  7 causes DMA to drive mDataByteEn = 0x80
*			%unsigned  3  LCNT  7
*						*  					*  *
*						*  					*  Indicate the no. of valid bytes in
*						*  					*  (1) the last beat transfer for this buffer (linear mode)
*						*  					*  (2) the last beat transfer of every line for this buffer (2D mode)
*						*  					*  Encoding - 0 means 1 byte is valid, and 7 means 8-bytes.
*						*  					*  The following shows the byte enables from DMA for various LCNT values (Little Endian convention)
*						*  					*  0 causes DMA to drive mDataByteEn = 0x01
*						*  					*  1 causes DMA to drive mDataByteEn = 0x03
*						*  					*  ..
*						*  					*  7 causes DMA to drive mDataByteEn = 0xFF
*			%unsigned  1  CENDIAN  0
*						*  					*  *
*						*  					*  Change Endianness
*						*  					*  0 – destination endianness is same as source endianness
*						*  					*  1 – source data's endianness is changed (internal to DMA) before it is written to destination.
*			%unsigned  1  SLOOP  0
*						*  					*  *
*						*  					*  Self Loop
*						*  					*  0 – DMA stops after the current BD is done
*						*  					*  1 – After the current BD is done, DMA loads the same BD parameters again and starts the transfer (as if Firmware has programmed another BD).
*						*  					*  Note: Please be careful to enable this feature. Normally, this feature is used when flow control is accomplished through some means other than the DMA interrupt, for example, semaphore.
*	@  START  (R-W-)
*	`  Starts the DMA Engine.
*			%unsigned  1  START  0
*						*  					*  *
*						*  					*  DMA Start
*						*  					*  1 – Starts the DMA Engine, if it is not already running
*						*  					*  0 – No change in the DMA Engine.
*						*  					*  Hardware clears the START bit as soon as it starts the channel's DMA.
*	@  STS  (R)
*	`  Defines the various status bits associated with a DMA channel.
*			%unsigned  1  BUSY  0
*						*  					*  *
*						*  					*  DMA Busy Status for the channel.
*						*  					*  1 : DMA is busy
*						*  					*  0 : DMA is Idle
*	@  BUF_DIM  (P)
*	`  Defines the dimensions of the associated Buffer.
*			%unsigned  16  X  0x0000
*						*  					*  *
*						*  					*  In linear buffer mode, specifies the lower significant 16-bits of the “total buffer length” in bytes. Total buffer length must be an integer multiple of DW/8.
*						*  					*  In 2D buffer mode, specifies the length (in bytes) of the 2D data unit. X must be an integer multiple of DW/8.
*						*  					*  Note :- Total buffer length of 0 means a transfer of infinite length that is never completed. Such type of transfer may be completed by setting the CH_CTRL.FLUSH bit. It is illegal to program an infinite length transfer in 2D buffer mode.
*			%unsigned  16  Y  0x0000
*						*  					*  *
*						*  					*  In linear buffer mode, specifies the higher significant 16-bits of the “total buffer length”.
*						*  					*  In 2D buffer mode, specifies the width of the 2D data unit.
*	`  End of BD Registers
**********************************************************************************************************************/
#ifdef	h_BD
#else
#define	h_BD

#define	\
	AR_BD \
		4
#define	\
	AB_BD \
		4

typedef struct SIE_BD {

	#define	RA_BD_CTRL 					0x00000
	#define	w32BD_CTRL 					{										\
					UNSG32				uCTRL_MTU					 :  3;		\
					UNSG32				uCTRL_BMODE					 :  1;		\
					UNSG32				uCTRL_FCNT					 :  3;		\
					UNSG32				uCTRL_LCNT					 :  3;		\
					UNSG32				uCTRL_CENDIAN				 :  1;		\
					UNSG32				uCTRL_SLOOP					 :  1;		\
					UNSG32				_x00000	: 20;							\
										}
	/* @'00000 */	union {	UNSG32		u32BD_CTRL;
								struct	w32BD_CTRL;
										};

	/* [ 2: 0] */	#define	  BA_BD_CTRL_MTU						 0x00000
	/* ---:--- */	#define	    bBD_CTRL_MTU						    3 /*bit*/
	/* ---:--- */	#define	LSb32BD_CTRL_MTU						    0 /*: 2*/
	/* ---:--- */	#define	MSK32BD_CTRL_MTU						       0x00000007
	/* ---:--- */	#define	GET32BD_CTRL_MTU(r32)						 (((r32)>> 0)&0x0007)
	/* ---:--- */	#define	GET16BD_CTRL_MTU(r16)						 (((r16)>> 0)&0x0007)
	/* ---:--- */	#define	SET32BD_CTRL_MTU(r32,v)						do{(r32)&=~(0x0007<< 0);(r32)|=((v)&0x0007)<< 0;}while(0)
	/* ---:--- */	#define	SET16BD_CTRL_MTU(r16,v)						do{(r16)&=~(0x0007<< 0);(r16)|=((v)&0x0007)<< 0;}while(0)
					#define	     BD_CTRL_MTU_BEAT2							0x0
					#define	     BD_CTRL_MTU_BEAT4							0x1
					#define	     BD_CTRL_MTU_BEAT8							0x2
					#define	     BD_CTRL_MTU_BEAT16							0x3
					#define	     BD_CTRL_MTU_BEAT32							0x4

	/* [ 3: 3] */	#define	  BA_BD_CTRL_BMODE						 0x00000
	/* ---:--- */	#define	    bBD_CTRL_BMODE						    1 /*bit*/
	/* ---:--- */	#define	LSb32BD_CTRL_BMODE						    3 /*: 3*/
	/* ---:--- */	#define	MSK32BD_CTRL_BMODE						       0x00000008
	/* ---:--- */	#define	GET32BD_CTRL_BMODE(r32)						 (((r32)>> 3)&0x0001)
	/* ---:--- */	#define	GET16BD_CTRL_BMODE(r16)						 (((r16)>> 3)&0x0001)
	/* ---:--- */	#define	SET32BD_CTRL_BMODE(r32,v)					do{(r32)&=~(0x0001<< 3);(r32)|=((v)&0x0001)<< 3;}while(0)
	/* ---:--- */	#define	SET16BD_CTRL_BMODE(r16,v)					do{(r16)&=~(0x0001<< 3);(r16)|=((v)&0x0001)<< 3;}while(0)

	/* [ 6: 4] */	#define	  BA_BD_CTRL_FCNT						 0x00000
	/* ---:--- */	#define	    bBD_CTRL_FCNT						    3 /*bit*/
	/* ---:--- */	#define	LSb32BD_CTRL_FCNT						    4 /*: 6*/
	/* ---:--- */	#define	MSK32BD_CTRL_FCNT						       0x00000070
	/* ---:--- */	#define	GET32BD_CTRL_FCNT(r32)						 (((r32)>> 4)&0x0007)
	/* ---:--- */	#define	GET16BD_CTRL_FCNT(r16)						 (((r16)>> 4)&0x0007)
	/* ---:--- */	#define	SET32BD_CTRL_FCNT(r32,v)					do{(r32)&=~(0x0007<< 4);(r32)|=((v)&0x0007)<< 4;}while(0)
	/* ---:--- */	#define	SET16BD_CTRL_FCNT(r16,v)					do{(r16)&=~(0x0007<< 4);(r16)|=((v)&0x0007)<< 4;}while(0)

	/* [ 9: 7] */	#define	  BA_BD_CTRL_LCNT						 0x00000
	/* ---:--- */	#define	    bBD_CTRL_LCNT						    3 /*bit*/
	/* ---:--- */	#define	LSb32BD_CTRL_LCNT						    7 /*: 9*/
	/* ---:--- */	#define	MSK32BD_CTRL_LCNT						       0x00000380
	/* ---:--- */	#define	GET32BD_CTRL_LCNT(r32)						 (((r32)>> 7)&0x0007)
	/* ---:--- */	#define	GET16BD_CTRL_LCNT(r16)						 (((r16)>> 7)&0x0007)
	/* ---:--- */	#define	SET32BD_CTRL_LCNT(r32,v)					do{(r32)&=~(0x0007<< 7);(r32)|=((v)&0x0007)<< 7;}while(0)
	/* ---:--- */	#define	SET16BD_CTRL_LCNT(r16,v)					do{(r16)&=~(0x0007<< 7);(r16)|=((v)&0x0007)<< 7;}while(0)

	/* [10:10] */	#define	  BA_BD_CTRL_CENDIAN					 0x00001
	/* ---:--- */	#define	    bBD_CTRL_CENDIAN					    1 /*bit*/
	/* ---:--- */	#define	LSb32BD_CTRL_CENDIAN					   10 /*:10*/
	/* ---:--- */	#define	MSK32BD_CTRL_CENDIAN					       0x00000400
	/* ---:--- */	#define	GET32BD_CTRL_CENDIAN(r32)					 (((r32)>>10)&0x0001)
	/* ---:--- */	#define	GET16BD_CTRL_CENDIAN(r16)					 (((r16)>>10)&0x0001)
	/* ---:--- */	#define	SET32BD_CTRL_CENDIAN(r32,v)					do{(r32)&=~(0x0001<<10);(r32)|=((v)&0x0001)<<10;}while(0)
	/* ---:--- */	#define	SET16BD_CTRL_CENDIAN(r16,v)					do{(r16)&=~(0x0001<<10);(r16)|=((v)&0x0001)<<10;}while(0)

	/* [11:11] */	#define	  BA_BD_CTRL_SLOOP						 0x00001
	/* ---:--- */	#define	    bBD_CTRL_SLOOP						    1 /*bit*/
	/* ---:--- */	#define	LSb32BD_CTRL_SLOOP						   11 /*:11*/
	/* ---:--- */	#define	MSK32BD_CTRL_SLOOP						       0x00000800
	/* ---:--- */	#define	GET32BD_CTRL_SLOOP(r32)						 (((r32)>>11)&0x0001)
	/* ---:--- */	#define	GET16BD_CTRL_SLOOP(r16)						 (((r16)>>11)&0x0001)
	/* ---:--- */	#define	SET32BD_CTRL_SLOOP(r32,v)					do{(r32)&=~(0x0001<<11);(r32)|=((v)&0x0001)<<11;}while(0)
	/* ---:--- */	#define	SET16BD_CTRL_SLOOP(r16,v)					do{(r16)&=~(0x0001<<11);(r16)|=((v)&0x0001)<<11;}while(0)

	#define	RA_BD_START 				0x00004
	#define	w32BD_START 				{										\
					UNSG32				uSTART_START				 :  1;		\
					UNSG32				_x00004	: 31;							\
										}
	/* @'00004 */	union {	UNSG32		u32BD_START;
								struct	w32BD_START;
										};

	/* [ 0: 0] */	#define	  BA_BD_START_START						 0x00004
	/* ---:--- */	#define	    bBD_START_START						    1 /*bit*/
	/* ---:--- */	#define	LSb32BD_START_START						    0 /*: 0*/
	/* ---:--- */	#define	MSK32BD_START_START						       0x00000001
	/* ---:--- */	#define	GET32BD_START_START(r32)					 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16BD_START_START(r16)					 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32BD_START_START(r32,v)					do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16BD_START_START(r16,v)					do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	#define	RA_BD_STS 					0x00008
	#define	w32BD_STS 					{										\
					UNSG32				uSTS_BUSY					 :  1;		\
					UNSG32				_x00008	: 31;							\
										}
	/* @'00008 */	union {	UNSG32		u32BD_STS;
								struct	w32BD_STS;
										};

	/* [ 0: 0] */	#define	  BA_BD_STS_BUSY						 0x00008
	/* ---:--- */	#define	    bBD_STS_BUSY						    1 /*bit*/
	/* ---:--- */	#define	LSb32BD_STS_BUSY						    0 /*: 0*/
	/* ---:--- */	#define	MSK32BD_STS_BUSY						       0x00000001
	/* ---:--- */	#define	GET32BD_STS_BUSY(r32)						 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16BD_STS_BUSY(r16)						 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32BD_STS_BUSY(r32,v)						do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16BD_STS_BUSY(r16,v)						do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	#define	RA_BD_BUF_DIM 				0x0000C
	#define	w32BD_BUF_DIM 				{										\
					UNSG32				uBUF_DIM_X					 : 16;		\
					UNSG32				uBUF_DIM_Y					 : 16;		\
										}
	/* @'0000C */	union {	UNSG32		u32BD_BUF_DIM;
								struct	w32BD_BUF_DIM;
										};

	/* [15: 0] */	#define	  BA_BD_BUF_DIM_X						 0x0000C
	/* ---:--- */	#define	    bBD_BUF_DIM_X						   16 /*bit*/
	/* ---:--- */	#define	LSb32BD_BUF_DIM_X						    0 /*:15*/
	/* ---:--- */	#define	MSK32BD_BUF_DIM_X						       0x0000FFFF
	/* ---:--- */	#define	GET32BD_BUF_DIM_X(r32)						 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16BD_BUF_DIM_X(r16)						 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BD_BUF_DIM_X(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16BD_BUF_DIM_X(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_BD_BUF_DIM_Y						 0x0000E
	/* ---:--- */	#define	    bBD_BUF_DIM_Y						   16 /*bit*/
	/* ---:--- */	#define	LSb32BD_BUF_DIM_Y						   16 /*:31*/
	/* ---:--- */	#define	MSK32BD_BUF_DIM_Y						       0xFFFF0000
	/* ---:--- */	#define	GET32BD_BUF_DIM_Y(r32)						 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16BD_BUF_DIM_Y(r16)						 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32BD_BUF_DIM_Y(r32,v)					do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16BD_BUF_DIM_Y(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_BD;

	#define	dftBD_CTRL 					0x00000380
			typedef	union {	UNSG32		u32;
								struct	w32BD_CTRL;
										} T32BD_CTRL;
	#define	dftBD_START 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BD_START;
										} T32BD_START;
	#define	dftBD_STS 					0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BD_STS;
										} T32BD_STS;
	#define	dftBD_BUF_DIM 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32BD_BUF_DIM;
										} T32BD_BUF_DIM;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	BD_drvrd (SIE_BD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	BD_drvwr (SIE_BD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	BD_reset (SIE_BD *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	BD_check(p,pie,ps8name,hfpErrLOG)		BD_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	BD_print(p,    ps8name,hfpErrLOG)		BD_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	BD_cmp   (SIE_BD *p, SIE_BD *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	BD_import(SIE_BD *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	BD_export(SIE_BD *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: BD
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: M2M
*	`  Defines the Registers related to a single M2M Channel.
*	@
*			$CH  CH
*	@
*			$BD  BD
*	@  SRC_ADDR  (P)
*	`  Defines the source address of the transfer.
*			%unsigned  32  SRC  0x00000000
*						*  					*  *
*						*  					*  Source Memory Address of the transfer. It may be noted that the address shall always be bus width aligned.
*	@  DST_ADDR  (P)
*	`  Defines the destination address of the transfer.
*			%unsigned  32  DST  0x00000000
*						*  					*  *
*						*  					*  Destination Memory Address of the transfer. It may be noted that the address shall always be bus width aligned.
*	@  DSEL  (P)
*	`  Defines the delta select.
*			%unsigned  4  SRC  0
*						*  					*  *
*						*  					*  Source Delta Select
*						*  					*  Selects the “ADELTAn” used in “2D Buffer mode” transfer. Only used when BD_CTRL.BMODE is 1. The selected Address Delta = ADELTAn where n is the value of SRC.
*			%unsigned  4  DST  0
*						*  					*  *
*						*  					*  Destination Delta Select
*						*  					*  Selects the “ADELTAn” used in “2D Buffer mode” transfer. Only used when BMODE is 1. The selected Address Delta = ADELTAn where n is the value of DST.
*	`  End of M2M Channel Registers
**********************************************************************************************************************/
#ifdef	h_M2M
#else
#define	h_M2M

#define	\
	AR_M2M \
		11
#define	\
	AB_M2M \
		6

typedef struct SIE_M2M {

	#define	RA_M2M_CH 					0x00000
	/* @'00000 */	SIE_CH 						ie_CH;

	#define	RA_M2M_BD 					0x00010
	/* @'00010 */	SIE_BD 						ie_BD;

	#define	RA_M2M_SRC_ADDR 			0x00020
	#define	w32M2M_SRC_ADDR 			{										\
					UNSG32				uSRC_ADDR_SRC				 : 32;		\
										}
	/* @'00020 */	union {	UNSG32		u32M2M_SRC_ADDR;
								struct	w32M2M_SRC_ADDR;
										};

	/* [31: 0] */	#define	  BA_M2M_SRC_ADDR_SRC					 0x00020
	/* ---:--- */	#define	    bM2M_SRC_ADDR_SRC					   32 /*bit*/
	/* ---:--- */	#define	LSb32M2M_SRC_ADDR_SRC					    0 /*:31*/
	/* ---:--- */	#define	MSK32M2M_SRC_ADDR_SRC					       0xFFFFFFFF
	/* ---:--- */	#define	GET32M2M_SRC_ADDR_SRC(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16M2M_SRC_ADDR_SRC(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32M2M_SRC_ADDR_SRC(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16M2M_SRC_ADDR_SRC(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_M2M_DST_ADDR 			0x00024
	#define	w32M2M_DST_ADDR 			{										\
					UNSG32				uDST_ADDR_DST				 : 32;		\
										}
	/* @'00024 */	union {	UNSG32		u32M2M_DST_ADDR;
								struct	w32M2M_DST_ADDR;
										};

	/* [31: 0] */	#define	  BA_M2M_DST_ADDR_DST					 0x00024
	/* ---:--- */	#define	    bM2M_DST_ADDR_DST					   32 /*bit*/
	/* ---:--- */	#define	LSb32M2M_DST_ADDR_DST					    0 /*:31*/
	/* ---:--- */	#define	MSK32M2M_DST_ADDR_DST					       0xFFFFFFFF
	/* ---:--- */	#define	GET32M2M_DST_ADDR_DST(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16M2M_DST_ADDR_DST(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32M2M_DST_ADDR_DST(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16M2M_DST_ADDR_DST(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_M2M_DSEL 				0x00028
	#define	w32M2M_DSEL 				{										\
					UNSG32				uDSEL_SRC					 :  4;		\
					UNSG32				uDSEL_DST					 :  4;		\
					UNSG32				_x00028	: 24;							\
										}
	/* @'00028 */	union {	UNSG32		u32M2M_DSEL;
								struct	w32M2M_DSEL;
										};

	/* [ 3: 0] */	#define	  BA_M2M_DSEL_SRC						 0x00028
	/* ---:--- */	#define	    bM2M_DSEL_SRC						    4 /*bit*/
	/* ---:--- */	#define	LSb32M2M_DSEL_SRC						    0 /*: 3*/
	/* ---:--- */	#define	MSK32M2M_DSEL_SRC						       0x0000000F
	/* ---:--- */	#define	GET32M2M_DSEL_SRC(r32)						 (((r32)>> 0)&0x000F)
	/* ---:--- */	#define	GET16M2M_DSEL_SRC(r16)						 (((r16)>> 0)&0x000F)
	/* ---:--- */	#define	SET32M2M_DSEL_SRC(r32,v)					do{(r32)&=~(0x000F<< 0);(r32)|=((v)&0x000F)<< 0;}while(0)
	/* ---:--- */	#define	SET16M2M_DSEL_SRC(r16,v)					do{(r16)&=~(0x000F<< 0);(r16)|=((v)&0x000F)<< 0;}while(0)

	/* [ 7: 4] */	#define	  BA_M2M_DSEL_DST						 0x00028
	/* ---:--- */	#define	    bM2M_DSEL_DST						    4 /*bit*/
	/* ---:--- */	#define	LSb32M2M_DSEL_DST						    4 /*: 7*/
	/* ---:--- */	#define	MSK32M2M_DSEL_DST						       0x000000F0
	/* ---:--- */	#define	GET32M2M_DSEL_DST(r32)						 (((r32)>> 4)&0x000F)
	/* ---:--- */	#define	GET16M2M_DSEL_DST(r16)						 (((r16)>> 4)&0x000F)
	/* ---:--- */	#define	SET32M2M_DSEL_DST(r32,v)					do{(r32)&=~(0x000F<< 4);(r32)|=((v)&0x000F)<< 4;}while(0)
	/* ---:--- */	#define	SET16M2M_DSEL_DST(r16,v)					do{(r16)&=~(0x000F<< 4);(r16)|=((v)&0x000F)<< 4;}while(0)

} SIE_M2M;

	#define	dftM2M_SRC_ADDR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32M2M_SRC_ADDR;
										} T32M2M_SRC_ADDR;
	#define	dftM2M_DST_ADDR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32M2M_DST_ADDR;
										} T32M2M_DST_ADDR;
	#define	dftM2M_DSEL 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32M2M_DSEL;
										} T32M2M_DSEL;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	M2M_drvrd (SIE_M2M *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	M2M_drvwr (SIE_M2M *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	M2M_reset (SIE_M2M *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	M2M_check(p,pie,ps8name,hfpErrLOG)		M2M_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	M2M_print(p,    ps8name,hfpErrLOG)		M2M_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	M2M_cmp   (SIE_M2M *p, SIE_M2M *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	M2M_import(SIE_M2M *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	M2M_export(SIE_M2M *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: M2M
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: M2H
*	`  Defines the Registers related to a single M2H Channel.
*	@
*			$CH  CH
*	@
*			$BD  BD
*	@  SRC_ADDR  (P)
*	`  Defines the memory address of the transfer.
*			%unsigned  32  SRC  0x00000000
*						*  					*  *
*						*  					*  Memory Address of the transfer. It may be noted that the address shall always be bus width aligned.
*	@  DSEL  (P)
*	`  Defines the delta select.
*			%unsigned  4  SRC  0
*						*  					*  *
*						*  					*  Source Delta Select
*						*  					*  Selects the “ADELTAn” used in “2D Buffer mode” transfer. Only used when BD_CTRL.BMODE is 1. The selected Address Delta = ADELTAn where n is the value of SRC.
*	@  HW_CTRL  (P)
*	`  Controls the interface connected to the Hardware Device
*			%unsigned  1  DHE  0
*						*  					*  *
*						*  					*  1 - Requests from the Hardware device are acknowledged
*						*  					*  0 – Requests from the Hardware device are not acknowledged. Disconnects the attached Hardware device from the DMA system
*	@  SEM_CTRL  (P)
*	`  Controls the Semaphore feature of the channel
*			%unsigned  1  SE  0
*						*  					*  *
*						*  					*  1 – Semaphore control enabled
*						*  					*  0 – Semaphore control is disabled. Behaves as if it is a non-semaphore channel.
*						*  					*  Note:- Only applicable for those channels which are configured with Semaphore Control feature
*	`  End of M2H Channel Registers
**********************************************************************************************************************/
#ifdef	h_M2H
#else
#define	h_M2H

#define	\
	AR_M2H \
		12
#define	\
	AB_M2H \
		6

typedef struct SIE_M2H {

	#define	RA_M2H_CH 					0x00000
	/* @'00000 */	SIE_CH 						ie_CH;

	#define	RA_M2H_BD 					0x00010
	/* @'00010 */	SIE_BD 						ie_BD;

	#define	RA_M2H_SRC_ADDR 			0x00020
	#define	w32M2H_SRC_ADDR 			{										\
					UNSG32				uSRC_ADDR_SRC				 : 32;		\
										}
	/* @'00020 */	union {	UNSG32		u32M2H_SRC_ADDR;
								struct	w32M2H_SRC_ADDR;
										};

	/* [31: 0] */	#define	  BA_M2H_SRC_ADDR_SRC					 0x00020
	/* ---:--- */	#define	    bM2H_SRC_ADDR_SRC					   32 /*bit*/
	/* ---:--- */	#define	LSb32M2H_SRC_ADDR_SRC					    0 /*:31*/
	/* ---:--- */	#define	MSK32M2H_SRC_ADDR_SRC					       0xFFFFFFFF
	/* ---:--- */	#define	GET32M2H_SRC_ADDR_SRC(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16M2H_SRC_ADDR_SRC(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32M2H_SRC_ADDR_SRC(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16M2H_SRC_ADDR_SRC(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_M2H_DSEL 				0x00024
	#define	w32M2H_DSEL 				{										\
					UNSG32				uDSEL_SRC					 :  4;		\
					UNSG32				_x00024	: 28;							\
										}
	/* @'00024 */	union {	UNSG32		u32M2H_DSEL;
								struct	w32M2H_DSEL;
										};

	/* [ 3: 0] */	#define	  BA_M2H_DSEL_SRC						 0x00024
	/* ---:--- */	#define	    bM2H_DSEL_SRC						    4 /*bit*/
	/* ---:--- */	#define	LSb32M2H_DSEL_SRC						    0 /*: 3*/
	/* ---:--- */	#define	MSK32M2H_DSEL_SRC						       0x0000000F
	/* ---:--- */	#define	GET32M2H_DSEL_SRC(r32)						 (((r32)>> 0)&0x000F)
	/* ---:--- */	#define	GET16M2H_DSEL_SRC(r16)						 (((r16)>> 0)&0x000F)
	/* ---:--- */	#define	SET32M2H_DSEL_SRC(r32,v)					do{(r32)&=~(0x000F<< 0);(r32)|=((v)&0x000F)<< 0;}while(0)
	/* ---:--- */	#define	SET16M2H_DSEL_SRC(r16,v)					do{(r16)&=~(0x000F<< 0);(r16)|=((v)&0x000F)<< 0;}while(0)

	#define	RA_M2H_HW_CTRL 				0x00028
	#define	w32M2H_HW_CTRL 				{										\
					UNSG32				uHW_CTRL_DHE				 :  1;		\
					UNSG32				_x00028	: 31;							\
										}
	/* @'00028 */	union {	UNSG32		u32M2H_HW_CTRL;
								struct	w32M2H_HW_CTRL;
										};

	/* [ 0: 0] */	#define	  BA_M2H_HW_CTRL_DHE					 0x00028
	/* ---:--- */	#define	    bM2H_HW_CTRL_DHE					    1 /*bit*/
	/* ---:--- */	#define	LSb32M2H_HW_CTRL_DHE					    0 /*: 0*/
	/* ---:--- */	#define	MSK32M2H_HW_CTRL_DHE					       0x00000001
	/* ---:--- */	#define	GET32M2H_HW_CTRL_DHE(r32)					 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16M2H_HW_CTRL_DHE(r16)					 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32M2H_HW_CTRL_DHE(r32,v)					do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16M2H_HW_CTRL_DHE(r16,v)					do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	#define	RA_M2H_SEM_CTRL 			0x0002C
	#define	w32M2H_SEM_CTRL 			{										\
					UNSG32				uSEM_CTRL_SE				 :  1;		\
					UNSG32				_x0002C	: 31;							\
										}
	/* @'0002C */	union {	UNSG32		u32M2H_SEM_CTRL;
								struct	w32M2H_SEM_CTRL;
										};

	/* [ 0: 0] */	#define	  BA_M2H_SEM_CTRL_SE					 0x0002C
	/* ---:--- */	#define	    bM2H_SEM_CTRL_SE					    1 /*bit*/
	/* ---:--- */	#define	LSb32M2H_SEM_CTRL_SE					    0 /*: 0*/
	/* ---:--- */	#define	MSK32M2H_SEM_CTRL_SE					       0x00000001
	/* ---:--- */	#define	GET32M2H_SEM_CTRL_SE(r32)					 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16M2H_SEM_CTRL_SE(r16)					 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32M2H_SEM_CTRL_SE(r32,v)					do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16M2H_SEM_CTRL_SE(r16,v)					do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

} SIE_M2H;

	#define	dftM2H_SRC_ADDR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32M2H_SRC_ADDR;
										} T32M2H_SRC_ADDR;
	#define	dftM2H_DSEL 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32M2H_DSEL;
										} T32M2H_DSEL;
	#define	dftM2H_HW_CTRL 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32M2H_HW_CTRL;
										} T32M2H_HW_CTRL;
	#define	dftM2H_SEM_CTRL 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32M2H_SEM_CTRL;
										} T32M2H_SEM_CTRL;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	M2H_drvrd (SIE_M2H *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	M2H_drvwr (SIE_M2H *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	M2H_reset (SIE_M2H *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	M2H_check(p,pie,ps8name,hfpErrLOG)		M2H_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	M2H_print(p,    ps8name,hfpErrLOG)		M2H_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	M2H_cmp   (SIE_M2H *p, SIE_M2H *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	M2H_import(SIE_M2H *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	M2H_export(SIE_M2H *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: M2H
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: H2M
*	`  Defines the Registers related to a single M2H Channel.
*	@
*			$CH  CH
*	@
*			$BD  BD
*	@  DST_ADDR  (P)
*	`  Defines the memory address of the transfer.
*			%unsigned  32  DST  0x00000000
*						*  					*  *
*						*  					*  Memory Address of the transfer. It may be noted that the address shall always be bus width aligned.
*	@  DSEL  (P)
*	`  Defines the delta select.
*			%unsigned  4  DST  0
*						*  					*  *
*						*  					*  Destination Delta Select
*						*  					*  Selects the “ADELTAn” used in “2D Buffer mode” transfer. Only used when BD_CTRL.BMODE is 1. The selected Address Delta = ADELTAn where n is the value of DST.
*	@  HW_CTRL  (P)
*	`  Controls the interface connected to the Hardware Device
*			%unsigned  1  SHE  0
*						*  					*  *
*						*  					*  1 - Requests from the Hardware device are acknowledged
*						*  					*  0 – Requests from the Hardware device are not acknowledged. Disconnects the attached Hardware device from the DMA system
*	@  SEM_CTRL  (P)
*	`  Controls the Semaphore feature of the channel
*			%unsigned  1  SE  0
*						*  					*  *
*						*  					*  1 – Semaphore control enabled
*						*  					*  0 – Semaphore control is disabled. Behaves as if it is a non-semaphore channel.
*						*  					*  Note:- Only applicable for those channels which are configured for Semaphore Control feature
*	`  End of H2M Channel Registers
**********************************************************************************************************************/
#ifdef	h_H2M
#else
#define	h_H2M

#define	\
	AR_H2M \
		12
#define	\
	AB_H2M \
		6

typedef struct SIE_H2M {

	#define	RA_H2M_CH 					0x00000
	/* @'00000 */	SIE_CH 						ie_CH;

	#define	RA_H2M_BD 					0x00010
	/* @'00010 */	SIE_BD 						ie_BD;

	#define	RA_H2M_DST_ADDR 			0x00020
	#define	w32H2M_DST_ADDR 			{										\
					UNSG32				uDST_ADDR_DST				 : 32;		\
										}
	/* @'00020 */	union {	UNSG32		u32H2M_DST_ADDR;
								struct	w32H2M_DST_ADDR;
										};

	/* [31: 0] */	#define	  BA_H2M_DST_ADDR_DST					 0x00020
	/* ---:--- */	#define	    bH2M_DST_ADDR_DST					   32 /*bit*/
	/* ---:--- */	#define	LSb32H2M_DST_ADDR_DST					    0 /*:31*/
	/* ---:--- */	#define	MSK32H2M_DST_ADDR_DST					       0xFFFFFFFF
	/* ---:--- */	#define	GET32H2M_DST_ADDR_DST(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16H2M_DST_ADDR_DST(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32H2M_DST_ADDR_DST(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16H2M_DST_ADDR_DST(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_H2M_DSEL 				0x00024
	#define	w32H2M_DSEL 				{										\
					UNSG32				uDSEL_DST					 :  4;		\
					UNSG32				_x00024	: 28;							\
										}
	/* @'00024 */	union {	UNSG32		u32H2M_DSEL;
								struct	w32H2M_DSEL;
										};

	/* [ 3: 0] */	#define	  BA_H2M_DSEL_DST						 0x00024
	/* ---:--- */	#define	    bH2M_DSEL_DST						    4 /*bit*/
	/* ---:--- */	#define	LSb32H2M_DSEL_DST						    0 /*: 3*/
	/* ---:--- */	#define	MSK32H2M_DSEL_DST						       0x0000000F
	/* ---:--- */	#define	GET32H2M_DSEL_DST(r32)						 (((r32)>> 0)&0x000F)
	/* ---:--- */	#define	GET16H2M_DSEL_DST(r16)						 (((r16)>> 0)&0x000F)
	/* ---:--- */	#define	SET32H2M_DSEL_DST(r32,v)					do{(r32)&=~(0x000F<< 0);(r32)|=((v)&0x000F)<< 0;}while(0)
	/* ---:--- */	#define	SET16H2M_DSEL_DST(r16,v)					do{(r16)&=~(0x000F<< 0);(r16)|=((v)&0x000F)<< 0;}while(0)

	#define	RA_H2M_HW_CTRL 				0x00028
	#define	w32H2M_HW_CTRL 				{										\
					UNSG32				uHW_CTRL_SHE				 :  1;		\
					UNSG32				_x00028	: 31;							\
										}
	/* @'00028 */	union {	UNSG32		u32H2M_HW_CTRL;
								struct	w32H2M_HW_CTRL;
										};

	/* [ 0: 0] */	#define	  BA_H2M_HW_CTRL_SHE					 0x00028
	/* ---:--- */	#define	    bH2M_HW_CTRL_SHE					    1 /*bit*/
	/* ---:--- */	#define	LSb32H2M_HW_CTRL_SHE					    0 /*: 0*/
	/* ---:--- */	#define	MSK32H2M_HW_CTRL_SHE					       0x00000001
	/* ---:--- */	#define	GET32H2M_HW_CTRL_SHE(r32)					 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16H2M_HW_CTRL_SHE(r16)					 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32H2M_HW_CTRL_SHE(r32,v)					do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16H2M_HW_CTRL_SHE(r16,v)					do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	#define	RA_H2M_SEM_CTRL 			0x0002C
	#define	w32H2M_SEM_CTRL 			{										\
					UNSG32				uSEM_CTRL_SE				 :  1;		\
					UNSG32				_x0002C	: 31;							\
										}
	/* @'0002C */	union {	UNSG32		u32H2M_SEM_CTRL;
								struct	w32H2M_SEM_CTRL;
										};

	/* [ 0: 0] */	#define	  BA_H2M_SEM_CTRL_SE					 0x0002C
	/* ---:--- */	#define	    bH2M_SEM_CTRL_SE					    1 /*bit*/
	/* ---:--- */	#define	LSb32H2M_SEM_CTRL_SE					    0 /*: 0*/
	/* ---:--- */	#define	MSK32H2M_SEM_CTRL_SE					       0x00000001
	/* ---:--- */	#define	GET32H2M_SEM_CTRL_SE(r32)					 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16H2M_SEM_CTRL_SE(r16)					 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32H2M_SEM_CTRL_SE(r32,v)					do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16H2M_SEM_CTRL_SE(r16,v)					do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

} SIE_H2M;

	#define	dftH2M_DST_ADDR 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32H2M_DST_ADDR;
										} T32H2M_DST_ADDR;
	#define	dftH2M_DSEL 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32H2M_DSEL;
										} T32H2M_DSEL;
	#define	dftH2M_HW_CTRL 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32H2M_HW_CTRL;
										} T32H2M_HW_CTRL;
	#define	dftH2M_SEM_CTRL 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32H2M_SEM_CTRL;
										} T32H2M_SEM_CTRL;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	H2M_drvrd (SIE_H2M *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	H2M_drvwr (SIE_H2M *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	H2M_reset (SIE_H2M *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	H2M_check(p,pie,ps8name,hfpErrLOG)		H2M_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	H2M_print(p,    ps8name,hfpErrLOG)		H2M_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	H2M_cmp   (SIE_H2M *p, SIE_H2M *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	H2M_import(SIE_H2M *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	H2M_export(SIE_H2M *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: H2M
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: H2H
*	`  Defines the Registers related to a single M2H/H2M Channel.
*	@
*			$CH  CH
*	@  HW_CTRL  (P)
*	`  Controls the interface connected to the Hardware Device
*			%unsigned  1  SHE  0
*						*  					*  *
*						*  					*  1 - Requests from the source Hardware device are acknowledged
*						*  					*  0 – Requests from the source Hardware device are not acknowledged. Disconnects the attached source Hardware device from the DMA system
*			%unsigned  1  DHE  0
*						*  					*  *
*						*  					*  1 - Requests from the Destination Hardware device are acknowledged
*						*  					*  0 – Requests from the destination Hardware device are not acknowledged. Disconnects the attached destination Hardware device from the DMA system
*	@  HW_CNT  (P)
*	`  H2H Transfer Count
*			%unsigned  32  CNT  0x00000000
*						*  					*  *
*						*  					*  Specify the no. of bytes needs to be transfered from source hardware device to destination hardware device. CNT is in terms of bytes, and must be an integer multiple of DW/8.
*						*  					*  CNT = 0 means, an infinite length transfer that never completes. Such a transfer may be ended by using CH_CTRL.FLUSH.
*						*  					*  When the CNT no. of data are transfered to destination Hardware device, CH_INTSTS.DONE bit is set.
*	@  HW_START  (R-W-)
*	`  Starts the H2H transfer
*			%unsigned  1  START  0
*						*  					*  *
*						*  					*  H2H transfer start. Self-clear bit.
*						*  					*  1 - Load the HW_CNT into internal counter, if it was not already loaded.
*						*  					*  0 – Do nothing
*	`  End of H2H Channel Registers
**********************************************************************************************************************/
#ifdef	h_H2H
#else
#define	h_H2H

#define	\
	AR_H2H \
		7
#define	\
	AB_H2H \
		5

typedef struct SIE_H2H {

	#define	RA_H2H_CH 					0x00000
	/* @'00000 */	SIE_CH 						ie_CH;

	#define	RA_H2H_HW_CTRL 				0x00010
	#define	w32H2H_HW_CTRL 				{										\
					UNSG32				uHW_CTRL_SHE				 :  1;		\
					UNSG32				uHW_CTRL_DHE				 :  1;		\
					UNSG32				_x00010	: 30;							\
										}
	/* @'00010 */	union {	UNSG32		u32H2H_HW_CTRL;
								struct	w32H2H_HW_CTRL;
										};

	/* [ 0: 0] */	#define	  BA_H2H_HW_CTRL_SHE					 0x00010
	/* ---:--- */	#define	    bH2H_HW_CTRL_SHE					    1 /*bit*/
	/* ---:--- */	#define	LSb32H2H_HW_CTRL_SHE					    0 /*: 0*/
	/* ---:--- */	#define	MSK32H2H_HW_CTRL_SHE					       0x00000001
	/* ---:--- */	#define	GET32H2H_HW_CTRL_SHE(r32)					 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16H2H_HW_CTRL_SHE(r16)					 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32H2H_HW_CTRL_SHE(r32,v)					do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16H2H_HW_CTRL_SHE(r16,v)					do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [ 1: 1] */	#define	  BA_H2H_HW_CTRL_DHE					 0x00010
	/* ---:--- */	#define	    bH2H_HW_CTRL_DHE					    1 /*bit*/
	/* ---:--- */	#define	LSb32H2H_HW_CTRL_DHE					    1 /*: 1*/
	/* ---:--- */	#define	MSK32H2H_HW_CTRL_DHE					       0x00000002
	/* ---:--- */	#define	GET32H2H_HW_CTRL_DHE(r32)					 (((r32)>> 1)&0x0001)
	/* ---:--- */	#define	GET16H2H_HW_CTRL_DHE(r16)					 (((r16)>> 1)&0x0001)
	/* ---:--- */	#define	SET32H2H_HW_CTRL_DHE(r32,v)					do{(r32)&=~(0x0001<< 1);(r32)|=((v)&0x0001)<< 1;}while(0)
	/* ---:--- */	#define	SET16H2H_HW_CTRL_DHE(r16,v)					do{(r16)&=~(0x0001<< 1);(r16)|=((v)&0x0001)<< 1;}while(0)

	#define	RA_H2H_HW_CNT 				0x00014
	#define	w32H2H_HW_CNT 				{										\
					UNSG32				uHW_CNT_CNT					 : 32;		\
										}
	/* @'00014 */	union {	UNSG32		u32H2H_HW_CNT;
								struct	w32H2H_HW_CNT;
										};

	/* [31: 0] */	#define	  BA_H2H_HW_CNT_CNT						 0x00014
	/* ---:--- */	#define	    bH2H_HW_CNT_CNT						   32 /*bit*/
	/* ---:--- */	#define	LSb32H2H_HW_CNT_CNT						    0 /*:31*/
	/* ---:--- */	#define	MSK32H2H_HW_CNT_CNT						       0xFFFFFFFF
	/* ---:--- */	#define	GET32H2H_HW_CNT_CNT(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16H2H_HW_CNT_CNT(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32H2H_HW_CNT_CNT(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16H2H_HW_CNT_CNT(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_H2H_HW_START 			0x00018
	#define	w32H2H_HW_START 			{										\
					UNSG32				uHW_START_START				 :  1;		\
					UNSG32				_x00018	: 31;							\
										}
	/* @'00018 */	union {	UNSG32		u32H2H_HW_START;
								struct	w32H2H_HW_START;
										};

	/* [ 0: 0] */	#define	  BA_H2H_HW_START_START					 0x00018
	/* ---:--- */	#define	    bH2H_HW_START_START					    1 /*bit*/
	/* ---:--- */	#define	LSb32H2H_HW_START_START					    0 /*: 0*/
	/* ---:--- */	#define	MSK32H2H_HW_START_START					       0x00000001
	/* ---:--- */	#define	GET32H2H_HW_START_START(r32)				 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16H2H_HW_START_START(r16)				 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32H2H_HW_START_START(r32,v)				do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16H2H_HW_START_START(r16,v)				do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

} SIE_H2H;

	#define	dftH2H_HW_CTRL 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32H2H_HW_CTRL;
										} T32H2H_HW_CTRL;
	#define	dftH2H_HW_CNT 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32H2H_HW_CNT;
										} T32H2H_HW_CNT;
	#define	dftH2H_HW_START 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32H2H_HW_START;
										} T32H2H_HW_START;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	H2H_drvrd (SIE_H2H *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	H2H_drvwr (SIE_H2H *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	H2H_reset (SIE_H2H *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	H2H_check(p,pie,ps8name,hfpErrLOG)		H2H_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	H2H_print(p,    ps8name,hfpErrLOG)		H2H_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	H2H_cmp   (SIE_H2H *p, SIE_H2H *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	H2H_import(SIE_H2H *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	H2H_export(SIE_H2H *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: H2H
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CPUIFC
*	`  Defines the Registers that facilitate the CPU access of the shared SRAM.
*	@  CPU_WCMD1  (W)
*	`  Defines “CPU Write Command Queue”, in which each location contains the channel ID, its base address and the length of the data structure that is written to SRAM.  The CPU writes to WCQ through CPU_WCMD1 and CPU_WCMD2 registers. CPU's read to WCQ is not implemented.
*			%unsigned  8  CID  0
*			%unsigned  16  CBASE  0
*						*  					*  *
*						*  					*  CID : Channel that CPU uses for the transfer.
*						*  					*  CBASE : Channel Base Address in Shared SRAM.
*	@  CPU_WCMD2  (W)
*			%unsigned  16  LEN  0
*						*  					*  *
*						*  					*  Length of the data structure.
*						*  					*  When this register is written, the DMA block pushes {CID,CBASE,LEN} into “CPU Write Command Queue” (WCQ).
*						*  					*  The following steps explain the sequence of actions taken by DMA for WCQ.
*						*  					*  (i) Wait until CH_FEMPTY[x].
*						*  					*  (ii) Read the WCQ.
*						*  					*  (iii) Load the following – CH_BASE[x]=CBASE, ch_rptr[x] = 0, ch_wptr[x] = LEN.
*						*  					*  Where x=CID.
*	@  CPU_RCMD1  (W)
*	`  Defines “CPU Read Command Queue”, in which each location contains the channel ID, its base address and the length of the data structure that is read (or will be read) from SRAM.  The CPU writes to RCQ through CPU_RCMD1 and CPU_RCMD2 registers. CPU's read to WCQ is not implemented.
*			%unsigned  8  CID  0
*			%unsigned  16  CBASE  0
*						*  					*  *
*						*  					*  CID : Channel that CPU uses for the transfer.
*						*  					*  CBASE : Channel Base Address in Shared SRAM.
*	@  CPU_RCMD2  (W)
*			%unsigned  16  LEN  0
*						*  					*  *
*						*  					*  Length of the data structure.
*						*  					*  When this register is written, the DMA block pushes {CID,CBASE,LEN} into “CPU Read Command Queue” (RCQ).
*						*  					*  The following steps explain the sequence of actions taken by DMA for RCQ.
*						*  					*  (i) Wait until CH_FFULL[x]
*						*  					*  (ii) Read the RCQ.
*						*  					*  (iii) Load the following – CH_BASE[x]=CBASE, ch_rptr[x] = 0, ch_wptr[x] = 0.
*						*  					*  Where x=CID.
*	@  CPU_QSTS  (R)
*	`  Indicates the CPU Write/Read Queue status.
*			%unsigned  1  WEMPTY  0
*						*  					*  *
*						*  					*  WEMPTY – Indicates that “CPU Write Command Queue” has at least two empty entires.
*						*  					*  Note: Announcing empty when has at least two empty entries solves the WCQ coherency problems with 2 CPUs.
*			%unsigned  1  REMPTY  0
*						*  					*  *
*						*  					*  REMPTY – Indicates that “CPU Read Command Queue” has at least two empty entries.
*						*  					*  Note: Announcing empty when has at least two empty entries solves the RCQ coherency problems with 2 CPUs.
**********************************************************************************************************************/
#ifdef	h_CPUIFC
#else
#define	h_CPUIFC

#define	\
	AR_CPUIFC \
		5
#define	\
	AB_CPUIFC \
		5

typedef struct SIE_CPUIFC {

	#define	RA_CPUIFC_CPU_WCMD1 		0x00000
	#define	w32CPUIFC_CPU_WCMD1 		{										\
					UNSG32				uCPU_WCMD1_CID				 :  8;		\
					UNSG32				uCPU_WCMD1_CBASE			 : 16;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */	union {	UNSG32		u32CPUIFC_CPU_WCMD1;
								struct	w32CPUIFC_CPU_WCMD1;
										};

	/* [ 7: 0] */	#define	  BA_CPUIFC_CPU_WCMD1_CID				 0x00000
	/* ---:--- */	#define	    bCPUIFC_CPU_WCMD1_CID				    8 /*bit*/
	/* ---:--- */	#define	LSb32CPUIFC_CPU_WCMD1_CID				    0 /*: 7*/
	/* ---:--- */	#define	MSK32CPUIFC_CPU_WCMD1_CID				       0x000000FF
	/* ---:--- */	#define	GET32CPUIFC_CPU_WCMD1_CID(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16CPUIFC_CPU_WCMD1_CID(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32CPUIFC_CPU_WCMD1_CID(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CPUIFC_CPU_WCMD1_CID(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [23: 8] */	#define	  BA_CPUIFC_CPU_WCMD1_CBASE				 0x00001
	/* ---:--- */	#define	    bCPUIFC_CPU_WCMD1_CBASE				   16 /*bit*/
	/* ---:--- */	#define	LSb32CPUIFC_CPU_WCMD1_CBASE				    8 /*:23*/
	/* ---:--- */	#define	MSK32CPUIFC_CPU_WCMD1_CBASE				       0x00FFFF00
	/* ---:--- */	#define	GET32CPUIFC_CPU_WCMD1_CBASE(r32)			 (((r32)>> 8)&0xFFFF)
	/* ---:--- */	#define	GET16CPUIFC_CPU_WCMD1_CBASE(r16)			 (((r16)>> 8)&0xFFFF)
	/* ---:--- */	#define	SET32CPUIFC_CPU_WCMD1_CBASE(r32,v)			do{(r32)&=~(0xFFFF<< 8);(r32)|=((v)&0xFFFF)<< 8;}while(0)
	/* ---:--- */	#define	SET16CPUIFC_CPU_WCMD1_CBASE(r16,v)			do{(r16)&=~(0xFFFF<< 8);(r16)|=((v)&0xFFFF)<< 8;}while(0)

	#define	RA_CPUIFC_CPU_WCMD2 		0x00004
	#define	w32CPUIFC_CPU_WCMD2 		{										\
					UNSG32				uCPU_WCMD2_LEN				 : 16;		\
					UNSG32				_x00004	: 16;							\
										}
	/* @'00004 */	union {	UNSG32		u32CPUIFC_CPU_WCMD2;
								struct	w32CPUIFC_CPU_WCMD2;
										};

	/* [15: 0] */	#define	  BA_CPUIFC_CPU_WCMD2_LEN				 0x00004
	/* ---:--- */	#define	    bCPUIFC_CPU_WCMD2_LEN				   16 /*bit*/
	/* ---:--- */	#define	LSb32CPUIFC_CPU_WCMD2_LEN				    0 /*:15*/
	/* ---:--- */	#define	MSK32CPUIFC_CPU_WCMD2_LEN				       0x0000FFFF
	/* ---:--- */	#define	GET32CPUIFC_CPU_WCMD2_LEN(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16CPUIFC_CPU_WCMD2_LEN(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32CPUIFC_CPU_WCMD2_LEN(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CPUIFC_CPU_WCMD2_LEN(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_CPUIFC_CPU_RCMD1 		0x00008
	#define	w32CPUIFC_CPU_RCMD1 		{										\
					UNSG32				uCPU_RCMD1_CID				 :  8;		\
					UNSG32				uCPU_RCMD1_CBASE			 : 16;		\
					UNSG32				_x00008	:  8;							\
										}
	/* @'00008 */	union {	UNSG32		u32CPUIFC_CPU_RCMD1;
								struct	w32CPUIFC_CPU_RCMD1;
										};

	/* [ 7: 0] */	#define	  BA_CPUIFC_CPU_RCMD1_CID				 0x00008
	/* ---:--- */	#define	    bCPUIFC_CPU_RCMD1_CID				    8 /*bit*/
	/* ---:--- */	#define	LSb32CPUIFC_CPU_RCMD1_CID				    0 /*: 7*/
	/* ---:--- */	#define	MSK32CPUIFC_CPU_RCMD1_CID				       0x000000FF
	/* ---:--- */	#define	GET32CPUIFC_CPU_RCMD1_CID(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16CPUIFC_CPU_RCMD1_CID(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32CPUIFC_CPU_RCMD1_CID(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CPUIFC_CPU_RCMD1_CID(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [23: 8] */	#define	  BA_CPUIFC_CPU_RCMD1_CBASE				 0x00009
	/* ---:--- */	#define	    bCPUIFC_CPU_RCMD1_CBASE				   16 /*bit*/
	/* ---:--- */	#define	LSb32CPUIFC_CPU_RCMD1_CBASE				    8 /*:23*/
	/* ---:--- */	#define	MSK32CPUIFC_CPU_RCMD1_CBASE				       0x00FFFF00
	/* ---:--- */	#define	GET32CPUIFC_CPU_RCMD1_CBASE(r32)			 (((r32)>> 8)&0xFFFF)
	/* ---:--- */	#define	GET16CPUIFC_CPU_RCMD1_CBASE(r16)			 (((r16)>> 8)&0xFFFF)
	/* ---:--- */	#define	SET32CPUIFC_CPU_RCMD1_CBASE(r32,v)			do{(r32)&=~(0xFFFF<< 8);(r32)|=((v)&0xFFFF)<< 8;}while(0)
	/* ---:--- */	#define	SET16CPUIFC_CPU_RCMD1_CBASE(r16,v)			do{(r16)&=~(0xFFFF<< 8);(r16)|=((v)&0xFFFF)<< 8;}while(0)

	#define	RA_CPUIFC_CPU_RCMD2 		0x0000C
	#define	w32CPUIFC_CPU_RCMD2 		{										\
					UNSG32				uCPU_RCMD2_LEN				 : 16;		\
					UNSG32				_x0000C	: 16;							\
										}
	/* @'0000C */	union {	UNSG32		u32CPUIFC_CPU_RCMD2;
								struct	w32CPUIFC_CPU_RCMD2;
										};

	/* [15: 0] */	#define	  BA_CPUIFC_CPU_RCMD2_LEN				 0x0000C
	/* ---:--- */	#define	    bCPUIFC_CPU_RCMD2_LEN				   16 /*bit*/
	/* ---:--- */	#define	LSb32CPUIFC_CPU_RCMD2_LEN				    0 /*:15*/
	/* ---:--- */	#define	MSK32CPUIFC_CPU_RCMD2_LEN				       0x0000FFFF
	/* ---:--- */	#define	GET32CPUIFC_CPU_RCMD2_LEN(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16CPUIFC_CPU_RCMD2_LEN(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32CPUIFC_CPU_RCMD2_LEN(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CPUIFC_CPU_RCMD2_LEN(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_CPUIFC_CPU_QSTS 			0x00010
	#define	w32CPUIFC_CPU_QSTS 			{										\
					UNSG32				uCPU_QSTS_WEMPTY			 :  1;		\
					UNSG32				uCPU_QSTS_REMPTY			 :  1;		\
					UNSG32				_x00010	: 30;							\
										}
	/* @'00010 */	union {	UNSG32		u32CPUIFC_CPU_QSTS;
								struct	w32CPUIFC_CPU_QSTS;
										};

	/* [ 0: 0] */	#define	  BA_CPUIFC_CPU_QSTS_WEMPTY				 0x00010
	/* ---:--- */	#define	    bCPUIFC_CPU_QSTS_WEMPTY				    1 /*bit*/
	/* ---:--- */	#define	LSb32CPUIFC_CPU_QSTS_WEMPTY				    0 /*: 0*/
	/* ---:--- */	#define	MSK32CPUIFC_CPU_QSTS_WEMPTY				       0x00000001
	/* ---:--- */	#define	GET32CPUIFC_CPU_QSTS_WEMPTY(r32)			 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16CPUIFC_CPU_QSTS_WEMPTY(r16)			 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32CPUIFC_CPU_QSTS_WEMPTY(r32,v)			do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16CPUIFC_CPU_QSTS_WEMPTY(r16,v)			do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [ 1: 1] */	#define	  BA_CPUIFC_CPU_QSTS_REMPTY				 0x00010
	/* ---:--- */	#define	    bCPUIFC_CPU_QSTS_REMPTY				    1 /*bit*/
	/* ---:--- */	#define	LSb32CPUIFC_CPU_QSTS_REMPTY				    1 /*: 1*/
	/* ---:--- */	#define	MSK32CPUIFC_CPU_QSTS_REMPTY				       0x00000002
	/* ---:--- */	#define	GET32CPUIFC_CPU_QSTS_REMPTY(r32)			 (((r32)>> 1)&0x0001)
	/* ---:--- */	#define	GET16CPUIFC_CPU_QSTS_REMPTY(r16)			 (((r16)>> 1)&0x0001)
	/* ---:--- */	#define	SET32CPUIFC_CPU_QSTS_REMPTY(r32,v)			do{(r32)&=~(0x0001<< 1);(r32)|=((v)&0x0001)<< 1;}while(0)
	/* ---:--- */	#define	SET16CPUIFC_CPU_QSTS_REMPTY(r16,v)			do{(r16)&=~(0x0001<< 1);(r16)|=((v)&0x0001)<< 1;}while(0)

} SIE_CPUIFC;

	#define	dftCPUIFC_CPU_WCMD1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CPUIFC_CPU_WCMD1;
										} T32CPUIFC_CPU_WCMD1;
	#define	dftCPUIFC_CPU_WCMD2 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CPUIFC_CPU_WCMD2;
										} T32CPUIFC_CPU_WCMD2;
	#define	dftCPUIFC_CPU_RCMD1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CPUIFC_CPU_RCMD1;
										} T32CPUIFC_CPU_RCMD1;
	#define	dftCPUIFC_CPU_RCMD2 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CPUIFC_CPU_RCMD2;
										} T32CPUIFC_CPU_RCMD2;
	#define	dftCPUIFC_CPU_QSTS 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CPUIFC_CPU_QSTS;
										} T32CPUIFC_CPU_QSTS;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CPUIFC_drvrd (SIE_CPUIFC *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CPUIFC_drvwr (SIE_CPUIFC *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CPUIFC_reset (SIE_CPUIFC *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CPUIFC_check(p,pie,ps8name,hfpErrLOG)		CPUIFC_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CPUIFC_print(p,    ps8name,hfpErrLOG)		CPUIFC_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CPUIFC_cmp   (SIE_CPUIFC *p, SIE_CPUIFC *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CPUIFC_import(SIE_CPUIFC *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CPUIFC_export(SIE_CPUIFC *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CPUIFC
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: ADELTA
*	`  Address Delta Register used in 2D copy.
*	@  (P)
*			%unsigned  32  DELTA  0x00000000
*						*  					*  *
*						*  					*  In 2D copy, at the end of transferring X bytes, DELTA is added to the start address of the line.
*	`  End of Address Delta Register.
**********************************************************************************************************************/
#ifdef	h_ADELTA
#else
#define	h_ADELTA

#define	\
	AR_ADELTA \
		1
#define	\
	AB_ADELTA \
		2

typedef struct SIE_ADELTA {

	#define	RA_ADELTA_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32ADELTA_D0th_ 			{										\
					UNSG32				u_DELTA						 : 32;		\
										}
	/* @'00000 */				struct	w32ADELTA_D0th_;

	/* [31: 0] */	#define	  BA_ADELTA_DELTA						 0x00000
	/* ---:--- */	#define	    bADELTA_DELTA						   32 /*bit*/
	/* ---:--- */	#define	LSb32ADELTA_DELTA						    0 /*:31*/
	/* ---:--- */	#define	MSK32ADELTA_DELTA						       0xFFFFFFFF
	/* ---:--- */	#define	GET32ADELTA_DELTA(r32)						 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16ADELTA_DELTA(r16)						 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32ADELTA_DELTA(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16ADELTA_DELTA(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_ADELTA;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	ADELTA_drvrd (SIE_ADELTA *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	ADELTA_drvwr (SIE_ADELTA *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	ADELTA_reset (SIE_ADELTA *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	ADELTA_check(p,pie,ps8name,hfpErrLOG)		ADELTA_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	ADELTA_print(p,    ps8name,hfpErrLOG)		ADELTA_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	ADELTA_cmp   (SIE_ADELTA *p, SIE_ADELTA *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	ADELTA_import(SIE_ADELTA *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	ADELTA_export(SIE_ADELTA *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: ADELTA
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: avioDma_INTEN
*	`  Interrupt Enable Register.
*	@  (P)
*			%unsigned  12  IE  0x00000000
*						*  					*  *
*						*  					*  Interrupt Enable. IE[x] is for channel x.
*	`  End of Interrupt Enable Register.
**********************************************************************************************************************/
#ifdef	h_avioDma_INTEN
#else
#define	h_avioDma_INTEN

#define	\
	AR_avioDma_INTEN \
		1
#define	\
	AB_avioDma_INTEN \
		2

typedef struct SIE_avioDma_INTEN {

	#define	RA_avioDma_INTEN_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32avioDma_INTEN_D0th_ 		{										\
					UNSG32				u_IE						 : 12;		\
					UNSG32				_x00000	: 20;							\
										}
	/* @'00000 */				struct	w32avioDma_INTEN_D0th_;

	/* [11: 0] */	#define	  BA_avioDma_INTEN_IE						 0x00000
	/* ---:--- */	#define	    bavioDma_INTEN_IE						   12 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_INTEN_IE						    0 /*:11*/
	/* ---:--- */	#define	MSK32avioDma_INTEN_IE						       0x00000FFF
	/* ---:--- */	#define	GET32avioDma_INTEN_IE(r32)						 (((r32)>> 0)&0x0FFF)
	/* ---:--- */	#define	GET16avioDma_INTEN_IE(r16)						 (((r16)>> 0)&0x0FFF)
	/* ---:--- */	#define	SET32avioDma_INTEN_IE(r32,v)					do{(r32)&=~(0x0FFF<< 0);(r32)|=((v)&0x0FFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16avioDma_INTEN_IE(r16,v)					do{(r16)&=~(0x0FFF<< 0);(r16)|=((v)&0x0FFF)<< 0;}while(0)

} SIE_avioDma_INTEN;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	avioDma_INTEN_drvrd (SIE_avioDma_INTEN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	avioDma_INTEN_drvwr (SIE_avioDma_INTEN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	avioDma_INTEN_reset (SIE_avioDma_INTEN *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	avioDma_INTEN_check(p,pie,ps8name,hfpErrLOG)		avioDma_INTEN_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	avioDma_INTEN_print(p,    ps8name,hfpErrLOG)		avioDma_INTEN_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	avioDma_INTEN_cmp   (SIE_avioDma_INTEN *p, SIE_avioDma_INTEN *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	avioDma_INTEN_import(SIE_avioDma_INTEN *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	avioDma_INTEN_export(SIE_avioDma_INTEN *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: avioDma_INTEN
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DA
*	`  To create SRAM-like interface for providing current DMA address (Hier:1)
*	@  (R)
*			%unsigned  32  ADDR  0x00000000
*						*  					*  *
*						*  					*  Current DMA Address for debug.
**********************************************************************************************************************/
#ifdef	h_DA
#else
#define	h_DA

#define	\
	AR_DA \
		1
#define	\
	AB_DA \
		2

typedef struct SIE_DA {

	#define	RA_DA_D0th_ 				ISC_USE_ONLY	0x00000
	#define	w32DA_D0th_ 				{										\
					UNSG32				u_ADDR						 : 32;		\
										}
	/* @'00000 */				struct	w32DA_D0th_;

	/* [31: 0] */	#define	  BA_DA_ADDR							 0x00000
	/* ---:--- */	#define	    bDA_ADDR							   32 /*bit*/
	/* ---:--- */	#define	LSb32DA_ADDR							    0 /*:31*/
	/* ---:--- */	#define	MSK32DA_ADDR							       0xFFFFFFFF
	/* ---:--- */	#define	GET32DA_ADDR(r32)							 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DA_ADDR(r16)							 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DA_ADDR(r32,v)							do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DA_ADDR(r16,v)							do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DA;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DA_drvrd (SIE_DA *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DA_drvwr (SIE_DA *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DA_reset (SIE_DA *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DA_check(p,pie,ps8name,hfpErrLOG)		DA_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DA_print(p,    ps8name,hfpErrLOG)		DA_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DA_cmp   (SIE_DA *p, SIE_DA *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DA_import(SIE_DA *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DA_export(SIE_DA *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DA
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DA_SRAM
*	`  To create SRAM-like interface for providing current DMA address (Hier:2)
*	@
*			$DA  dummy  REG  [32]
**********************************************************************************************************************/
#ifdef	h_DA_SRAM
#else
#define	h_DA_SRAM

#define	\
	AR_DA_SRAM \
		32
#define	\
	AB_DA_SRAM \
		7

typedef struct SIE_DA_SRAM {

	#define	RA_DA_SRAM_dummy 			0x00000
	/* @'00000 */	SIE_DA 						ie_dummy			 [32];
					#define	 arr_DA_SRAM_dummy 						  32

} SIE_DA_SRAM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DA_SRAM_drvrd (SIE_DA_SRAM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DA_SRAM_drvwr (SIE_DA_SRAM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DA_SRAM_reset (SIE_DA_SRAM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DA_SRAM_check(p,pie,ps8name,hfpErrLOG)		DA_SRAM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DA_SRAM_print(p,    ps8name,hfpErrLOG)		DA_SRAM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DA_SRAM_cmp   (SIE_DA_SRAM *p, SIE_DA_SRAM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DA_SRAM_import(SIE_DA_SRAM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DA_SRAM_export(SIE_DA_SRAM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DA_SRAM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DEBUG
*	`  All debug registers.
*	@  Q_STS  (R)
*			%unsigned  32  STS  0x00000000
*						*  					*  *
*						*  					*  Full/Empty status of all the Qs of the DMA design.
*	@  0x80  (R)
*			$DA_SRAM  RDA  MEM
*						*  					*  *
*						*  					*  Read DMA Address for Debug (Hier:3)
*	@  0x100  (R)
*			$DA_SRAM  WDA  MEM
*						*  					*  *
*						*  					*  Write DMA Address for Debug (Hier:3)
*	`  End of Debug Registers.
**********************************************************************************************************************/
#ifdef	h_DEBUG
#else
#define	h_DEBUG

#define	\
	AR_DEBUG \
		96
#define	\
	AB_DEBUG \
		9

typedef struct SIE_DEBUG {

	#define	RA_DEBUG_Q_STS 				0x00000
	#define	w32DEBUG_Q_STS 				{										\
					UNSG32				uQ_STS_STS					 : 32;		\
										}
	/* @'00000 */	union {	UNSG32		u32DEBUG_Q_STS;
								struct	w32DEBUG_Q_STS;
										};

	/* [31: 0] */	#define	  BA_DEBUG_Q_STS_STS					 0x00000
	/* ---:--- */	#define	    bDEBUG_Q_STS_STS					   32 /*bit*/
	/* ---:--- */	#define	LSb32DEBUG_Q_STS_STS					    0 /*:31*/
	/* ---:--- */	#define	MSK32DEBUG_Q_STS_STS					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DEBUG_Q_STS_STS(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DEBUG_Q_STS_STS(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DEBUG_Q_STS_STS(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DEBUG_Q_STS_STS(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	UNSG32	_PAD_000[(0x00080-0x00004)/4];
	#define	RA_DEBUG_RDA 				0x00080
	/* @'00080 */	SIE_DA_SRAM 				ie_RDA;

	#define	RA_DEBUG_WDA 				0x00100
	/* @'00100 */	SIE_DA_SRAM 				ie_WDA;

} SIE_DEBUG;

	#define	dftDEBUG_Q_STS 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DEBUG_Q_STS;
										} T32DEBUG_Q_STS;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DEBUG_drvrd (SIE_DEBUG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DEBUG_drvwr (SIE_DEBUG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DEBUG_reset (SIE_DEBUG *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DEBUG_check(p,pie,ps8name,hfpErrLOG)		DEBUG_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DEBUG_print(p,    ps8name,hfpErrLOG)		DEBUG_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DEBUG_cmp   (SIE_DEBUG *p, SIE_DEBUG *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DEBUG_import(SIE_DEBUG *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DEBUG_export(SIE_DEBUG *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DEBUG
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: avioDma
*	` Registers generated from script Start
*	@  0x0
*		    $M2H CH0
*	@  0x40
*		    $M2H CH1
*	@  0x80
*		    $M2H CH2
*	@  0xc0
*		    $M2H CH3
*	@  0x100
*		    $M2H CH4
*	@  0x140
*		    $M2H CH5
*	@  0x180
*		    $H2M CH6
*	@  0x1c0
*		    $M2H CH7
*	@  0x200
*		    $M2H CH8
*	@  0x240
*		    $M2H CH9
*	@  0x280
*		    $M2H CH10
*	@  0x2c0
*		    $M2H CH11
*						*                      *  Channels.
*	` Registers generated from script End
*	@  0x800
*			$ADELTA  ADELTA  REG  [16]
*						*  					*  *
*						*  					*  Address Delta Registers used in 2D copy.
*	@
*			$avioDma_INTEN  CH_INTEN  REG  [3]
*						*  					*  *
*						*  					*  Channel Interrupt Enable Registers. For each interrupt output from DMA, there exists a set of BD_INTEN, and CH_INTEN registers.
*	@
*			$avioDma_INTEN  BD_INTEN  REG  [3]
*						*  					*  *
*						*  					*  BD Interrupt Enable Registers. For each interrupt output from DMA, there exists a set of BD_INTEN, and CH_INTEN registers.
*	@  CH_INTSTS  (RWC)
*	`  Channel Interrupt Status Register
*			%unsigned  1  DONE  0  [12]
*						*  					*  *
*						*  					*  Channel Done Status
*						*  					*  The DONE bit is set when the Channel transfer is done. Depending on the Channel Type, the DONE bit is asserted for that Channel –
*						*  					*  M2M – BUF_DIM units transfered to Memory
*						*  					*  H2M – BUF_DIM units transfered to Memory
*						*  					*  M2H – BUF_DIM units transfered to Hardware
*						*  					*  H2H - HW_CNT units transfered to Hardware
*						*  					*  C2M – BUF_LEN units transfered to Memory
*						*  					*  M2C – BUF_LEN units transfered to internal SRAM.
*						*  					*  When CH_INTENx.IE[y] is 1, dmaIntr[x] is asserted when DONE[y] is 1. CPU shall write 1 to clear the DONE bit.
*						*  					*  Note: (1) In M2H channel's case, if DONE interrupt is required, new DMA transfer MUST not be initialized, until DONE is asserted.
*						*  					*  (2) In H2H channel's case, if DONE interrupt is required, new START MUST not be issued, until DONE is asserted.
*	@  BD_INTSTS  (RWC)
*	`  Defines the interrupt status bit.
*			%unsigned  1  DONE  0  [12]
*						*  					*  *
*						*  					*  Buffer Done Status
*						*  					*  DMA sets the DONE bit when it is done with the BD. When BD_INTENx.IE[y] is 1, dmaIntr[x] is asserted when DONE[y] is 1. CPU shall write 1, to this bit field, to clear the DONE bit.
*	@
*			$DEBUG  DEBUG
*						*  					*  *
*						*  					*  to print it in .h file, for firmware use.
**********************************************************************************************************************/
#ifdef	h_avioDma
#else
#define	h_avioDma

#define	\
	AR_avioDma \
		640
#define	\
	AB_avioDma \
		12

typedef struct SIE_avioDma {

	#define	RA_avioDma_CH0 				0x00000
	/* @'00000 */	SIE_M2H 					ie_CH0;

	UNSG32	_PAD_000[(0x00040-0x00030)/4];
	#define	RA_avioDma_CH1 				0x00040
	/* @'00040 */	SIE_M2H 					ie_CH1;

	UNSG32	_PAD_001[(0x00080-0x00070)/4];
	#define	RA_avioDma_CH2 				0x00080
	/* @'00080 */	SIE_M2H 					ie_CH2;

	UNSG32	_PAD_002[(0x000C0-0x000B0)/4];
	#define	RA_avioDma_CH3 				0x000C0
	/* @'000C0 */	SIE_M2H 					ie_CH3;

	UNSG32	_PAD_003[(0x00100-0x000F0)/4];
	#define	RA_avioDma_CH4 				0x00100
	/* @'00100 */	SIE_M2H 					ie_CH4;

	UNSG32	_PAD_004[(0x00140-0x00130)/4];
	#define	RA_avioDma_CH5 				0x00140
	/* @'00140 */	SIE_M2H 					ie_CH5;

	UNSG32	_PAD_005[(0x00180-0x00170)/4];
	#define	RA_avioDma_CH6 				0x00180
	/* @'00180 */	SIE_H2M 					ie_CH6;

	UNSG32	_PAD_006[(0x001C0-0x001B0)/4];
	#define	RA_avioDma_CH7 				0x001C0
	/* @'001C0 */	SIE_M2H 					ie_CH7;

	UNSG32	_PAD_007[(0x00200-0x001F0)/4];
	#define	RA_avioDma_CH8 				0x00200
	/* @'00200 */	SIE_M2H 					ie_CH8;

	UNSG32	_PAD_008[(0x00240-0x00230)/4];
	#define	RA_avioDma_CH9 				0x00240
	/* @'00240 */	SIE_M2H 					ie_CH9;

	UNSG32	_PAD_009[(0x00280-0x00270)/4];
	#define	RA_avioDma_CH10 				0x00280
	/* @'00280 */	SIE_M2H 					ie_CH10;

	UNSG32	_PAD_010[(0x002C0-0x002B0)/4];
	#define	RA_avioDma_CH11 				0x002C0
	/* @'002C0 */	SIE_M2H 					ie_CH11;

	UNSG32	_PAD_011[(0x00800-0x002F0)/4];
	#define	RA_avioDma_ADELTA 				0x00800
	/* @'00800 */	SIE_ADELTA 					ie_ADELTA			 [16];
					#define	 arr_avioDma_ADELTA 						  16

	#define	RA_avioDma_CH_INTEN 			0x00840
	/* @'00840 */	SIE_avioDma_INTEN 				ie_CH_INTEN			 [3];
					#define	 arr_avioDma_CH_INTEN 						  3

	#define	RA_avioDma_BD_INTEN 			0x0084C
	/* @'0084C */	SIE_avioDma_INTEN 				ie_BD_INTEN			 [3];
					#define	 arr_avioDma_BD_INTEN 						  3

	#define	RA_avioDma_CH_INTSTS 			0x00858
	#define	w32avioDma_CH_INTSTS 			{										\
					UNSG32				uCH_INTSTS_DONE_0i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_1i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_2i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_3i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_4i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_5i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_6i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_7i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_8i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_9i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_10i			 :  1;		\
					UNSG32				uCH_INTSTS_DONE_11i			 :  1;		\
					UNSG32				_x00858	: 20;							\
										}
	/* @'00858 */	union {	UNSG32		u32avioDma_CH_INTSTS;
								struct	w32avioDma_CH_INTSTS;
										};

	/* [ 0: 0] */	#define	  BA_avioDma_CH_INTSTS_DONE_0i				 0x00858
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_0i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_0i				    0 /*: 0*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_0i				       0x00000001
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_0i(r32)			 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_0i(r16)			 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_0i(r32,v)			do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_0i(r16,v)			do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [ 1: 1] */	#define	  BA_avioDma_CH_INTSTS_DONE_1i				 0x00858
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_1i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_1i				    1 /*: 1*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_1i				       0x00000002
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_1i(r32)			 (((r32)>> 1)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_1i(r16)			 (((r16)>> 1)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_1i(r32,v)			do{(r32)&=~(0x0001<< 1);(r32)|=((v)&0x0001)<< 1;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_1i(r16,v)			do{(r16)&=~(0x0001<< 1);(r16)|=((v)&0x0001)<< 1;}while(0)

	/* [ 2: 2] */	#define	  BA_avioDma_CH_INTSTS_DONE_2i				 0x00858
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_2i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_2i				    2 /*: 2*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_2i				       0x00000004
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_2i(r32)			 (((r32)>> 2)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_2i(r16)			 (((r16)>> 2)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_2i(r32,v)			do{(r32)&=~(0x0001<< 2);(r32)|=((v)&0x0001)<< 2;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_2i(r16,v)			do{(r16)&=~(0x0001<< 2);(r16)|=((v)&0x0001)<< 2;}while(0)

	/* [ 3: 3] */	#define	  BA_avioDma_CH_INTSTS_DONE_3i				 0x00858
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_3i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_3i				    3 /*: 3*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_3i				       0x00000008
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_3i(r32)			 (((r32)>> 3)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_3i(r16)			 (((r16)>> 3)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_3i(r32,v)			do{(r32)&=~(0x0001<< 3);(r32)|=((v)&0x0001)<< 3;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_3i(r16,v)			do{(r16)&=~(0x0001<< 3);(r16)|=((v)&0x0001)<< 3;}while(0)

	/* [ 4: 4] */	#define	  BA_avioDma_CH_INTSTS_DONE_4i				 0x00858
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_4i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_4i				    4 /*: 4*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_4i				       0x00000010
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_4i(r32)			 (((r32)>> 4)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_4i(r16)			 (((r16)>> 4)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_4i(r32,v)			do{(r32)&=~(0x0001<< 4);(r32)|=((v)&0x0001)<< 4;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_4i(r16,v)			do{(r16)&=~(0x0001<< 4);(r16)|=((v)&0x0001)<< 4;}while(0)

	/* [ 5: 5] */	#define	  BA_avioDma_CH_INTSTS_DONE_5i				 0x00858
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_5i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_5i				    5 /*: 5*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_5i				       0x00000020
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_5i(r32)			 (((r32)>> 5)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_5i(r16)			 (((r16)>> 5)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_5i(r32,v)			do{(r32)&=~(0x0001<< 5);(r32)|=((v)&0x0001)<< 5;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_5i(r16,v)			do{(r16)&=~(0x0001<< 5);(r16)|=((v)&0x0001)<< 5;}while(0)

	/* [ 6: 6] */	#define	  BA_avioDma_CH_INTSTS_DONE_6i				 0x00858
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_6i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_6i				    6 /*: 6*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_6i				       0x00000040
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_6i(r32)			 (((r32)>> 6)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_6i(r16)			 (((r16)>> 6)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_6i(r32,v)			do{(r32)&=~(0x0001<< 6);(r32)|=((v)&0x0001)<< 6;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_6i(r16,v)			do{(r16)&=~(0x0001<< 6);(r16)|=((v)&0x0001)<< 6;}while(0)

	/* [ 7: 7] */	#define	  BA_avioDma_CH_INTSTS_DONE_7i				 0x00858
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_7i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_7i				    7 /*: 7*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_7i				       0x00000080
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_7i(r32)			 (((r32)>> 7)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_7i(r16)			 (((r16)>> 7)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_7i(r32,v)			do{(r32)&=~(0x0001<< 7);(r32)|=((v)&0x0001)<< 7;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_7i(r16,v)			do{(r16)&=~(0x0001<< 7);(r16)|=((v)&0x0001)<< 7;}while(0)

	/* [ 8: 8] */	#define	  BA_avioDma_CH_INTSTS_DONE_8i				 0x00859
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_8i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_8i				    8 /*: 8*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_8i				       0x00000100
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_8i(r32)			 (((r32)>> 8)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_8i(r16)			 (((r16)>> 8)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_8i(r32,v)			do{(r32)&=~(0x0001<< 8);(r32)|=((v)&0x0001)<< 8;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_8i(r16,v)			do{(r16)&=~(0x0001<< 8);(r16)|=((v)&0x0001)<< 8;}while(0)

	/* [ 9: 9] */	#define	  BA_avioDma_CH_INTSTS_DONE_9i				 0x00859
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_9i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_9i				    9 /*: 9*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_9i				       0x00000200
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_9i(r32)			 (((r32)>> 9)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_9i(r16)			 (((r16)>> 9)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_9i(r32,v)			do{(r32)&=~(0x0001<< 9);(r32)|=((v)&0x0001)<< 9;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_9i(r16,v)			do{(r16)&=~(0x0001<< 9);(r16)|=((v)&0x0001)<< 9;}while(0)

	/* [10:10] */	#define	  BA_avioDma_CH_INTSTS_DONE_10i			 0x00859
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_10i			    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_10i			   10 /*:10*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_10i			       0x00000400
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_10i(r32)			 (((r32)>>10)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_10i(r16)			 (((r16)>>10)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_10i(r32,v)			do{(r32)&=~(0x0001<<10);(r32)|=((v)&0x0001)<<10;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_10i(r16,v)			do{(r16)&=~(0x0001<<10);(r16)|=((v)&0x0001)<<10;}while(0)

	/* [11:11] */	#define	  BA_avioDma_CH_INTSTS_DONE_11i			 0x00859
	/* ---:--- */	#define	    bavioDma_CH_INTSTS_DONE_11i			    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_CH_INTSTS_DONE_11i			   11 /*:11*/
	/* ---:--- */	#define	MSK32avioDma_CH_INTSTS_DONE_11i			       0x00000800
	/* ---:--- */	#define	GET32avioDma_CH_INTSTS_DONE_11i(r32)			 (((r32)>>11)&0x0001)
	/* ---:--- */	#define	GET16avioDma_CH_INTSTS_DONE_11i(r16)			 (((r16)>>11)&0x0001)
	/* ---:--- */	#define	SET32avioDma_CH_INTSTS_DONE_11i(r32,v)			do{(r32)&=~(0x0001<<11);(r32)|=((v)&0x0001)<<11;}while(0)
	/* ---:--- */	#define	SET16avioDma_CH_INTSTS_DONE_11i(r16,v)			do{(r16)&=~(0x0001<<11);(r16)|=((v)&0x0001)<<11;}while(0)

	#define	RA_avioDma_BD_INTSTS 			0x0085C
	#define	w32avioDma_BD_INTSTS 			{										\
					UNSG32				uBD_INTSTS_DONE_0i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_1i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_2i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_3i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_4i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_5i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_6i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_7i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_8i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_9i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_10i			 :  1;		\
					UNSG32				uBD_INTSTS_DONE_11i			 :  1;		\
					UNSG32				_x0085C	: 20;							\
										}
	/* @'0085C */	union {	UNSG32		u32avioDma_BD_INTSTS;
								struct	w32avioDma_BD_INTSTS;
										};

	/* [ 0: 0] */	#define	  BA_avioDma_BD_INTSTS_DONE_0i				 0x0085C
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_0i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_0i				    0 /*: 0*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_0i				       0x00000001
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_0i(r32)			 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_0i(r16)			 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_0i(r32,v)			do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_0i(r16,v)			do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [ 1: 1] */	#define	  BA_avioDma_BD_INTSTS_DONE_1i				 0x0085C
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_1i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_1i				    1 /*: 1*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_1i				       0x00000002
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_1i(r32)			 (((r32)>> 1)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_1i(r16)			 (((r16)>> 1)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_1i(r32,v)			do{(r32)&=~(0x0001<< 1);(r32)|=((v)&0x0001)<< 1;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_1i(r16,v)			do{(r16)&=~(0x0001<< 1);(r16)|=((v)&0x0001)<< 1;}while(0)

	/* [ 2: 2] */	#define	  BA_avioDma_BD_INTSTS_DONE_2i				 0x0085C
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_2i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_2i				    2 /*: 2*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_2i				       0x00000004
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_2i(r32)			 (((r32)>> 2)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_2i(r16)			 (((r16)>> 2)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_2i(r32,v)			do{(r32)&=~(0x0001<< 2);(r32)|=((v)&0x0001)<< 2;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_2i(r16,v)			do{(r16)&=~(0x0001<< 2);(r16)|=((v)&0x0001)<< 2;}while(0)

	/* [ 3: 3] */	#define	  BA_avioDma_BD_INTSTS_DONE_3i				 0x0085C
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_3i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_3i				    3 /*: 3*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_3i				       0x00000008
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_3i(r32)			 (((r32)>> 3)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_3i(r16)			 (((r16)>> 3)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_3i(r32,v)			do{(r32)&=~(0x0001<< 3);(r32)|=((v)&0x0001)<< 3;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_3i(r16,v)			do{(r16)&=~(0x0001<< 3);(r16)|=((v)&0x0001)<< 3;}while(0)

	/* [ 4: 4] */	#define	  BA_avioDma_BD_INTSTS_DONE_4i				 0x0085C
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_4i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_4i				    4 /*: 4*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_4i				       0x00000010
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_4i(r32)			 (((r32)>> 4)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_4i(r16)			 (((r16)>> 4)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_4i(r32,v)			do{(r32)&=~(0x0001<< 4);(r32)|=((v)&0x0001)<< 4;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_4i(r16,v)			do{(r16)&=~(0x0001<< 4);(r16)|=((v)&0x0001)<< 4;}while(0)

	/* [ 5: 5] */	#define	  BA_avioDma_BD_INTSTS_DONE_5i				 0x0085C
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_5i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_5i				    5 /*: 5*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_5i				       0x00000020
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_5i(r32)			 (((r32)>> 5)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_5i(r16)			 (((r16)>> 5)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_5i(r32,v)			do{(r32)&=~(0x0001<< 5);(r32)|=((v)&0x0001)<< 5;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_5i(r16,v)			do{(r16)&=~(0x0001<< 5);(r16)|=((v)&0x0001)<< 5;}while(0)

	/* [ 6: 6] */	#define	  BA_avioDma_BD_INTSTS_DONE_6i				 0x0085C
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_6i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_6i				    6 /*: 6*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_6i				       0x00000040
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_6i(r32)			 (((r32)>> 6)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_6i(r16)			 (((r16)>> 6)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_6i(r32,v)			do{(r32)&=~(0x0001<< 6);(r32)|=((v)&0x0001)<< 6;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_6i(r16,v)			do{(r16)&=~(0x0001<< 6);(r16)|=((v)&0x0001)<< 6;}while(0)

	/* [ 7: 7] */	#define	  BA_avioDma_BD_INTSTS_DONE_7i				 0x0085C
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_7i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_7i				    7 /*: 7*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_7i				       0x00000080
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_7i(r32)			 (((r32)>> 7)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_7i(r16)			 (((r16)>> 7)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_7i(r32,v)			do{(r32)&=~(0x0001<< 7);(r32)|=((v)&0x0001)<< 7;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_7i(r16,v)			do{(r16)&=~(0x0001<< 7);(r16)|=((v)&0x0001)<< 7;}while(0)

	/* [ 8: 8] */	#define	  BA_avioDma_BD_INTSTS_DONE_8i				 0x0085D
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_8i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_8i				    8 /*: 8*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_8i				       0x00000100
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_8i(r32)			 (((r32)>> 8)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_8i(r16)			 (((r16)>> 8)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_8i(r32,v)			do{(r32)&=~(0x0001<< 8);(r32)|=((v)&0x0001)<< 8;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_8i(r16,v)			do{(r16)&=~(0x0001<< 8);(r16)|=((v)&0x0001)<< 8;}while(0)

	/* [ 9: 9] */	#define	  BA_avioDma_BD_INTSTS_DONE_9i				 0x0085D
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_9i				    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_9i				    9 /*: 9*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_9i				       0x00000200
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_9i(r32)			 (((r32)>> 9)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_9i(r16)			 (((r16)>> 9)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_9i(r32,v)			do{(r32)&=~(0x0001<< 9);(r32)|=((v)&0x0001)<< 9;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_9i(r16,v)			do{(r16)&=~(0x0001<< 9);(r16)|=((v)&0x0001)<< 9;}while(0)

	/* [10:10] */	#define	  BA_avioDma_BD_INTSTS_DONE_10i			 0x0085D
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_10i			    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_10i			   10 /*:10*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_10i			       0x00000400
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_10i(r32)			 (((r32)>>10)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_10i(r16)			 (((r16)>>10)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_10i(r32,v)			do{(r32)&=~(0x0001<<10);(r32)|=((v)&0x0001)<<10;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_10i(r16,v)			do{(r16)&=~(0x0001<<10);(r16)|=((v)&0x0001)<<10;}while(0)

	/* [11:11] */	#define	  BA_avioDma_BD_INTSTS_DONE_11i			 0x0085D
	/* ---:--- */	#define	    bavioDma_BD_INTSTS_DONE_11i			    1 /*bit*/
	/* ---:--- */	#define	LSb32avioDma_BD_INTSTS_DONE_11i			   11 /*:11*/
	/* ---:--- */	#define	MSK32avioDma_BD_INTSTS_DONE_11i			       0x00000800
	/* ---:--- */	#define	GET32avioDma_BD_INTSTS_DONE_11i(r32)			 (((r32)>>11)&0x0001)
	/* ---:--- */	#define	GET16avioDma_BD_INTSTS_DONE_11i(r16)			 (((r16)>>11)&0x0001)
	/* ---:--- */	#define	SET32avioDma_BD_INTSTS_DONE_11i(r32,v)			do{(r32)&=~(0x0001<<11);(r32)|=((v)&0x0001)<<11;}while(0)
	/* ---:--- */	#define	SET16avioDma_BD_INTSTS_DONE_11i(r16,v)			do{(r16)&=~(0x0001<<11);(r16)|=((v)&0x0001)<<11;}while(0)

	UNSG32	_PAD_012[(0x00880-0x00860)/4];
	#define	RA_avioDma_DEBUG 				0x00880
	/* @'00880 */	SIE_DEBUG 					ie_DEBUG;

} SIE_avioDma;

	#define	dftavioDma_CH_INTSTS 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32avioDma_CH_INTSTS;
										} T32avioDma_CH_INTSTS;
	#define	dftavioDma_BD_INTSTS 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32avioDma_BD_INTSTS;
										} T32avioDma_BD_INTSTS;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	avioDma_drvrd (SIE_avioDma *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	avioDma_drvwr (SIE_avioDma *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	avioDma_reset (SIE_avioDma *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	avioDma_check(p,pie,ps8name,hfpErrLOG)		avioDma_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	avioDma_print(p,    ps8name,hfpErrLOG)		avioDma_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	avioDma_cmp   (SIE_avioDma *p, SIE_avioDma *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	avioDma_import(SIE_avioDma *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	avioDma_export(SIE_avioDma *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: avioDma
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: CFG_avioDma
*	`  to print the .cfg params in .h file, for firmware use
*					:  SRAM_DEPTH  1536
*	@  dummy  (R)
*			%unsigned  32  0x00000000
*						*  					*  *
*						*  					*  dummy
*	`  End of Debug Registers.
**********************************************************************************************************************/
#ifdef	h_CFG_avioDma
#else
#define	h_CFG_avioDma

#define	\
	AR_CFG_avioDma \
		1
#define	\
	AB_CFG_avioDma \
		2

	#define	CFG_avioDma_SRAM_DEPTH 		0x600

typedef struct SIE_CFG_avioDma {

	#define	RA_CFG_avioDma_dummy 			0x00000
	#define	w32CFG_avioDma_dummy 			{										\
					UNSG32				udummy_0x00000000			 : 32;		\
										}
	/* @'00000 */	union {	UNSG32		u32CFG_avioDma_dummy;
								struct	w32CFG_avioDma_dummy;
										};

	/* [31: 0] */	#define	  BA_CFG_avioDma_dummy_0x00000000			 0x00000
	/* ---:--- */	#define	    bCFG_avioDma_dummy_0x00000000			   32 /*bit*/
	/* ---:--- */	#define	LSb32CFG_avioDma_dummy_0x00000000			    0 /*:31*/
	/* ---:--- */	#define	MSK32CFG_avioDma_dummy_0x00000000			       0xFFFFFFFF
	/* ---:--- */	#define	GET32CFG_avioDma_dummy_0x00000000(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16CFG_avioDma_dummy_0x00000000(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32CFG_avioDma_dummy_0x00000000(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16CFG_avioDma_dummy_0x00000000(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_CFG_avioDma;

	#define	dftCFG_avioDma_dummy 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32CFG_avioDma_dummy;
										} T32CFG_avioDma_dummy;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	CFG_avioDma_drvrd (SIE_CFG_avioDma *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	CFG_avioDma_drvwr (SIE_CFG_avioDma *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	CFG_avioDma_reset (SIE_CFG_avioDma *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	CFG_avioDma_check(p,pie,ps8name,hfpErrLOG)		CFG_avioDma_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	CFG_avioDma_print(p,    ps8name,hfpErrLOG)		CFG_avioDma_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	CFG_avioDma_cmp   (SIE_CFG_avioDma *p, SIE_CFG_avioDma *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	CFG_avioDma_import(SIE_CFG_avioDma *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	CFG_avioDma_export(SIE_CFG_avioDma *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: CFG_avioDma
**********************************************************************************************************************/



#pragma	pack()

#ifdef	__cplusplus
	}
#endif

#endif	/* _avioDmaReg_h */
/**********************************************************************************************************************
*	ENDOFFILE (by "Interface Specification Compiler" ver-1.0): avioDmaReg.h
**********************************************************************************************************************/

