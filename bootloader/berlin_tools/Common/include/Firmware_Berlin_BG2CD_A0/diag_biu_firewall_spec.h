/**********************************************************************************************************************
*	DO NOT EDIT! Automatically generated by "Interface Specification Compiler" ver-1.0
*			<ansi-c> :    diag_biu_firewall_spec.h
**********************************************************************************************************************/
#ifdef	_diag_biu_firewall_spec_h
#else
#define	_diag_biu_firewall_spec_h	"_firewall_spec_h >>>    "
#include	"ctypes.h"

#pragma	pack(4)

#ifdef	__cplusplus
	extern	"C"
	{
#endif



/**********************************************************************************************************************
*	INTERFACE: HBOADDR
*	@
*		%unsigned  16  uAddr  0
**********************************************************************************************************************/
#ifdef	h_HBOADDR
#else
#define	h_HBOADDR

#define	\
	AR_HBOADDR \
		1
#define	\
	AB_HBOADDR \
		2

typedef struct SIE_HBOADDR {

	#define	RA_HBOADDR_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32HBOADDR_D0th_ 			{										\
					UNSG32				u_uAddr						 : 16;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32HBOADDR_D0th_;

	/* [15: 0] */	#define	  BA_HBOADDR_uAddr						 0x00000
	/* ---:--- */	#define	    bHBOADDR_uAddr						   16 /*bit*/
	/* ---:--- */	#define	LSb32HBOADDR_uAddr						    0 /*:15*/
	/* ---:--- */	#define	MSK32HBOADDR_uAddr						       0x0000FFFF
	/* ---:--- */	#define	GET32HBOADDR_uAddr(r32)						 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16HBOADDR_uAddr(r16)						 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32HBOADDR_uAddr(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16HBOADDR_uAddr(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_HBOADDR;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	HBOADDR_drvrd (SIE_HBOADDR *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	HBOADDR_drvwr (SIE_HBOADDR *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	HBOADDR_reset (SIE_HBOADDR *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	HBOADDR_check(p,pie,ps8name,hfpErrLOG)		HBOADDR_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	HBOADDR_print(p,    ps8name,hfpErrLOG)		HBOADDR_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	HBOADDR_cmp   (SIE_HBOADDR *p, SIE_HBOADDR *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	HBOADDR_import(SIE_HBOADDR *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	HBOADDR_export(SIE_HBOADDR *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: HBOADDR
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UINT32
*	@  V32
*		%unsigned  16  uV16L  0
*		%unsigned  16  uV16H  0
**********************************************************************************************************************/
#ifdef	h_UINT32
#else
#define	h_UINT32

#define	\
	AR_UINT32 \
		1
#define	\
	AB_UINT32 \
		2

typedef struct SIE_UINT32 {

	#define	RA_UINT32_V32 				0x00000
	#define	w32UINT32_V32 				{										\
					UNSG32				uV32_uV16L					 : 16;		\
					UNSG32				uV32_uV16H					 : 16;		\
										}
	/* @'00000 */	union {	UNSG32		u32UINT32_V32;
								struct	w32UINT32_V32;
										};

	/* [15: 0] */	#define	  BA_UINT32_V32_uV16L					 0x00000
	/* ---:--- */	#define	    bUINT32_V32_uV16L					   16 /*bit*/
	/* ---:--- */	#define	LSb32UINT32_V32_uV16L					    0 /*:15*/
	/* ---:--- */	#define	MSK32UINT32_V32_uV16L					       0x0000FFFF
	/* ---:--- */	#define	GET32UINT32_V32_uV16L(r32)					 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16UINT32_V32_uV16L(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32UINT32_V32_uV16L(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16UINT32_V32_uV16L(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_UINT32_V32_uV16H					 0x00002
	/* ---:--- */	#define	    bUINT32_V32_uV16H					   16 /*bit*/
	/* ---:--- */	#define	LSb32UINT32_V32_uV16H					   16 /*:31*/
	/* ---:--- */	#define	MSK32UINT32_V32_uV16H					       0xFFFF0000
	/* ---:--- */	#define	GET32UINT32_V32_uV16H(r32)					 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16UINT32_V32_uV16H(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32UINT32_V32_uV16H(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16UINT32_V32_uV16H(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_UINT32;

	#define	dftUINT32_V32 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32UINT32_V32;
										} T32UINT32_V32;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UINT32_drvrd (SIE_UINT32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UINT32_drvwr (SIE_UINT32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UINT32_reset (SIE_UINT32 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UINT32_check(p,pie,ps8name,hfpErrLOG)		UINT32_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UINT32_print(p,    ps8name,hfpErrLOG)		UINT32_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UINT32_cmp   (SIE_UINT32 *p, SIE_UINT32 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UINT32_import(SIE_UINT32 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UINT32_export(SIE_UINT32 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UINT32
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UINT64
*		$UINT32  v32  REG  [2]
**********************************************************************************************************************/
#ifdef	h_UINT64
#else
#define	h_UINT64

#define	\
	AR_UINT64 \
		2
#define	\
	AB_UINT64 \
		3

typedef struct SIE_UINT64 {

	#define	RA_UINT64_v32 				0x00000
	/* @'00000 */	SIE_UINT32 					ie_v32				 [2];
					#define	 arr_UINT64_v32 						  2

} SIE_UINT64;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UINT64_drvrd (SIE_UINT64 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UINT64_drvwr (SIE_UINT64 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UINT64_reset (SIE_UINT64 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UINT64_check(p,pie,ps8name,hfpErrLOG)		UINT64_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UINT64_print(p,    ps8name,hfpErrLOG)		UINT64_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UINT64_cmp   (SIE_UINT64 *p, SIE_UINT64 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UINT64_import(SIE_UINT64 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UINT64_export(SIE_UINT64 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UINT64
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UINT128
*		$UINT32  v32  REG  [4]
**********************************************************************************************************************/
#ifdef	h_UINT128
#else
#define	h_UINT128

#define	\
	AR_UINT128 \
		4
#define	\
	AB_UINT128 \
		4

typedef struct SIE_UINT128 {

	#define	RA_UINT128_v32 				0x00000
	/* @'00000 */	SIE_UINT32 					ie_v32				 [4];
					#define	 arr_UINT128_v32 						  4

} SIE_UINT128;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UINT128_drvrd (SIE_UINT128 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UINT128_drvwr (SIE_UINT128 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UINT128_reset (SIE_UINT128 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UINT128_check(p,pie,ps8name,hfpErrLOG)		UINT128_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UINT128_print(p,    ps8name,hfpErrLOG)		UINT128_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UINT128_cmp   (SIE_UINT128 *p, SIE_UINT128 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UINT128_import(SIE_UINT128 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UINT128_export(SIE_UINT128 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UINT128
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: UINT1024
*		$UINT128  v128  REG  [8]
**********************************************************************************************************************/
#ifdef	h_UINT1024
#else
#define	h_UINT1024

#define	\
	AR_UINT1024 \
		32
#define	\
	AB_UINT1024 \
		7

typedef struct SIE_UINT1024 {

	#define	RA_UINT1024_v128 			0x00000
	/* @'00000 */	SIE_UINT128 				ie_v128				 [8];
					#define	 arr_UINT1024_v128 						  8

} SIE_UINT1024;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	UINT1024_drvrd (SIE_UINT1024 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	UINT1024_drvwr (SIE_UINT1024 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	UINT1024_reset (SIE_UINT1024 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	UINT1024_check(p,pie,ps8name,hfpErrLOG)		UINT1024_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	UINT1024_print(p,    ps8name,hfpErrLOG)		UINT1024_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	UINT1024_cmp   (SIE_UINT1024 *p, SIE_UINT1024 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	UINT1024_import(SIE_UINT1024 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	UINT1024_export(SIE_UINT1024 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: UINT1024
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DTCMFifo
*	@
*		%unsigned  16  nRdOff  0
*						*  *
*						*  Current read offset
*		%unsigned  16  pbBase  0
*						*  *
*						*  DTCM FIFO base address
*	@
*		%unsigned  16  nWrOff  0
*						*  *
*						*  Current write offset
*		%unsigned  16  nMaxSize  0
*						*  *
*						*  MAX size of DTCM FIFO in bytes
**********************************************************************************************************************/
#ifdef	h_DTCMFifo
#else
#define	h_DTCMFifo

#define	\
	AR_DTCMFifo \
		2
#define	\
	AB_DTCMFifo \
		3

typedef struct SIE_DTCMFifo {

	#define	RA_DTCMFifo_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32DTCMFifo_D0th_ 			{										\
					UNSG32				u_nRdOff					 : 16;		\
					UNSG32				u_pbBase					 : 16;		\
										}
	/* @'00000 */				struct	w32DTCMFifo_D0th_;

	/* [15: 0] */	#define	  BA_DTCMFifo_nRdOff					 0x00000
	/* ---:--- */	#define	    bDTCMFifo_nRdOff					   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMFifo_nRdOff					    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMFifo_nRdOff					       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMFifo_nRdOff(r32)					 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMFifo_nRdOff(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMFifo_nRdOff(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMFifo_nRdOff(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMFifo_pbBase					 0x00002
	/* ---:--- */	#define	    bDTCMFifo_pbBase					   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMFifo_pbBase					   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMFifo_pbBase					       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMFifo_pbBase(r32)					 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMFifo_pbBase(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMFifo_pbBase(r32,v)					do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMFifo_pbBase(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DTCMFifo_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DTCMFifo_D1th_ 			{										\
					UNSG32				u_nWrOff					 : 16;		\
					UNSG32				u_nMaxSize					 : 16;		\
										}
	/* @'00004 */				struct	w32DTCMFifo_D1th_;

	/* [15: 0] */	#define	  BA_DTCMFifo_nWrOff					 0x00004
	/* ---:--- */	#define	    bDTCMFifo_nWrOff					   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMFifo_nWrOff					    0 /*:15*/
	/* ---:--- */	#define	MSK32DTCMFifo_nWrOff					       0x0000FFFF
	/* ---:--- */	#define	GET32DTCMFifo_nWrOff(r32)					 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMFifo_nWrOff(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMFifo_nWrOff(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DTCMFifo_nWrOff(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DTCMFifo_nMaxSize					 0x00006
	/* ---:--- */	#define	    bDTCMFifo_nMaxSize					   16 /*bit*/
	/* ---:--- */	#define	LSb32DTCMFifo_nMaxSize					   16 /*:31*/
	/* ---:--- */	#define	MSK32DTCMFifo_nMaxSize					       0xFFFF0000
	/* ---:--- */	#define	GET32DTCMFifo_nMaxSize(r32)					 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DTCMFifo_nMaxSize(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DTCMFifo_nMaxSize(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DTCMFifo_nMaxSize(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_DTCMFifo;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DTCMFifo_drvrd (SIE_DTCMFifo *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DTCMFifo_drvwr (SIE_DTCMFifo *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DTCMFifo_reset (SIE_DTCMFifo *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DTCMFifo_check(p,pie,ps8name,hfpErrLOG)		DTCMFifo_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DTCMFifo_print(p,    ps8name,hfpErrLOG)		DTCMFifo_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DTCMFifo_cmp   (SIE_DTCMFifo *p, SIE_DTCMFifo *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DTCMFifo_import(SIE_DTCMFifo *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DTCMFifo_export(SIE_DTCMFifo *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DTCMFifo
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSFifo16
*	@
*		%unsigned  16  nWrOff  0
*						*  *
*						*  Current FIFO write offset from the base address of the FIFO
*		%unsigned  16  nMaxSize  0
*						*  *
*						*  Maximum size of the FIFO size
*		%unsigned  32  pbBase  0
*						*  *
*						*  32-bits address of the FIFO buffer base in DDR
**********************************************************************************************************************/
#ifdef	h_DSFifo16
#else
#define	h_DSFifo16

#define	\
	AR_DSFifo16 \
		2
#define	\
	AB_DSFifo16 \
		3

typedef struct SIE_DSFifo16 {

	#define	RA_DSFifo16_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32DSFifo16_D0th_ 			{										\
					UNSG32				u_nWrOff					 : 16;		\
					UNSG32				u_nMaxSize					 : 16;		\
										}
	/* @'00000 */				struct	w32DSFifo16_D0th_;

	/* [15: 0] */	#define	  BA_DSFifo16_nWrOff					 0x00000
	/* ---:--- */	#define	    bDSFifo16_nWrOff					   16 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo16_nWrOff					    0 /*:15*/
	/* ---:--- */	#define	MSK32DSFifo16_nWrOff					       0x0000FFFF
	/* ---:--- */	#define	GET32DSFifo16_nWrOff(r32)					 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DSFifo16_nWrOff(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSFifo16_nWrOff(r32,v)					do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo16_nWrOff(r16,v)					do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DSFifo16_nMaxSize					 0x00002
	/* ---:--- */	#define	    bDSFifo16_nMaxSize					   16 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo16_nMaxSize					   16 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo16_nMaxSize					       0xFFFF0000
	/* ---:--- */	#define	GET32DSFifo16_nMaxSize(r32)					 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DSFifo16_nMaxSize(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DSFifo16_nMaxSize(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DSFifo16_nMaxSize(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DSFifo16_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DSFifo16_D1th_ 			{										\
					UNSG32				u_pbBase					 : 32;		\
										}
	/* @'00004 */				struct	w32DSFifo16_D1th_;

	/* [31: 0] */	#define	  BA_DSFifo16_pbBase					 0x00004
	/* ---:--- */	#define	    bDSFifo16_pbBase					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo16_pbBase					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo16_pbBase					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo16_pbBase(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo16_pbBase(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo16_pbBase(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo16_pbBase(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DSFifo16;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSFifo16_drvrd (SIE_DSFifo16 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSFifo16_drvwr (SIE_DSFifo16 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSFifo16_reset (SIE_DSFifo16 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSFifo16_check(p,pie,ps8name,hfpErrLOG)		DSFifo16_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSFifo16_print(p,    ps8name,hfpErrLOG)		DSFifo16_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSFifo16_cmp   (SIE_DSFifo16 *p, SIE_DSFifo16 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSFifo16_import(SIE_DSFifo16 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSFifo16_export(SIE_DSFifo16 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSFifo16
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DSFifo32
*	@
*		%unsigned  32  nRdOff  0
*						*  *
*						*  Current FIFO read offset from the base address of the FIFO
*	@
*		%unsigned  32  nWrOff  0
*						*  *
*						*  Current FIFO write offset from the base address of the FIFO
*	@
*		%unsigned  32  pbBase  0
*						*  *
*						*  32-bits address of the FIFO buffer base in DDR
*	@
*		%unsigned  32  nMaxSize  0
*						*  *
*						*  Maximum size of the FIFO size
**********************************************************************************************************************/
#ifdef	h_DSFifo32
#else
#define	h_DSFifo32

#define	\
	AR_DSFifo32 \
		4
#define	\
	AB_DSFifo32 \
		4

typedef struct SIE_DSFifo32 {

	#define	RA_DSFifo32_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32DSFifo32_D0th_ 			{										\
					UNSG32				u_nRdOff					 : 32;		\
										}
	/* @'00000 */				struct	w32DSFifo32_D0th_;

	/* [31: 0] */	#define	  BA_DSFifo32_nRdOff					 0x00000
	/* ---:--- */	#define	    bDSFifo32_nRdOff					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo32_nRdOff					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo32_nRdOff					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo32_nRdOff(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo32_nRdOff(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo32_nRdOff(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo32_nRdOff(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DSFifo32_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DSFifo32_D1th_ 			{										\
					UNSG32				u_nWrOff					 : 32;		\
										}
	/* @'00004 */				struct	w32DSFifo32_D1th_;

	/* [31: 0] */	#define	  BA_DSFifo32_nWrOff					 0x00004
	/* ---:--- */	#define	    bDSFifo32_nWrOff					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo32_nWrOff					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo32_nWrOff					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo32_nWrOff(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo32_nWrOff(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo32_nWrOff(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo32_nWrOff(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DSFifo32_D2th_ 			ISC_USE_ONLY	0x00008
	#define	w32DSFifo32_D2th_ 			{										\
					UNSG32				u_pbBase					 : 32;		\
										}
	/* @'00008 */				struct	w32DSFifo32_D2th_;

	/* [31: 0] */	#define	  BA_DSFifo32_pbBase					 0x00008
	/* ---:--- */	#define	    bDSFifo32_pbBase					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo32_pbBase					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo32_pbBase					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo32_pbBase(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo32_pbBase(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo32_pbBase(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo32_pbBase(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DSFifo32_D3th_ 			ISC_USE_ONLY	0x0000C
	#define	w32DSFifo32_D3th_ 			{										\
					UNSG32				u_nMaxSize					 : 32;		\
										}
	/* @'0000C */				struct	w32DSFifo32_D3th_;

	/* [31: 0] */	#define	  BA_DSFifo32_nMaxSize					 0x0000C
	/* ---:--- */	#define	    bDSFifo32_nMaxSize					   32 /*bit*/
	/* ---:--- */	#define	LSb32DSFifo32_nMaxSize					    0 /*:31*/
	/* ---:--- */	#define	MSK32DSFifo32_nMaxSize					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DSFifo32_nMaxSize(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DSFifo32_nMaxSize(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DSFifo32_nMaxSize(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DSFifo32_nMaxSize(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DSFifo32;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DSFifo32_drvrd (SIE_DSFifo32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DSFifo32_drvwr (SIE_DSFifo32 *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DSFifo32_reset (SIE_DSFifo32 *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DSFifo32_check(p,pie,ps8name,hfpErrLOG)		DSFifo32_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DSFifo32_print(p,    ps8name,hfpErrLOG)		DSFifo32_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DSFifo32_cmp   (SIE_DSFifo32 *p, SIE_DSFifo32 *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DSFifo32_import(SIE_DSFifo32 *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DSFifo32_export(SIE_DSFifo32 *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DSFifo32
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: LocalArea
*	@
*		%unsigned  16  uDsCmdIdRet  REG
*						*  *Data streamer retired command ID
*		%unsigned  16  uNextDsCmdId  REG
*						*  *Next data streamer command ID
*	@
*		$UINT32  uRetCmdSeqNum  REG
*						*  *
*						*  Return command sequence number
*	@  REGDUMP
*		$UINT64  regDumpArea  REG  [32]
*						*  *
*						*  Registers Dumping Area for debug purpose
*	@
*		$DTCMFifo  hboFifoList  REG  [16]
*						*  *
*						*  HBO Fifo Pointer Information
**********************************************************************************************************************/
#ifdef	h_LocalArea
#else
#define	h_LocalArea

#define	\
	AR_LocalArea \
		98
#define	\
	AB_LocalArea \
		9

typedef struct SIE_LocalArea {

	#define	RA_LocalArea_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32LocalArea_D0th_ 			{										\
					UNSG32				u_uDsCmdIdRet				 : 16;		\
					UNSG32				u_uNextDsCmdId				 : 16;		\
										}
	/* @'00000 */				struct	w32LocalArea_D0th_;

	/* [15: 0] */	#define	  BA_LocalArea_uDsCmdIdRet				 0x00000
	/* ---:--- */	#define	    bLocalArea_uDsCmdIdRet				   16 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_uDsCmdIdRet				    0 /*:15*/
	/* ---:--- */	#define	MSK32LocalArea_uDsCmdIdRet				       0x0000FFFF
	/* ---:--- */	#define	GET32LocalArea_uDsCmdIdRet(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16LocalArea_uDsCmdIdRet(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32LocalArea_uDsCmdIdRet(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16LocalArea_uDsCmdIdRet(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_LocalArea_uNextDsCmdId				 0x00002
	/* ---:--- */	#define	    bLocalArea_uNextDsCmdId				   16 /*bit*/
	/* ---:--- */	#define	LSb32LocalArea_uNextDsCmdId				   16 /*:31*/
	/* ---:--- */	#define	MSK32LocalArea_uNextDsCmdId				       0xFFFF0000
	/* ---:--- */	#define	GET32LocalArea_uNextDsCmdId(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16LocalArea_uNextDsCmdId(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32LocalArea_uNextDsCmdId(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16LocalArea_uNextDsCmdId(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_LocalArea_uRetCmdSeqNum 	0x00004
	/* @'00004 */	SIE_UINT32 					ie_uRetCmdSeqNum;

	#define	RA_LocalArea_REGDUMP 		0x00008
	/* @'00008 */	SIE_UINT64 					ie_regDumpArea		 [32];
					#define	 arr_LocalArea_regDumpArea 				  32

	#define	RA_LocalArea_hboFifoList 	0x00108
	/* @'00108 */	SIE_DTCMFifo 				ie_hboFifoList		 [16];
					#define	 arr_LocalArea_hboFifoList 				  16

} SIE_LocalArea;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	LocalArea_drvrd (SIE_LocalArea *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	LocalArea_drvwr (SIE_LocalArea *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	LocalArea_reset (SIE_LocalArea *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	LocalArea_check(p,pie,ps8name,hfpErrLOG)		LocalArea_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	LocalArea_print(p,    ps8name,hfpErrLOG)		LocalArea_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	LocalArea_cmp   (SIE_LocalArea *p, SIE_LocalArea *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	LocalArea_import(SIE_LocalArea *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	LocalArea_export(SIE_LocalArea *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: LocalArea
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: FIGOSYS_OTP
*	@
*		$UINT128  RKEK  0
*						*  *128-bit Root Key Encryption Key (RKEK), which is randomly created, and burned into OTP registers at fist the time boot-up while manufacturing.
*	@
*		$UINT128  VERIFY_KEY  0
*						*  *128-bit signature verification key , which is given by Marvell customer to burn when the system boot up for the first time
*	@
*		$UINT128  UID  0
*						*  *128-bit reserved for customer to save the identification information
*	@
*		$UINT32  FEATURE  0
*						*  *32-bit feature information
*	@
*		$UINT1024  PKEY  0
*						*  *Customers public keys
**********************************************************************************************************************/
#ifdef	h_FIGOSYS_OTP
#else
#define	h_FIGOSYS_OTP

#define	\
	AR_FIGOSYS_OTP \
		45
#define	\
	AB_FIGOSYS_OTP \
		8

typedef struct SIE_FIGOSYS_OTP {

	#define	RA_FIGOSYS_OTP_RKEK 		0x00000
	/* @'00000 */	SIE_UINT128 				ie_RKEK;

	#define	RA_FIGOSYS_OTP_VERIFY_KEY 	0x00010
	/* @'00010 */	SIE_UINT128 				ie_VERIFY_KEY;

	#define	RA_FIGOSYS_OTP_UID 			0x00020
	/* @'00020 */	SIE_UINT128 				ie_UID;

	#define	RA_FIGOSYS_OTP_FEATURE 		0x00030
	/* @'00030 */	SIE_UINT32 					ie_FEATURE;

	#define	RA_FIGOSYS_OTP_PKEY 		0x00034
	/* @'00034 */	SIE_UINT1024 				ie_PKEY;

} SIE_FIGOSYS_OTP;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	FIGOSYS_OTP_drvrd (SIE_FIGOSYS_OTP *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	FIGOSYS_OTP_drvwr (SIE_FIGOSYS_OTP *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	FIGOSYS_OTP_reset (SIE_FIGOSYS_OTP *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	FIGOSYS_OTP_check(p,pie,ps8name,hfpErrLOG)		FIGOSYS_OTP_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	FIGOSYS_OTP_print(p,    ps8name,hfpErrLOG)		FIGOSYS_OTP_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	FIGOSYS_OTP_cmp   (SIE_FIGOSYS_OTP *p, SIE_FIGOSYS_OTP *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	FIGOSYS_OTP_import(SIE_FIGOSYS_OTP *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	FIGOSYS_OTP_export(SIE_FIGOSYS_OTP *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: FIGOSYS_OTP
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SECHF_ENTRY
*	@  (P)
*		%unsigned  2  flag  0
*			:  DISABLED  0
*						*  *
*						*  This entry is disabled
*			:  RO  1
*						*  *
*						*  The entry indicate a BIU register space range which is ready only for ARM
*			:  WO  2
*						*  *
*						*  The entry indicate a BIU register space range which is write only for ARM
*			:  RW  3
*						*  *
*						*  The entry indicate a BIU register space range which can be read and written by ARM
*		%unsigned  14  reserved
*						*  *
*						*  Reserved bits
*		%unsigned  16  regSize  0
*						*  *
*						*  The size of the register spaces   in bytes to be configured
*	@  (RW)
*		%unsigned  32  regAddr  0
*						*  *
*						*  Start offset of the register spaces within the secure processor BIU to be configured
*						*  0
**********************************************************************************************************************/
#ifdef	h_SECHF_ENTRY
#else
#define	h_SECHF_ENTRY

#define	\
	AR_SECHF_ENTRY \
		2
#define	\
	AB_SECHF_ENTRY \
		3

typedef struct SIE_SECHF_ENTRY {

	#define	RA_SECHF_ENTRY_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32SECHF_ENTRY_D0th_ 		{										\
					UNSG32				u_flag						 :  2;		\
					UNSG32				u_reserved					 : 14;		\
					UNSG32				u_regSize					 : 16;		\
										}
	/* @'00000 */				struct	w32SECHF_ENTRY_D0th_;

	/* [ 1: 0] */	#define	  BA_SECHF_ENTRY_flag					 0x00000
	/* ---:--- */	#define	    bSECHF_ENTRY_flag					    2 /*bit*/
	/* ---:--- */	#define	LSb32SECHF_ENTRY_flag					    0 /*: 1*/
	/* ---:--- */	#define	MSK32SECHF_ENTRY_flag					       0x00000003
	/* ---:--- */	#define	GET32SECHF_ENTRY_flag(r32)					 (((r32)>> 0)&0x0003)
	/* ---:--- */	#define	GET16SECHF_ENTRY_flag(r16)					 (((r16)>> 0)&0x0003)
	/* ---:--- */	#define	SET32SECHF_ENTRY_flag(r32,v)				do{(r32)&=~(0x0003<< 0);(r32)|=((v)&0x0003)<< 0;}while(0)
	/* ---:--- */	#define	SET16SECHF_ENTRY_flag(r16,v)				do{(r16)&=~(0x0003<< 0);(r16)|=((v)&0x0003)<< 0;}while(0)
					#define	     SECHF_ENTRY_flag_DISABLED					0x0
					#define	     SECHF_ENTRY_flag_RO						0x1
					#define	     SECHF_ENTRY_flag_WO						0x2
					#define	     SECHF_ENTRY_flag_RW						0x3

	/* [15: 2] */	#define	  BA_SECHF_ENTRY_reserved				 0x00000
	/* ---:--- */	#define	    bSECHF_ENTRY_reserved				   14 /*bit*/
	/* ---:--- */	#define	LSb32SECHF_ENTRY_reserved				    2 /*:15*/
	/* ---:--- */	#define	MSK32SECHF_ENTRY_reserved				       0x0000FFFC
	/* ---:--- */	#define	GET32SECHF_ENTRY_reserved(r32)				 (((r32)>> 2)&0x3FFF)
	/* ---:--- */	#define	GET16SECHF_ENTRY_reserved(r16)				 (((r16)>> 2)&0x3FFF)
	/* ---:--- */	#define	SET32SECHF_ENTRY_reserved(r32,v)			do{(r32)&=~(0x3FFF<< 2);(r32)|=((v)&0x3FFF)<< 2;}while(0)
	/* ---:--- */	#define	SET16SECHF_ENTRY_reserved(r16,v)			do{(r16)&=~(0x3FFF<< 2);(r16)|=((v)&0x3FFF)<< 2;}while(0)

	/* [31:16] */	#define	  BA_SECHF_ENTRY_regSize				 0x00002
	/* ---:--- */	#define	    bSECHF_ENTRY_regSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32SECHF_ENTRY_regSize				   16 /*:31*/
	/* ---:--- */	#define	MSK32SECHF_ENTRY_regSize				       0xFFFF0000
	/* ---:--- */	#define	GET32SECHF_ENTRY_regSize(r32)				 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16SECHF_ENTRY_regSize(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32SECHF_ENTRY_regSize(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16SECHF_ENTRY_regSize(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_SECHF_ENTRY_D1th_ 		ISC_USE_ONLY	0x00004
	#define	w32SECHF_ENTRY_D1th_ 		{										\
					UNSG32				u_regAddr					 : 32;		\
										}
	/* @'00004 */				struct	w32SECHF_ENTRY_D1th_;

	/* [31: 0] */	#define	  BA_SECHF_ENTRY_regAddr				 0x00004
	/* ---:--- */	#define	    bSECHF_ENTRY_regAddr				   32 /*bit*/
	/* ---:--- */	#define	LSb32SECHF_ENTRY_regAddr				    0 /*:31*/
	/* ---:--- */	#define	MSK32SECHF_ENTRY_regAddr				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SECHF_ENTRY_regAddr(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SECHF_ENTRY_regAddr(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SECHF_ENTRY_regAddr(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SECHF_ENTRY_regAddr(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_SECHF_ENTRY;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SECHF_ENTRY_drvrd (SIE_SECHF_ENTRY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SECHF_ENTRY_drvwr (SIE_SECHF_ENTRY *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SECHF_ENTRY_reset (SIE_SECHF_ENTRY *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SECHF_ENTRY_check(p,pie,ps8name,hfpErrLOG)		SECHF_ENTRY_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SECHF_ENTRY_print(p,    ps8name,hfpErrLOG)		SECHF_ENTRY_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SECHF_ENTRY_cmp   (SIE_SECHF_ENTRY *p, SIE_SECHF_ENTRY *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SECHF_ENTRY_import(SIE_SECHF_ENTRY *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SECHF_ENTRY_export(SIE_SECHF_ENTRY *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SECHF_ENTRY
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SECHF
*	@
*		$SECHF_ENTRY  secEntries  [8]
*						*  *
*						*  The entries to define accessible range of the secure processor of the BIU
**********************************************************************************************************************/
#ifdef	h_SECHF
#else
#define	h_SECHF

#define	\
	AR_SECHF \
		2
#define	\
	AB_SECHF \
		3

typedef struct SIE_SECHF {

	#define	RA_SECHF_secEntries 		0x00000
	/* @'00000 */	SIE_SECHF_ENTRY 			ie_secEntries;

} SIE_SECHF;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SECHF_drvrd (SIE_SECHF *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SECHF_drvwr (SIE_SECHF *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SECHF_reset (SIE_SECHF *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SECHF_check(p,pie,ps8name,hfpErrLOG)		SECHF_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SECHF_print(p,    ps8name,hfpErrLOG)		SECHF_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SECHF_cmp   (SIE_SECHF *p, SIE_SECHF *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SECHF_import(SIE_SECHF *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SECHF_export(SIE_SECHF *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SECHF
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: JTAGCTL
*	@
*		%unsigned  1  EN  0
*						*  *
*						*  0 to disable Jtag
*						*  1 to enable Jtag
**********************************************************************************************************************/
#ifdef	h_JTAGCTL
#else
#define	h_JTAGCTL

#define	\
	AR_JTAGCTL \
		1
#define	\
	AB_JTAGCTL \
		2

typedef struct SIE_JTAGCTL {

	#define	RA_JTAGCTL_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32JTAGCTL_D0th_ 			{										\
					UNSG32				u_EN						 :  1;		\
					UNSG32				_x00000	: 31;							\
										}
	/* @'00000 */				struct	w32JTAGCTL_D0th_;

	/* [ 0: 0] */	#define	  BA_JTAGCTL_EN							 0x00000
	/* ---:--- */	#define	    bJTAGCTL_EN							    1 /*bit*/
	/* ---:--- */	#define	LSb32JTAGCTL_EN							    0 /*: 0*/
	/* ---:--- */	#define	MSK32JTAGCTL_EN							       0x00000001
	/* ---:--- */	#define	GET32JTAGCTL_EN(r32)						 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16JTAGCTL_EN(r16)						 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32JTAGCTL_EN(r32,v)						do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16JTAGCTL_EN(r16,v)						do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

} SIE_JTAGCTL;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	JTAGCTL_drvrd (SIE_JTAGCTL *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	JTAGCTL_drvwr (SIE_JTAGCTL *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	JTAGCTL_reset (SIE_JTAGCTL *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	JTAGCTL_check(p,pie,ps8name,hfpErrLOG)		JTAGCTL_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	JTAGCTL_print(p,    ps8name,hfpErrLOG)		JTAGCTL_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	JTAGCTL_cmp   (SIE_JTAGCTL *p, SIE_JTAGCTL *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	JTAGCTL_import(SIE_JTAGCTL *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	JTAGCTL_export(SIE_JTAGCTL *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: JTAGCTL
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SECSTATUS
*	@
*		%unsigned  2  flag  0
*			:  DISABLED  0
*						*  *
*						*  The secure processor is not valid so far
*			:  ENABLED  1
*						*  *
*						*  The secure processor is valid now
*			:  FAILED  1
*						*  *
*						*  The secure processor failed to check the hardware status. The error code is given by errCode. Whenever this flag is specified by 'FAILED', a fatal hardware defection is detected by FIGO. All the BIU firewall will be disabled by ARM.
*		%unsigned  14  Reserved
*		%unsigned  16  errCode
*						*  *
*						*  If flag is FAILED, this field will indicate the error NO
*	@
*		%unsigned  1  secLevelEn  0
*						*  *
*						*  Flag to indicate whether the security level bits are available or not.
*		%unsigned  15  secLevelBits  0
*						*  *
*						*  Current security level bits specified by ARM
**********************************************************************************************************************/
#ifdef	h_SECSTATUS
#else
#define	h_SECSTATUS

#define	\
	AR_SECSTATUS \
		2
#define	\
	AB_SECSTATUS \
		3

typedef struct SIE_SECSTATUS {

	#define	RA_SECSTATUS_D0th_ 			ISC_USE_ONLY	0x00000
	#define	w32SECSTATUS_D0th_ 			{										\
					UNSG32				u_flag						 :  2;		\
					UNSG32				u_Reserved					 : 14;		\
					UNSG32				u_errCode					 : 16;		\
										}
	/* @'00000 */				struct	w32SECSTATUS_D0th_;

	/* [ 1: 0] */	#define	  BA_SECSTATUS_flag						 0x00000
	/* ---:--- */	#define	    bSECSTATUS_flag						    2 /*bit*/
	/* ---:--- */	#define	LSb32SECSTATUS_flag						    0 /*: 1*/
	/* ---:--- */	#define	MSK32SECSTATUS_flag						       0x00000003
	/* ---:--- */	#define	GET32SECSTATUS_flag(r32)					 (((r32)>> 0)&0x0003)
	/* ---:--- */	#define	GET16SECSTATUS_flag(r16)					 (((r16)>> 0)&0x0003)
	/* ---:--- */	#define	SET32SECSTATUS_flag(r32,v)					do{(r32)&=~(0x0003<< 0);(r32)|=((v)&0x0003)<< 0;}while(0)
	/* ---:--- */	#define	SET16SECSTATUS_flag(r16,v)					do{(r16)&=~(0x0003<< 0);(r16)|=((v)&0x0003)<< 0;}while(0)
					#define	     SECSTATUS_flag_DISABLED					0x0
					#define	     SECSTATUS_flag_ENABLED						0x1
					#define	     SECSTATUS_flag_FAILED						0x1

	/* [15: 2] */	#define	  BA_SECSTATUS_Reserved					 0x00000
	/* ---:--- */	#define	    bSECSTATUS_Reserved					   14 /*bit*/
	/* ---:--- */	#define	LSb32SECSTATUS_Reserved					    2 /*:15*/
	/* ---:--- */	#define	MSK32SECSTATUS_Reserved					       0x0000FFFC
	/* ---:--- */	#define	GET32SECSTATUS_Reserved(r32)				 (((r32)>> 2)&0x3FFF)
	/* ---:--- */	#define	GET16SECSTATUS_Reserved(r16)				 (((r16)>> 2)&0x3FFF)
	/* ---:--- */	#define	SET32SECSTATUS_Reserved(r32,v)				do{(r32)&=~(0x3FFF<< 2);(r32)|=((v)&0x3FFF)<< 2;}while(0)
	/* ---:--- */	#define	SET16SECSTATUS_Reserved(r16,v)				do{(r16)&=~(0x3FFF<< 2);(r16)|=((v)&0x3FFF)<< 2;}while(0)

	/* [31:16] */	#define	  BA_SECSTATUS_errCode					 0x00002
	/* ---:--- */	#define	    bSECSTATUS_errCode					   16 /*bit*/
	/* ---:--- */	#define	LSb32SECSTATUS_errCode					   16 /*:31*/
	/* ---:--- */	#define	MSK32SECSTATUS_errCode					       0xFFFF0000
	/* ---:--- */	#define	GET32SECSTATUS_errCode(r32)					 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16SECSTATUS_errCode(r16)					 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32SECSTATUS_errCode(r32,v)				do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16SECSTATUS_errCode(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_SECSTATUS_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32SECSTATUS_D1th_ 			{										\
					UNSG32				u_secLevelEn				 :  1;		\
					UNSG32				u_secLevelBits				 : 15;		\
					UNSG32				_x00004	: 16;							\
										}
	/* @'00004 */				struct	w32SECSTATUS_D1th_;

	/* [ 0: 0] */	#define	  BA_SECSTATUS_secLevelEn				 0x00004
	/* ---:--- */	#define	    bSECSTATUS_secLevelEn				    1 /*bit*/
	/* ---:--- */	#define	LSb32SECSTATUS_secLevelEn				    0 /*: 0*/
	/* ---:--- */	#define	MSK32SECSTATUS_secLevelEn				       0x00000001
	/* ---:--- */	#define	GET32SECSTATUS_secLevelEn(r32)				 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16SECSTATUS_secLevelEn(r16)				 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32SECSTATUS_secLevelEn(r32,v)			do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16SECSTATUS_secLevelEn(r16,v)			do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [15: 1] */	#define	  BA_SECSTATUS_secLevelBits				 0x00004
	/* ---:--- */	#define	    bSECSTATUS_secLevelBits				   15 /*bit*/
	/* ---:--- */	#define	LSb32SECSTATUS_secLevelBits				    1 /*:15*/
	/* ---:--- */	#define	MSK32SECSTATUS_secLevelBits				       0x0000FFFE
	/* ---:--- */	#define	GET32SECSTATUS_secLevelBits(r32)			 (((r32)>> 1)&0x7FFF)
	/* ---:--- */	#define	GET16SECSTATUS_secLevelBits(r16)			 (((r16)>> 1)&0x7FFF)
	/* ---:--- */	#define	SET32SECSTATUS_secLevelBits(r32,v)			do{(r32)&=~(0x7FFF<< 1);(r32)|=((v)&0x7FFF)<< 1;}while(0)
	/* ---:--- */	#define	SET16SECSTATUS_secLevelBits(r16,v)			do{(r16)&=~(0x7FFF<< 1);(r16)|=((v)&0x7FFF)<< 1;}while(0)

} SIE_SECSTATUS;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SECSTATUS_drvrd (SIE_SECSTATUS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SECSTATUS_drvwr (SIE_SECSTATUS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SECSTATUS_reset (SIE_SECSTATUS *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SECSTATUS_check(p,pie,ps8name,hfpErrLOG)		SECSTATUS_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SECSTATUS_print(p,    ps8name,hfpErrLOG)		SECSTATUS_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SECSTATUS_cmp   (SIE_SECSTATUS *p, SIE_SECSTATUS *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SECSTATUS_import(SIE_SECSTATUS *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SECSTATUS_export(SIE_SECSTATUS *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SECSTATUS
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_CTXTYPE
*	@
*			:  AES
*						*  *
*						*  128 bits AES
*			:  DES
*						*  *
*						*  64 bits DES
*			:  3xDES
*						*  *
*			:  RSA1024
*			:  RSA2048
*			:  SHA1
*			:  HMAC
*			:  CMAC
*	@
*		%unsigned  32  dummy
**********************************************************************************************************************/
#ifdef	h_DRM_CTXTYPE
#else
#define	h_DRM_CTXTYPE

#define	\
	AR_DRM_CTXTYPE \
		1
#define	\
	AB_DRM_CTXTYPE \
		2

typedef struct SIE_DRM_CTXTYPE {

	#define	RA_DRM_CTXTYPE_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32DRM_CTXTYPE_D0th_ 		{										\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32DRM_CTXTYPE_D0th_;

	/* [31: 0] */	#define	  BA_DRM_CTXTYPE_dummy					 0x00000
	/* ---:--- */	#define	    bDRM_CTXTYPE_dummy					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXTYPE_dummy					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_CTXTYPE_dummy					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_CTXTYPE_dummy(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_CTXTYPE_dummy(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_CTXTYPE_dummy(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXTYPE_dummy(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRM_CTXTYPE;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_CTXTYPE_drvrd (SIE_DRM_CTXTYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_CTXTYPE_drvwr (SIE_DRM_CTXTYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_CTXTYPE_reset (SIE_DRM_CTXTYPE *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_CTXTYPE_check(p,pie,ps8name,hfpErrLOG)		DRM_CTXTYPE_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_CTXTYPE_print(p,    ps8name,hfpErrLOG)		DRM_CTXTYPE_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_CTXTYPE_cmp   (SIE_DRM_CTXTYPE *p, SIE_DRM_CTXTYPE *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_CTXTYPE_import(SIE_DRM_CTXTYPE *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_CTXTYPE_export(SIE_DRM_CTXTYPE *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_CTXTYPE
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_CTXHDR
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved
*						*  *
*						*  Key parameter
**********************************************************************************************************************/
#ifdef	h_DRM_CTXHDR
#else
#define	h_DRM_CTXHDR

#define	\
	AR_DRM_CTXHDR \
		2
#define	\
	AB_DRM_CTXHDR \
		3

typedef struct SIE_DRM_CTXHDR {

	#define	RA_DRM_CTXHDR_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32DRM_CTXHDR_D0th_ 		{										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_CTXHDR_D0th_;

	/* [15: 0] */	#define	  BA_DRM_CTXHDR_ctxSize					 0x00000
	/* ---:--- */	#define	    bDRM_CTXHDR_ctxSize					   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXHDR_ctxSize					    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_CTXHDR_ctxSize					       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_CTXHDR_ctxSize(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_CTXHDR_ctxSize(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_CTXHDR_ctxSize(r32,v)				do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXHDR_ctxSize(r16,v)				do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_CTXHDR_ctxType					 0x00002
	/* ---:--- */	#define	    bDRM_CTXHDR_ctxType					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXHDR_ctxType					   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_CTXHDR_ctxType					       0x00FF0000
	/* ---:--- */	#define	GET32DRM_CTXHDR_ctxType(r32)				 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_CTXHDR_ctxType(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_CTXHDR_ctxType(r32,v)				do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXHDR_ctxType(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_CTXHDR_D1th_ 		ISC_USE_ONLY	0x00004
	#define	w32DRM_CTXHDR_D1th_ 		{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_CTXHDR_D1th_;

	/* [31: 0] */	#define	  BA_DRM_CTXHDR_reserved				 0x00004
	/* ---:--- */	#define	    bDRM_CTXHDR_reserved				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXHDR_reserved				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_CTXHDR_reserved				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_CTXHDR_reserved(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_CTXHDR_reserved(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_CTXHDR_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXHDR_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRM_CTXHDR;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_CTXHDR_drvrd (SIE_DRM_CTXHDR *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_CTXHDR_drvwr (SIE_DRM_CTXHDR *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_CTXHDR_reset (SIE_DRM_CTXHDR *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_CTXHDR_check(p,pie,ps8name,hfpErrLOG)		DRM_CTXHDR_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_CTXHDR_print(p,    ps8name,hfpErrLOG)		DRM_CTXHDR_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_CTXHDR_cmp   (SIE_DRM_CTXHDR *p, SIE_DRM_CTXHDR *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_CTXHDR_import(SIE_DRM_CTXHDR *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_CTXHDR_export(SIE_DRM_CTXHDR *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_CTXHDR
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_CTXID
*	@  DAT
*		%unsigned  8  ctxID
*						*  *
*						*  Context ID
*			:  RKEK  0x01
*						*  *
*						*  Root Key wrapping key ID
*			:  SIGNK  0x02
*						*  *
*						*  Signature key
*			:  UKEY  0x03
*						*  *
*						*  User key id start
*			:  INVALID  0xff
**********************************************************************************************************************/
#ifdef	h_DRM_CTXID
#else
#define	h_DRM_CTXID

#define	\
	AR_DRM_CTXID \
		1
#define	\
	AB_DRM_CTXID \
		2

typedef struct SIE_DRM_CTXID {

	#define	RA_DRM_CTXID_DAT 			0x00000
	#define	w32DRM_CTXID_DAT 			{										\
					UNSG32				uDAT_ctxID					 :  8;		\
					UNSG32				_x00000	: 24;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRM_CTXID_DAT;
								struct	w32DRM_CTXID_DAT;
										};

	/* [ 7: 0] */	#define	  BA_DRM_CTXID_DAT_ctxID				 0x00000
	/* ---:--- */	#define	    bDRM_CTXID_DAT_ctxID				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CTXID_DAT_ctxID				    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_CTXID_DAT_ctxID				       0x000000FF
	/* ---:--- */	#define	GET32DRM_CTXID_DAT_ctxID(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_CTXID_DAT_ctxID(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_CTXID_DAT_ctxID(r32,v)				do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CTXID_DAT_ctxID(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRM_CTXID_DAT_ctxID_RKEK					0x1
					#define	     DRM_CTXID_DAT_ctxID_SIGNK					0x2
					#define	     DRM_CTXID_DAT_ctxID_UKEY					0x3
					#define	     DRM_CTXID_DAT_ctxID_INVALID				0xFF

} SIE_DRM_CTXID;

	#define	dftDRM_CTXID_DAT 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_CTXID_DAT;
										} T32DRM_CTXID_DAT;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_CTXID_drvrd (SIE_DRM_CTXID *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_CTXID_drvwr (SIE_DRM_CTXID *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_CTXID_reset (SIE_DRM_CTXID *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_CTXID_check(p,pie,ps8name,hfpErrLOG)		DRM_CTXID_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_CTXID_print(p,    ps8name,hfpErrLOG)		DRM_CTXID_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_CTXID_cmp   (SIE_DRM_CTXID *p, SIE_DRM_CTXID *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_CTXID_import(SIE_DRM_CTXID *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_CTXID_export(SIE_DRM_CTXID *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_CTXID
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_KEYPARM
*	@
*		$UINT32  keyParm  [8]
*						*  *
*						*  Reserved key parameter data
**********************************************************************************************************************/
#ifdef	h_DRM_KEYPARM
#else
#define	h_DRM_KEYPARM

#define	\
	AR_DRM_KEYPARM \
		1
#define	\
	AB_DRM_KEYPARM \
		2

typedef struct SIE_DRM_KEYPARM {

	#define	RA_DRM_KEYPARM_keyParm 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_keyParm;

} SIE_DRM_KEYPARM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_KEYPARM_drvrd (SIE_DRM_KEYPARM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_KEYPARM_drvwr (SIE_DRM_KEYPARM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_KEYPARM_reset (SIE_DRM_KEYPARM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_KEYPARM_check(p,pie,ps8name,hfpErrLOG)		DRM_KEYPARM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_KEYPARM_print(p,    ps8name,hfpErrLOG)		DRM_KEYPARM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_KEYPARM_cmp   (SIE_DRM_KEYPARM *p, SIE_DRM_KEYPARM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_KEYPARM_import(SIE_DRM_KEYPARM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_KEYPARM_export(SIE_DRM_KEYPARM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_KEYPARM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_KEYPARM_RSA
*	@
*		%unsigned  16  keyLen
*						*  *
*						*  The size of the RSA key in bits
*		%unsigned  16  numPrimes  0
*						*  *
*						*  the number of prime factors used by this RSA key.
*	@
*		%unsigned  16  exponentSize  0
*						*  *
*						*  the size of the exponent. If the key is using the default exponent then the exponentSize MUST be 0.
**********************************************************************************************************************/
#ifdef	h_DRM_KEYPARM_RSA
#else
#define	h_DRM_KEYPARM_RSA

#define	\
	AR_DRM_KEYPARM_RSA \
		2
#define	\
	AB_DRM_KEYPARM_RSA \
		3

typedef struct SIE_DRM_KEYPARM_RSA {

	#define	RA_DRM_KEYPARM_RSA_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRM_KEYPARM_RSA_D0th_ 	{										\
					UNSG32				u_keyLen					 : 16;		\
					UNSG32				u_numPrimes					 : 16;		\
										}
	/* @'00000 */				struct	w32DRM_KEYPARM_RSA_D0th_;

	/* [15: 0] */	#define	  BA_DRM_KEYPARM_RSA_keyLen				 0x00000
	/* ---:--- */	#define	    bDRM_KEYPARM_RSA_keyLen				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_RSA_keyLen				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_RSA_keyLen				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYPARM_RSA_keyLen(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_RSA_keyLen(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_RSA_keyLen(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_RSA_keyLen(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_KEYPARM_RSA_numPrimes			 0x00002
	/* ---:--- */	#define	    bDRM_KEYPARM_RSA_numPrimes			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_RSA_numPrimes			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_RSA_numPrimes			       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_KEYPARM_RSA_numPrimes(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_RSA_numPrimes(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_RSA_numPrimes(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_RSA_numPrimes(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_KEYPARM_RSA_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32DRM_KEYPARM_RSA_D1th_ 	{										\
					UNSG32				u_exponentSize				 : 16;		\
					UNSG32				_x00004	: 16;							\
										}
	/* @'00004 */				struct	w32DRM_KEYPARM_RSA_D1th_;

	/* [15: 0] */	#define	  BA_DRM_KEYPARM_RSA_exponentSize		 0x00004
	/* ---:--- */	#define	    bDRM_KEYPARM_RSA_exponentSize		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_RSA_exponentSize		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_RSA_exponentSize		       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYPARM_RSA_exponentSize(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_RSA_exponentSize(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_RSA_exponentSize(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_RSA_exponentSize(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_DRM_KEYPARM_RSA;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_KEYPARM_RSA_drvrd (SIE_DRM_KEYPARM_RSA *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_KEYPARM_RSA_drvwr (SIE_DRM_KEYPARM_RSA *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_KEYPARM_RSA_reset (SIE_DRM_KEYPARM_RSA *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_KEYPARM_RSA_check(p,pie,ps8name,hfpErrLOG)		DRM_KEYPARM_RSA_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_KEYPARM_RSA_print(p,    ps8name,hfpErrLOG)		DRM_KEYPARM_RSA_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_KEYPARM_RSA_cmp   (SIE_DRM_KEYPARM_RSA *p, SIE_DRM_KEYPARM_RSA *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_KEYPARM_RSA_import(SIE_DRM_KEYPARM_RSA *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_KEYPARM_RSA_export(SIE_DRM_KEYPARM_RSA *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_KEYPARM_RSA
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_KEYPARM_SYM
*	@
*		%unsigned  16  keyLen
*						*  *
*						*  indicate the length of the key in bits
*		%unsigned  16  blockSize  0
*						*  *
*						*  indicate the block size of the algorithm
*	@
*		%unsigned  16  ivSiz  0
*						*  *
*						*  indicate the size of the IV
*		%unsigned  16  keyMode  0
*						*  *
*						*  indicate the encryption and decryption mode
*	@
*		$UINT128  ivData  0
*						*  *
*						*  The initialization vector
**********************************************************************************************************************/
#ifdef	h_DRM_KEYPARM_SYM
#else
#define	h_DRM_KEYPARM_SYM

#define	\
	AR_DRM_KEYPARM_SYM \
		6
#define	\
	AB_DRM_KEYPARM_SYM \
		5

typedef struct SIE_DRM_KEYPARM_SYM {

	#define	RA_DRM_KEYPARM_SYM_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRM_KEYPARM_SYM_D0th_ 	{										\
					UNSG32				u_keyLen					 : 16;		\
					UNSG32				u_blockSize					 : 16;		\
										}
	/* @'00000 */				struct	w32DRM_KEYPARM_SYM_D0th_;

	/* [15: 0] */	#define	  BA_DRM_KEYPARM_SYM_keyLen				 0x00000
	/* ---:--- */	#define	    bDRM_KEYPARM_SYM_keyLen				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_SYM_keyLen				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_SYM_keyLen				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYPARM_SYM_keyLen(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_SYM_keyLen(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_SYM_keyLen(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_SYM_keyLen(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_KEYPARM_SYM_blockSize			 0x00002
	/* ---:--- */	#define	    bDRM_KEYPARM_SYM_blockSize			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_SYM_blockSize			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_SYM_blockSize			       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_KEYPARM_SYM_blockSize(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_SYM_blockSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_SYM_blockSize(r32,v)		do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_SYM_blockSize(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_KEYPARM_SYM_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32DRM_KEYPARM_SYM_D1th_ 	{										\
					UNSG32				u_ivSiz						 : 16;		\
					UNSG32				u_keyMode					 : 16;		\
										}
	/* @'00004 */				struct	w32DRM_KEYPARM_SYM_D1th_;

	/* [15: 0] */	#define	  BA_DRM_KEYPARM_SYM_ivSiz				 0x00004
	/* ---:--- */	#define	    bDRM_KEYPARM_SYM_ivSiz				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_SYM_ivSiz				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_SYM_ivSiz				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYPARM_SYM_ivSiz(r32)				 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_SYM_ivSiz(r16)				 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_SYM_ivSiz(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_SYM_ivSiz(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_KEYPARM_SYM_keyMode			 0x00006
	/* ---:--- */	#define	    bDRM_KEYPARM_SYM_keyMode			   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYPARM_SYM_keyMode			   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_KEYPARM_SYM_keyMode			       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_KEYPARM_SYM_keyMode(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYPARM_SYM_keyMode(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYPARM_SYM_keyMode(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYPARM_SYM_keyMode(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_KEYPARM_SYM_ivData 	0x00008
	/* @'00008 */	SIE_UINT128 				ie_ivData;

} SIE_DRM_KEYPARM_SYM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_KEYPARM_SYM_drvrd (SIE_DRM_KEYPARM_SYM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_KEYPARM_SYM_drvwr (SIE_DRM_KEYPARM_SYM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_KEYPARM_SYM_reset (SIE_DRM_KEYPARM_SYM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_KEYPARM_SYM_check(p,pie,ps8name,hfpErrLOG)		DRM_KEYPARM_SYM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_KEYPARM_SYM_print(p,    ps8name,hfpErrLOG)		DRM_KEYPARM_SYM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_KEYPARM_SYM_cmp   (SIE_DRM_KEYPARM_SYM *p, SIE_DRM_KEYPARM_SYM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_KEYPARM_SYM_import(SIE_DRM_KEYPARM_SYM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_KEYPARM_SYM_export(SIE_DRM_KEYPARM_SYM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_KEYPARM_SYM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_DIGEST
*	@
*		$DRM_CTXID  sigKey
*						*  *
*						*  Signature key
*	@
*		%unsigned  32  reserved
*						*  *
*						*  Reserved bits
*	@
*		$UINT32  hashVal  REG  [6]
*						*  *
*						*  Digest value
**********************************************************************************************************************/
#ifdef	h_DRM_DIGEST
#else
#define	h_DRM_DIGEST

#define	\
	AR_DRM_DIGEST \
		8
#define	\
	AB_DRM_DIGEST \
		5

typedef struct SIE_DRM_DIGEST {

	#define	RA_DRM_DIGEST_sigKey 		0x00000
	/* @'00000 */	SIE_DRM_CTXID 				ie_sigKey;

	#define	RA_DRM_DIGEST_D1th_ 		ISC_USE_ONLY	0x00004
	#define	w32DRM_DIGEST_D1th_ 		{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_DIGEST_D1th_;

	/* [31: 0] */	#define	  BA_DRM_DIGEST_reserved				 0x00004
	/* ---:--- */	#define	    bDRM_DIGEST_reserved				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_DIGEST_reserved				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_DIGEST_reserved				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_DIGEST_reserved(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_DIGEST_reserved(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_DIGEST_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_DIGEST_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_DIGEST_hashVal 		0x00008
	/* @'00008 */	SIE_UINT32 					ie_hashVal			 [6];
					#define	 arr_DRM_DIGEST_hashVal 				  6

} SIE_DRM_DIGEST;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_DIGEST_drvrd (SIE_DRM_DIGEST *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_DIGEST_drvwr (SIE_DRM_DIGEST *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_DIGEST_reset (SIE_DRM_DIGEST *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_DIGEST_check(p,pie,ps8name,hfpErrLOG)		DRM_DIGEST_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_DIGEST_print(p,    ps8name,hfpErrLOG)		DRM_DIGEST_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_DIGEST_cmp   (SIE_DRM_DIGEST *p, SIE_DRM_DIGEST *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_DIGEST_import(SIE_DRM_DIGEST *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_DIGEST_export(SIE_DRM_DIGEST *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_DIGEST
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_SUBKEY_OUT
*	@
*		$DRM_CTXID  parentKeyID
*						*  *
*						*  Parent key ID. It can be RKEK ID or SIGNKEY ID
*	@
*		$UINT32  reserved  REG  [3]
*	@
*		$UINT128  keyData
*						*  *
*						*  Sub key cipher text protected by RKEK
*	@
*		$DRM_DIGEST  keyHash
*						*  *
*						*  Hash value of the sub key plain text
**********************************************************************************************************************/
#ifdef	h_DRM_SUBKEY_OUT
#else
#define	h_DRM_SUBKEY_OUT

#define	\
	AR_DRM_SUBKEY_OUT \
		16
#define	\
	AB_DRM_SUBKEY_OUT \
		6

typedef struct SIE_DRM_SUBKEY_OUT {

	#define	RA_DRM_SUBKEY_OUT_parentKeyID 0x00000
	/* @'00000 */	SIE_DRM_CTXID 				ie_parentKeyID;

	#define	RA_DRM_SUBKEY_OUT_reserved 	0x00004
	/* @'00004 */	SIE_UINT32 					ie_reserved			 [3];
					#define	 arr_DRM_SUBKEY_OUT_reserved 			  3

	#define	RA_DRM_SUBKEY_OUT_keyData 	0x00010
	/* @'00010 */	SIE_UINT128 				ie_keyData;

	#define	RA_DRM_SUBKEY_OUT_keyHash 	0x00020
	/* @'00020 */	SIE_DRM_DIGEST 				ie_keyHash;

} SIE_DRM_SUBKEY_OUT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_SUBKEY_OUT_drvrd (SIE_DRM_SUBKEY_OUT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_SUBKEY_OUT_drvwr (SIE_DRM_SUBKEY_OUT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_SUBKEY_OUT_reset (SIE_DRM_SUBKEY_OUT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_SUBKEY_OUT_check(p,pie,ps8name,hfpErrLOG)		DRM_SUBKEY_OUT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_SUBKEY_OUT_print(p,    ps8name,hfpErrLOG)		DRM_SUBKEY_OUT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_SUBKEY_OUT_cmp   (SIE_DRM_SUBKEY_OUT *p, SIE_DRM_SUBKEY_OUT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_SUBKEY_OUT_import(SIE_DRM_SUBKEY_OUT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_SUBKEY_OUT_export(SIE_DRM_SUBKEY_OUT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_SUBKEY_OUT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_KEYCTX_OUT
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved
*						*  *
*						*  Reserved
*	@
*		$DRM_KEYPARM  keyParm
*						*  *
*						*  Key parameter
*	@
*		$DRM_DIGEST  hashVal
*						*  *
*						*  Cipher text SHA1 hash value
*	@
*		$UINT64  cipherTxt
*						*  *
*						*  Cipher text of the key context
**********************************************************************************************************************/
#ifdef	h_DRM_KEYCTX_OUT
#else
#define	h_DRM_KEYCTX_OUT

#define	\
	AR_DRM_KEYCTX_OUT \
		13
#define	\
	AB_DRM_KEYCTX_OUT \
		6

typedef struct SIE_DRM_KEYCTX_OUT {

	#define	RA_DRM_KEYCTX_OUT_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRM_KEYCTX_OUT_D0th_ 	{										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_KEYCTX_OUT_D0th_;

	/* [15: 0] */	#define	  BA_DRM_KEYCTX_OUT_ctxSize				 0x00000
	/* ---:--- */	#define	    bDRM_KEYCTX_OUT_ctxSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYCTX_OUT_ctxSize				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_KEYCTX_OUT_ctxSize				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_KEYCTX_OUT_ctxSize(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_KEYCTX_OUT_ctxSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_KEYCTX_OUT_ctxSize(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYCTX_OUT_ctxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_KEYCTX_OUT_ctxType				 0x00002
	/* ---:--- */	#define	    bDRM_KEYCTX_OUT_ctxType				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYCTX_OUT_ctxType				   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_KEYCTX_OUT_ctxType				       0x00FF0000
	/* ---:--- */	#define	GET32DRM_KEYCTX_OUT_ctxType(r32)			 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_KEYCTX_OUT_ctxType(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_KEYCTX_OUT_ctxType(r32,v)			do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYCTX_OUT_ctxType(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_KEYCTX_OUT_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32DRM_KEYCTX_OUT_D1th_ 	{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_KEYCTX_OUT_D1th_;

	/* [31: 0] */	#define	  BA_DRM_KEYCTX_OUT_reserved			 0x00004
	/* ---:--- */	#define	    bDRM_KEYCTX_OUT_reserved			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_KEYCTX_OUT_reserved			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_KEYCTX_OUT_reserved			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_KEYCTX_OUT_reserved(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_KEYCTX_OUT_reserved(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_KEYCTX_OUT_reserved(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_KEYCTX_OUT_reserved(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_KEYCTX_OUT_keyParm 	0x00008
	/* @'00008 */	SIE_DRM_KEYPARM 			ie_keyParm;

	#define	RA_DRM_KEYCTX_OUT_hashVal 	0x0000C
	/* @'0000C */	SIE_DRM_DIGEST 				ie_hashVal;

	#define	RA_DRM_KEYCTX_OUT_cipherTxt 0x0002C
	/* @'0002C */	SIE_UINT64 					ie_cipherTxt;

} SIE_DRM_KEYCTX_OUT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_KEYCTX_OUT_drvrd (SIE_DRM_KEYCTX_OUT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_KEYCTX_OUT_drvwr (SIE_DRM_KEYCTX_OUT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_KEYCTX_OUT_reset (SIE_DRM_KEYCTX_OUT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_KEYCTX_OUT_check(p,pie,ps8name,hfpErrLOG)		DRM_KEYCTX_OUT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_KEYCTX_OUT_print(p,    ps8name,hfpErrLOG)		DRM_KEYCTX_OUT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_KEYCTX_OUT_cmp   (SIE_DRM_KEYCTX_OUT *p, SIE_DRM_KEYCTX_OUT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_KEYCTX_OUT_import(SIE_DRM_KEYCTX_OUT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_KEYCTX_OUT_export(SIE_DRM_KEYCTX_OUT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_KEYCTX_OUT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_SYMKEYCTX256_IN
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved0
*						*  *
*						*  Reserved
*	@
*		$DRM_KEYPARM_SYM  keyParm
*						*  *
*						*  Key parameter
*	@
*		$DRM_DIGEST  hashVal
*						*  *
*						*  Cipher text SHA1 hash value
*	@
*		%unsigned  8  keyUsageRule
*						*  *
*						*  Context usage rules
*			:  KUL_SIGN  0x01
*						*  *
*						*  a signing key
*			:  KUL_KEK  0x02
*						*  *
*						*  wrap and unwrap other keys
*			:  KUL_ENC  0x04
*						*  *
*						*  Encrypt data
*			:  KUL_DEC  0x04
*						*  *
*						*  Decrypt data
*			:  KUL_EXPORT  0x08
*						*  *
*						*  Exportable keys
*			:  KUL_AUTH  0x10
*						*  *
*						*  Key usage authentication or not
*	@
*		%unsigned  32  reserved1
*						*  *
*						*  Reserved
*	@
*		$UINT64  keyPwd
*						*  *
*						*  Authentication password
*	@
*		$UINT128  keyData
*						*  *
*						*  Algorithm specific of the key data
**********************************************************************************************************************/
#ifdef	h_DRM_SYMKEYCTX256_IN
#else
#define	h_DRM_SYMKEYCTX256_IN

#define	\
	AR_DRM_SYMKEYCTX256_IN \
		24
#define	\
	AB_DRM_SYMKEYCTX256_IN \
		7

typedef struct SIE_DRM_SYMKEYCTX256_IN {

	#define	RA_DRM_SYMKEYCTX256_IN_D0th_ ISC_USE_ONLY	0x00000
	#define	w32DRM_SYMKEYCTX256_IN_D0th_ {										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_SYMKEYCTX256_IN_D0th_;

	/* [15: 0] */	#define	  BA_DRM_SYMKEYCTX256_IN_ctxSize		 0x00000
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_ctxSize		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_ctxSize		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_ctxSize		       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_ctxSize(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_ctxSize(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_ctxSize(r32,v)		do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_ctxSize(r16,v)		do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_SYMKEYCTX256_IN_ctxType		 0x00002
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_ctxType		    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_ctxType		   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_ctxType		       0x00FF0000
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_ctxType(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_ctxType(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_ctxType(r32,v)		do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_ctxType(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_SYMKEYCTX256_IN_D1th_ ISC_USE_ONLY	0x00004
	#define	w32DRM_SYMKEYCTX256_IN_D1th_ {										\
					UNSG32				u_reserved0					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_SYMKEYCTX256_IN_D1th_;

	/* [31: 0] */	#define	  BA_DRM_SYMKEYCTX256_IN_reserved0		 0x00004
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_reserved0		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_reserved0		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_reserved0		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_reserved0(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_reserved0(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_reserved0(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_reserved0(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_SYMKEYCTX256_IN_keyParm 0x00008
	/* @'00008 */	SIE_DRM_KEYPARM_SYM 		ie_keyParm;

	#define	RA_DRM_SYMKEYCTX256_IN_hashVal 0x00020
	/* @'00020 */	SIE_DRM_DIGEST 				ie_hashVal;

	#define	RA_DRM_SYMKEYCTX256_IN_D16th_ ISC_USE_ONLY	0x00040
	#define	w32DRM_SYMKEYCTX256_IN_D16th_ {										\
					UNSG32				u_keyUsageRule				 :  8;		\
					UNSG32				_x00040	: 24;							\
										}
	/* @'00040 */				struct	w32DRM_SYMKEYCTX256_IN_D16th_;

	/* [ 7: 0] */	#define	  BA_DRM_SYMKEYCTX256_IN_keyUsageRule	 0x00040
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_keyUsageRule	    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_keyUsageRule	    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_keyUsageRule	       0x000000FF
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_keyUsageRule(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_keyUsageRule(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_keyUsageRule(r32,v)do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_keyUsageRule(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_SIGN	0x1
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_KEK	0x2
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_ENC	0x4
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_DEC	0x4
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_EXPORT	0x8
					#define	     DRM_SYMKEYCTX256_IN_keyUsageRule_KUL_AUTH	0x10

	#define	RA_DRM_SYMKEYCTX256_IN_D17th_ ISC_USE_ONLY	0x00044
	#define	w32DRM_SYMKEYCTX256_IN_D17th_ {										\
					UNSG32				u_reserved1					 : 32;		\
										}
	/* @'00044 */				struct	w32DRM_SYMKEYCTX256_IN_D17th_;

	/* [31: 0] */	#define	  BA_DRM_SYMKEYCTX256_IN_reserved1		 0x00044
	/* ---:--- */	#define	    bDRM_SYMKEYCTX256_IN_reserved1		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_SYMKEYCTX256_IN_reserved1		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_SYMKEYCTX256_IN_reserved1		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_SYMKEYCTX256_IN_reserved1(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_SYMKEYCTX256_IN_reserved1(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_SYMKEYCTX256_IN_reserved1(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_SYMKEYCTX256_IN_reserved1(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_SYMKEYCTX256_IN_keyPwd 0x00048
	/* @'00048 */	SIE_UINT64 					ie_keyPwd;

	#define	RA_DRM_SYMKEYCTX256_IN_keyData 0x00050
	/* @'00050 */	SIE_UINT128 				ie_keyData;

} SIE_DRM_SYMKEYCTX256_IN;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_SYMKEYCTX256_IN_drvrd (SIE_DRM_SYMKEYCTX256_IN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_SYMKEYCTX256_IN_drvwr (SIE_DRM_SYMKEYCTX256_IN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_SYMKEYCTX256_IN_reset (SIE_DRM_SYMKEYCTX256_IN *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_SYMKEYCTX256_IN_check(p,pie,ps8name,hfpErrLOG)		DRM_SYMKEYCTX256_IN_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_SYMKEYCTX256_IN_print(p,    ps8name,hfpErrLOG)		DRM_SYMKEYCTX256_IN_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_SYMKEYCTX256_IN_cmp   (SIE_DRM_SYMKEYCTX256_IN *p, SIE_DRM_SYMKEYCTX256_IN *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_SYMKEYCTX256_IN_import(SIE_DRM_SYMKEYCTX256_IN *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_SYMKEYCTX256_IN_export(SIE_DRM_SYMKEYCTX256_IN *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_SYMKEYCTX256_IN
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_RSAKEYCTX1024_IN
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved0
*						*  *
*						*  Reserved
*	@
*		$DRM_KEYPARM_RSA  keyParm
*						*  *
*						*  Key parameter
*	@
*		$DRM_DIGEST  hashVal
*						*  *
*						*  Cipher text SHA1 hash value
*	@
*		%unsigned  8  keyUsageRule
*						*  *
*						*  Context usage rules
*			:  KUL_SIGN  0x01
*						*  *
*						*  a signing key
*			:  KUL_KEK  0x02
*						*  *
*						*  wrap and unwrap other keys
*			:  KUL_ENC  0x04
*						*  *
*						*  Encrypt data
*			:  KUL_DEC  0x04
*						*  *
*						*  Decrypt data
*			:  KUL_EXPORT  0x08
*						*  *
*						*  Exportable keys
*			:  KUL_AUTH  0x10
*						*  *
*						*  Key usage authentication or not
*	@
*		%unsigned  32  reserved1
*						*  *
*						*  Reserved
*	@
*		$UINT64  keyPwd
*						*  *
*						*  Authentication password
*	@
*		$UINT128  keyData  [16]
*						*  *
*						*  Algorithm specific of the key data
**********************************************************************************************************************/
#ifdef	h_DRM_RSAKEYCTX1024_IN
#else
#define	h_DRM_RSAKEYCTX1024_IN

#define	\
	AR_DRM_RSAKEYCTX1024_IN \
		20
#define	\
	AB_DRM_RSAKEYCTX1024_IN \
		7

typedef struct SIE_DRM_RSAKEYCTX1024_IN {

	#define	RA_DRM_RSAKEYCTX1024_IN_D0th_ ISC_USE_ONLY	0x00000
	#define	w32DRM_RSAKEYCTX1024_IN_D0th_ {										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_RSAKEYCTX1024_IN_D0th_;

	/* [15: 0] */	#define	  BA_DRM_RSAKEYCTX1024_IN_ctxSize		 0x00000
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_ctxSize		   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_ctxSize		    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_ctxSize		       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_ctxSize(r32)		 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_ctxSize(r16)		 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_ctxSize(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_ctxSize(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_RSAKEYCTX1024_IN_ctxType		 0x00002
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_ctxType		    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_ctxType		   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_ctxType		       0x00FF0000
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_ctxType(r32)		 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_ctxType(r16)		 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_ctxType(r32,v)	do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_ctxType(r16,v)	do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_RSAKEYCTX1024_IN_D1th_ ISC_USE_ONLY	0x00004
	#define	w32DRM_RSAKEYCTX1024_IN_D1th_ {										\
					UNSG32				u_reserved0					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_RSAKEYCTX1024_IN_D1th_;

	/* [31: 0] */	#define	  BA_DRM_RSAKEYCTX1024_IN_reserved0		 0x00004
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_reserved0		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_reserved0		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_reserved0		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_reserved0(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_reserved0(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_reserved0(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_reserved0(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_RSAKEYCTX1024_IN_keyParm 0x00008
	/* @'00008 */	SIE_DRM_KEYPARM_RSA 		ie_keyParm;

	#define	RA_DRM_RSAKEYCTX1024_IN_hashVal 0x00010
	/* @'00010 */	SIE_DRM_DIGEST 				ie_hashVal;

	#define	RA_DRM_RSAKEYCTX1024_IN_D12th_ ISC_USE_ONLY	0x00030
	#define	w32DRM_RSAKEYCTX1024_IN_D12th_ {									\
					UNSG32				u_keyUsageRule				 :  8;		\
					UNSG32				_x00030	: 24;							\
										}
	/* @'00030 */				struct	w32DRM_RSAKEYCTX1024_IN_D12th_;

	/* [ 7: 0] */	#define	  BA_DRM_RSAKEYCTX1024_IN_keyUsageRule	 0x00030
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_keyUsageRule	    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_keyUsageRule	    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_keyUsageRule	       0x000000FF
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_keyUsageRule(r32)	 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_keyUsageRule(r16)	 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_keyUsageRule(r32,v)do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_keyUsageRule(r16,v)do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)
					#define	     DRM_RSAKEYCTX1024_IN_keyUsageRule_KUL_SIGN	0x1
					#define	     DRM_RSAKEYCTX1024_IN_keyUsageRule_KUL_KEK	0x2
					#define	     DRM_RSAKEYCTX1024_IN_keyUsageRule_KUL_ENC	0x4
					#define	     DRM_RSAKEYCTX1024_IN_keyUsageRule_KUL_DEC	0x4
					#define	     DRM_RSAKEYCTX1024_IN_keyUsageRule_KUL_EXPORT	0x8
					#define	     DRM_RSAKEYCTX1024_IN_keyUsageRule_KUL_AUTH	0x10

	#define	RA_DRM_RSAKEYCTX1024_IN_D13th_ ISC_USE_ONLY	0x00034
	#define	w32DRM_RSAKEYCTX1024_IN_D13th_ {									\
					UNSG32				u_reserved1					 : 32;		\
										}
	/* @'00034 */				struct	w32DRM_RSAKEYCTX1024_IN_D13th_;

	/* [31: 0] */	#define	  BA_DRM_RSAKEYCTX1024_IN_reserved1		 0x00034
	/* ---:--- */	#define	    bDRM_RSAKEYCTX1024_IN_reserved1		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSAKEYCTX1024_IN_reserved1		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSAKEYCTX1024_IN_reserved1		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSAKEYCTX1024_IN_reserved1(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSAKEYCTX1024_IN_reserved1(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSAKEYCTX1024_IN_reserved1(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSAKEYCTX1024_IN_reserved1(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_RSAKEYCTX1024_IN_keyPwd 0x00038
	/* @'00038 */	SIE_UINT64 					ie_keyPwd;

	#define	RA_DRM_RSAKEYCTX1024_IN_keyData 0x00040
	/* @'00040 */	SIE_UINT128 				ie_keyData;

} SIE_DRM_RSAKEYCTX1024_IN;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_RSAKEYCTX1024_IN_drvrd (SIE_DRM_RSAKEYCTX1024_IN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_RSAKEYCTX1024_IN_drvwr (SIE_DRM_RSAKEYCTX1024_IN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_RSAKEYCTX1024_IN_reset (SIE_DRM_RSAKEYCTX1024_IN *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_RSAKEYCTX1024_IN_check(p,pie,ps8name,hfpErrLOG)		DRM_RSAKEYCTX1024_IN_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_RSAKEYCTX1024_IN_print(p,    ps8name,hfpErrLOG)		DRM_RSAKEYCTX1024_IN_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_RSAKEYCTX1024_IN_cmp   (SIE_DRM_RSAKEYCTX1024_IN *p, SIE_DRM_RSAKEYCTX1024_IN *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_RSAKEYCTX1024_IN_import(SIE_DRM_RSAKEYCTX1024_IN *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_RSAKEYCTX1024_IN_export(SIE_DRM_RSAKEYCTX1024_IN *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_RSAKEYCTX1024_IN
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_HASH_CTXIN
*	@
*		%unsigned  16  ctxSize
*						*  *
*						*  Context size
*		%unsigned  8  ctxType
*						*  *
*						*  Context type
*	@
*		%unsigned  32  reserved
*						*  *
*						*  Reserved
*	@
*		%unsigned  32  ctxData
*						*  *
*						*  Reserved
**********************************************************************************************************************/
#ifdef	h_DRM_HASH_CTXIN
#else
#define	h_DRM_HASH_CTXIN

#define	\
	AR_DRM_HASH_CTXIN \
		3
#define	\
	AB_DRM_HASH_CTXIN \
		4

typedef struct SIE_DRM_HASH_CTXIN {

	#define	RA_DRM_HASH_CTXIN_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRM_HASH_CTXIN_D0th_ 	{										\
					UNSG32				u_ctxSize					 : 16;		\
					UNSG32				u_ctxType					 :  8;		\
					UNSG32				_x00000	:  8;							\
										}
	/* @'00000 */				struct	w32DRM_HASH_CTXIN_D0th_;

	/* [15: 0] */	#define	  BA_DRM_HASH_CTXIN_ctxSize				 0x00000
	/* ---:--- */	#define	    bDRM_HASH_CTXIN_ctxSize				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_HASH_CTXIN_ctxSize				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_HASH_CTXIN_ctxSize				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_HASH_CTXIN_ctxSize(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_HASH_CTXIN_ctxSize(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_HASH_CTXIN_ctxSize(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_HASH_CTXIN_ctxSize(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [23:16] */	#define	  BA_DRM_HASH_CTXIN_ctxType				 0x00002
	/* ---:--- */	#define	    bDRM_HASH_CTXIN_ctxType				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_HASH_CTXIN_ctxType				   16 /*:23*/
	/* ---:--- */	#define	MSK32DRM_HASH_CTXIN_ctxType				       0x00FF0000
	/* ---:--- */	#define	GET32DRM_HASH_CTXIN_ctxType(r32)			 (((r32)>>16)&0x00FF)
	/* ---:--- */	#define	GET16DRM_HASH_CTXIN_ctxType(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_HASH_CTXIN_ctxType(r32,v)			do{(r32)&=~(0x00FF<<16);(r32)|=((v)&0x00FF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_HASH_CTXIN_ctxType(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_HASH_CTXIN_D1th_ 	ISC_USE_ONLY	0x00004
	#define	w32DRM_HASH_CTXIN_D1th_ 	{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_HASH_CTXIN_D1th_;

	/* [31: 0] */	#define	  BA_DRM_HASH_CTXIN_reserved			 0x00004
	/* ---:--- */	#define	    bDRM_HASH_CTXIN_reserved			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_HASH_CTXIN_reserved			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_HASH_CTXIN_reserved			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_HASH_CTXIN_reserved(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_HASH_CTXIN_reserved(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_HASH_CTXIN_reserved(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_HASH_CTXIN_reserved(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_HASH_CTXIN_D2th_ 	ISC_USE_ONLY	0x00008
	#define	w32DRM_HASH_CTXIN_D2th_ 	{										\
					UNSG32				u_ctxData					 : 32;		\
										}
	/* @'00008 */				struct	w32DRM_HASH_CTXIN_D2th_;

	/* [31: 0] */	#define	  BA_DRM_HASH_CTXIN_ctxData				 0x00008
	/* ---:--- */	#define	    bDRM_HASH_CTXIN_ctxData				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_HASH_CTXIN_ctxData				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_HASH_CTXIN_ctxData				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_HASH_CTXIN_ctxData(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_HASH_CTXIN_ctxData(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_HASH_CTXIN_ctxData(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_HASH_CTXIN_ctxData(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRM_HASH_CTXIN;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_HASH_CTXIN_drvrd (SIE_DRM_HASH_CTXIN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_HASH_CTXIN_drvwr (SIE_DRM_HASH_CTXIN *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_HASH_CTXIN_reset (SIE_DRM_HASH_CTXIN *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_HASH_CTXIN_check(p,pie,ps8name,hfpErrLOG)		DRM_HASH_CTXIN_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_HASH_CTXIN_print(p,    ps8name,hfpErrLOG)		DRM_HASH_CTXIN_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_HASH_CTXIN_cmp   (SIE_DRM_HASH_CTXIN *p, SIE_DRM_HASH_CTXIN *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_HASH_CTXIN_import(SIE_DRM_HASH_CTXIN *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_HASH_CTXIN_export(SIE_DRM_HASH_CTXIN *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_HASH_CTXIN
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_FIGOIMG
*	@
*		$DRM_SUBKEY_OUT  encKey
*						*  *
*						*  Image protection Key
*	@
*		$DRM_DIGEST  authData
*						*  *
*						*  Authentication information signed by sigKey
*	@
*		$UINT128  bindInfo
*						*  *
*						*  Platform binding information to indicate what type of underling hardware to run this firmware
*	@  CFG
*		%unsigned  16  insNum  0
*						*  *
*						*  Static data area size in 64bits entries
*		%unsigned  16  datCnt
*						*  *
*						*  Static data area size in 64bits entries
*	@
*		$UINT32  reserved  REG  [3]
*						*  *
*						*  Reserved bits
*	@
*		$UINT32  imgDat
**********************************************************************************************************************/
#ifdef	h_DRM_FIGOIMG
#else
#define	h_DRM_FIGOIMG

#define	\
	AR_DRM_FIGOIMG \
		33
#define	\
	AB_DRM_FIGOIMG \
		8

typedef struct SIE_DRM_FIGOIMG {

	#define	RA_DRM_FIGOIMG_encKey 		0x00000
	/* @'00000 */	SIE_DRM_SUBKEY_OUT 			ie_encKey;

	#define	RA_DRM_FIGOIMG_authData 	0x00040
	/* @'00040 */	SIE_DRM_DIGEST 				ie_authData;

	#define	RA_DRM_FIGOIMG_bindInfo 	0x00060
	/* @'00060 */	SIE_UINT128 				ie_bindInfo;

	#define	RA_DRM_FIGOIMG_CFG 			0x00070
	#define	w32DRM_FIGOIMG_CFG 			{										\
					UNSG32				uCFG_insNum					 : 16;		\
					UNSG32				uCFG_datCnt					 : 16;		\
										}
	/* @'00070 */	union {	UNSG32		u32DRM_FIGOIMG_CFG;
								struct	w32DRM_FIGOIMG_CFG;
										};

	/* [15: 0] */	#define	  BA_DRM_FIGOIMG_CFG_insNum				 0x00070
	/* ---:--- */	#define	    bDRM_FIGOIMG_CFG_insNum				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_FIGOIMG_CFG_insNum				    0 /*:15*/
	/* ---:--- */	#define	MSK32DRM_FIGOIMG_CFG_insNum				       0x0000FFFF
	/* ---:--- */	#define	GET32DRM_FIGOIMG_CFG_insNum(r32)			 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_FIGOIMG_CFG_insNum(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_FIGOIMG_CFG_insNum(r32,v)			do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_FIGOIMG_CFG_insNum(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DRM_FIGOIMG_CFG_datCnt				 0x00072
	/* ---:--- */	#define	    bDRM_FIGOIMG_CFG_datCnt				   16 /*bit*/
	/* ---:--- */	#define	LSb32DRM_FIGOIMG_CFG_datCnt				   16 /*:31*/
	/* ---:--- */	#define	MSK32DRM_FIGOIMG_CFG_datCnt				       0xFFFF0000
	/* ---:--- */	#define	GET32DRM_FIGOIMG_CFG_datCnt(r32)			 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DRM_FIGOIMG_CFG_datCnt(r16)			 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DRM_FIGOIMG_CFG_datCnt(r32,v)			do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DRM_FIGOIMG_CFG_datCnt(r16,v)			do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DRM_FIGOIMG_reserved 	0x00074
	/* @'00074 */	SIE_UINT32 					ie_reserved			 [3];
					#define	 arr_DRM_FIGOIMG_reserved 				  3

	#define	RA_DRM_FIGOIMG_imgDat 		0x00080
	/* @'00080 */	SIE_UINT32 					ie_imgDat;

} SIE_DRM_FIGOIMG;

	#define	dftDRM_FIGOIMG_CFG 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_FIGOIMG_CFG;
										} T32DRM_FIGOIMG_CFG;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_FIGOIMG_drvrd (SIE_DRM_FIGOIMG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_FIGOIMG_drvwr (SIE_DRM_FIGOIMG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_FIGOIMG_reset (SIE_DRM_FIGOIMG *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_FIGOIMG_check(p,pie,ps8name,hfpErrLOG)		DRM_FIGOIMG_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_FIGOIMG_print(p,    ps8name,hfpErrLOG)		DRM_FIGOIMG_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_FIGOIMG_cmp   (SIE_DRM_FIGOIMG *p, SIE_DRM_FIGOIMG *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_FIGOIMG_import(SIE_DRM_FIGOIMG *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_FIGOIMG_export(SIE_DRM_FIGOIMG *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_FIGOIMG
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_ARMIMG
*	@
*		$DRM_SUBKEY_OUT  encKey
*						*  *
*						*  Image protection Key
*	@
*		$DRM_DIGEST  authData
*						*  *
*						*  Authentication information signed by sigKey
*	@
*		$UINT128  bindInfo
*						*  *
*						*  Platform binding information to indicate what type of underling hardware to run this firmware
*	@
*		$UINT128  reserved
*	@
*		$UINT32  imgDat
**********************************************************************************************************************/
#ifdef	h_DRM_ARMIMG
#else
#define	h_DRM_ARMIMG

#define	\
	AR_DRM_ARMIMG \
		33
#define	\
	AB_DRM_ARMIMG \
		8

typedef struct SIE_DRM_ARMIMG {

	#define	RA_DRM_ARMIMG_encKey 		0x00000
	/* @'00000 */	SIE_DRM_SUBKEY_OUT 			ie_encKey;

	#define	RA_DRM_ARMIMG_authData 		0x00040
	/* @'00040 */	SIE_DRM_DIGEST 				ie_authData;

	#define	RA_DRM_ARMIMG_bindInfo 		0x00060
	/* @'00060 */	SIE_UINT128 				ie_bindInfo;

	#define	RA_DRM_ARMIMG_reserved 		0x00070
	/* @'00070 */	SIE_UINT128 				ie_reserved;

	#define	RA_DRM_ARMIMG_imgDat 		0x00080
	/* @'00080 */	SIE_UINT32 					ie_imgDat;

} SIE_DRM_ARMIMG;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_ARMIMG_drvrd (SIE_DRM_ARMIMG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_ARMIMG_drvwr (SIE_DRM_ARMIMG *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_ARMIMG_reset (SIE_DRM_ARMIMG *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_ARMIMG_check(p,pie,ps8name,hfpErrLOG)		DRM_ARMIMG_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_ARMIMG_print(p,    ps8name,hfpErrLOG)		DRM_ARMIMG_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_ARMIMG_cmp   (SIE_DRM_ARMIMG *p, SIE_DRM_ARMIMG *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_ARMIMG_import(SIE_DRM_ARMIMG *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_ARMIMG_export(SIE_DRM_ARMIMG *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_ARMIMG
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SHA1_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_SHA1_RODAT
#else
#define	h_SHA1_RODAT

#define	\
	AR_SHA1_RODAT \
		1
#define	\
	AB_SHA1_RODAT \
		2

typedef struct SIE_SHA1_RODAT {

	#define	RA_SHA1_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_SHA1_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SHA1_RODAT_drvrd (SIE_SHA1_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SHA1_RODAT_drvwr (SIE_SHA1_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SHA1_RODAT_reset (SIE_SHA1_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SHA1_RODAT_check(p,pie,ps8name,hfpErrLOG)		SHA1_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SHA1_RODAT_print(p,    ps8name,hfpErrLOG)		SHA1_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SHA1_RODAT_cmp   (SIE_SHA1_RODAT *p, SIE_SHA1_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SHA1_RODAT_import(SIE_SHA1_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SHA1_RODAT_export(SIE_SHA1_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SHA1_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: SHA1_CTXDAT
*	@
*		$UINT64  puCount
*						*  *
*						*  Counter
*	@
*		$UINT32  pbBuf  [16]
*						*  *
*						*  Internal buffer
*	@
*		%unsigned  32  puState  [6]
*						*  *
*						*  Hash state
**********************************************************************************************************************/
#ifdef	h_SHA1_CTXDAT
#else
#define	h_SHA1_CTXDAT

#define	\
	AR_SHA1_CTXDAT \
		9
#define	\
	AB_SHA1_CTXDAT \
		6

typedef struct SIE_SHA1_CTXDAT {

	#define	RA_SHA1_CTXDAT_puCount 		0x00000
	/* @'00000 */	SIE_UINT64 					ie_puCount;

	#define	RA_SHA1_CTXDAT_pbBuf 		0x00008
	/* @'00008 */	SIE_UINT32 					ie_pbBuf;

	#define	RA_SHA1_CTXDAT_D3th_ 		ISC_USE_ONLY	0x0000C
	#define	w32SHA1_CTXDAT_D3th_ 		{										\
					UNSG32				u_puState_0i				 : 32;		\
										}
	/* @'0000C */				struct	w32SHA1_CTXDAT_D3th_;

	/* [31: 0] */	#define	  BA_SHA1_CTXDAT_puState_0i				 0x0000C
	/* ---:--- */	#define	    bSHA1_CTXDAT_puState_0i				   32 /*bit*/
	/* ---:--- */	#define	LSb32SHA1_CTXDAT_puState_0i				    0 /*:31*/
	/* ---:--- */	#define	MSK32SHA1_CTXDAT_puState_0i				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SHA1_CTXDAT_puState_0i(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SHA1_CTXDAT_puState_0i(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SHA1_CTXDAT_puState_0i(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SHA1_CTXDAT_puState_0i(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SHA1_CTXDAT_D4th_ 		ISC_USE_ONLY	0x00010
	#define	w32SHA1_CTXDAT_D4th_ 		{										\
					UNSG32				u_puState_1i				 : 32;		\
										}
	/* @'00010 */				struct	w32SHA1_CTXDAT_D4th_;

	/* [31: 0] */	#define	  BA_SHA1_CTXDAT_puState_1i				 0x00010
	/* ---:--- */	#define	    bSHA1_CTXDAT_puState_1i				   32 /*bit*/
	/* ---:--- */	#define	LSb32SHA1_CTXDAT_puState_1i				    0 /*:31*/
	/* ---:--- */	#define	MSK32SHA1_CTXDAT_puState_1i				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SHA1_CTXDAT_puState_1i(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SHA1_CTXDAT_puState_1i(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SHA1_CTXDAT_puState_1i(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SHA1_CTXDAT_puState_1i(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SHA1_CTXDAT_D5th_ 		ISC_USE_ONLY	0x00014
	#define	w32SHA1_CTXDAT_D5th_ 		{										\
					UNSG32				u_puState_2i				 : 32;		\
										}
	/* @'00014 */				struct	w32SHA1_CTXDAT_D5th_;

	/* [31: 0] */	#define	  BA_SHA1_CTXDAT_puState_2i				 0x00014
	/* ---:--- */	#define	    bSHA1_CTXDAT_puState_2i				   32 /*bit*/
	/* ---:--- */	#define	LSb32SHA1_CTXDAT_puState_2i				    0 /*:31*/
	/* ---:--- */	#define	MSK32SHA1_CTXDAT_puState_2i				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SHA1_CTXDAT_puState_2i(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SHA1_CTXDAT_puState_2i(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SHA1_CTXDAT_puState_2i(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SHA1_CTXDAT_puState_2i(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SHA1_CTXDAT_D6th_ 		ISC_USE_ONLY	0x00018
	#define	w32SHA1_CTXDAT_D6th_ 		{										\
					UNSG32				u_puState_3i				 : 32;		\
										}
	/* @'00018 */				struct	w32SHA1_CTXDAT_D6th_;

	/* [31: 0] */	#define	  BA_SHA1_CTXDAT_puState_3i				 0x00018
	/* ---:--- */	#define	    bSHA1_CTXDAT_puState_3i				   32 /*bit*/
	/* ---:--- */	#define	LSb32SHA1_CTXDAT_puState_3i				    0 /*:31*/
	/* ---:--- */	#define	MSK32SHA1_CTXDAT_puState_3i				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SHA1_CTXDAT_puState_3i(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SHA1_CTXDAT_puState_3i(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SHA1_CTXDAT_puState_3i(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SHA1_CTXDAT_puState_3i(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SHA1_CTXDAT_D7th_ 		ISC_USE_ONLY	0x0001C
	#define	w32SHA1_CTXDAT_D7th_ 		{										\
					UNSG32				u_puState_4i				 : 32;		\
										}
	/* @'0001C */				struct	w32SHA1_CTXDAT_D7th_;

	/* [31: 0] */	#define	  BA_SHA1_CTXDAT_puState_4i				 0x0001C
	/* ---:--- */	#define	    bSHA1_CTXDAT_puState_4i				   32 /*bit*/
	/* ---:--- */	#define	LSb32SHA1_CTXDAT_puState_4i				    0 /*:31*/
	/* ---:--- */	#define	MSK32SHA1_CTXDAT_puState_4i				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SHA1_CTXDAT_puState_4i(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SHA1_CTXDAT_puState_4i(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SHA1_CTXDAT_puState_4i(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SHA1_CTXDAT_puState_4i(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_SHA1_CTXDAT_D8th_ 		ISC_USE_ONLY	0x00020
	#define	w32SHA1_CTXDAT_D8th_ 		{										\
					UNSG32				u_puState_5i				 : 32;		\
										}
	/* @'00020 */				struct	w32SHA1_CTXDAT_D8th_;

	/* [31: 0] */	#define	  BA_SHA1_CTXDAT_puState_5i				 0x00020
	/* ---:--- */	#define	    bSHA1_CTXDAT_puState_5i				   32 /*bit*/
	/* ---:--- */	#define	LSb32SHA1_CTXDAT_puState_5i				    0 /*:31*/
	/* ---:--- */	#define	MSK32SHA1_CTXDAT_puState_5i				       0xFFFFFFFF
	/* ---:--- */	#define	GET32SHA1_CTXDAT_puState_5i(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16SHA1_CTXDAT_puState_5i(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32SHA1_CTXDAT_puState_5i(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16SHA1_CTXDAT_puState_5i(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_SHA1_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	SHA1_CTXDAT_drvrd (SIE_SHA1_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	SHA1_CTXDAT_drvwr (SIE_SHA1_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	SHA1_CTXDAT_reset (SIE_SHA1_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	SHA1_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		SHA1_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	SHA1_CTXDAT_print(p,    ps8name,hfpErrLOG)		SHA1_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	SHA1_CTXDAT_cmp   (SIE_SHA1_CTXDAT *p, SIE_SHA1_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	SHA1_CTXDAT_import(SIE_SHA1_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	SHA1_CTXDAT_export(SIE_SHA1_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: SHA1_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: HMAC_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_HMAC_RODAT
#else
#define	h_HMAC_RODAT

#define	\
	AR_HMAC_RODAT \
		1
#define	\
	AB_HMAC_RODAT \
		2

typedef struct SIE_HMAC_RODAT {

	#define	RA_HMAC_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_HMAC_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	HMAC_RODAT_drvrd (SIE_HMAC_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	HMAC_RODAT_drvwr (SIE_HMAC_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	HMAC_RODAT_reset (SIE_HMAC_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	HMAC_RODAT_check(p,pie,ps8name,hfpErrLOG)		HMAC_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	HMAC_RODAT_print(p,    ps8name,hfpErrLOG)		HMAC_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	HMAC_RODAT_cmp   (SIE_HMAC_RODAT *p, SIE_HMAC_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	HMAC_RODAT_import(SIE_HMAC_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	HMAC_RODAT_export(SIE_HMAC_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: HMAC_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: HMAC_CTXDAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_HMAC_CTXDAT
#else
#define	h_HMAC_CTXDAT

#define	\
	AR_HMAC_CTXDAT \
		1
#define	\
	AB_HMAC_CTXDAT \
		2

typedef struct SIE_HMAC_CTXDAT {

	#define	RA_HMAC_CTXDAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_HMAC_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	HMAC_CTXDAT_drvrd (SIE_HMAC_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	HMAC_CTXDAT_drvwr (SIE_HMAC_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	HMAC_CTXDAT_reset (SIE_HMAC_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	HMAC_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		HMAC_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	HMAC_CTXDAT_print(p,    ps8name,hfpErrLOG)		HMAC_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	HMAC_CTXDAT_cmp   (SIE_HMAC_CTXDAT *p, SIE_HMAC_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	HMAC_CTXDAT_import(SIE_HMAC_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	HMAC_CTXDAT_export(SIE_HMAC_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: HMAC_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: AES128_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_AES128_RODAT
#else
#define	h_AES128_RODAT

#define	\
	AR_AES128_RODAT \
		1
#define	\
	AB_AES128_RODAT \
		2

typedef struct SIE_AES128_RODAT {

	#define	RA_AES128_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_AES128_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	AES128_RODAT_drvrd (SIE_AES128_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	AES128_RODAT_drvwr (SIE_AES128_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	AES128_RODAT_reset (SIE_AES128_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	AES128_RODAT_check(p,pie,ps8name,hfpErrLOG)		AES128_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	AES128_RODAT_print(p,    ps8name,hfpErrLOG)		AES128_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	AES128_RODAT_cmp   (SIE_AES128_RODAT *p, SIE_AES128_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	AES128_RODAT_import(SIE_AES128_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	AES128_RODAT_export(SIE_AES128_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: AES128_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: AES128_CTXDAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_AES128_CTXDAT
#else
#define	h_AES128_CTXDAT

#define	\
	AR_AES128_CTXDAT \
		1
#define	\
	AB_AES128_CTXDAT \
		2

typedef struct SIE_AES128_CTXDAT {

	#define	RA_AES128_CTXDAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_AES128_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	AES128_CTXDAT_drvrd (SIE_AES128_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	AES128_CTXDAT_drvwr (SIE_AES128_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	AES128_CTXDAT_reset (SIE_AES128_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	AES128_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		AES128_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	AES128_CTXDAT_print(p,    ps8name,hfpErrLOG)		AES128_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	AES128_CTXDAT_cmp   (SIE_AES128_CTXDAT *p, SIE_AES128_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	AES128_CTXDAT_import(SIE_AES128_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	AES128_CTXDAT_export(SIE_AES128_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: AES128_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DES_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_DES_RODAT
#else
#define	h_DES_RODAT

#define	\
	AR_DES_RODAT \
		1
#define	\
	AB_DES_RODAT \
		2

typedef struct SIE_DES_RODAT {

	#define	RA_DES_RODAT_dummy 			0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_DES_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DES_RODAT_drvrd (SIE_DES_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DES_RODAT_drvwr (SIE_DES_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DES_RODAT_reset (SIE_DES_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DES_RODAT_check(p,pie,ps8name,hfpErrLOG)		DES_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DES_RODAT_print(p,    ps8name,hfpErrLOG)		DES_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DES_RODAT_cmp   (SIE_DES_RODAT *p, SIE_DES_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DES_RODAT_import(SIE_DES_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DES_RODAT_export(SIE_DES_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DES_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DES_CTXDAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_DES_CTXDAT
#else
#define	h_DES_CTXDAT

#define	\
	AR_DES_CTXDAT \
		1
#define	\
	AB_DES_CTXDAT \
		2

typedef struct SIE_DES_CTXDAT {

	#define	RA_DES_CTXDAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_DES_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DES_CTXDAT_drvrd (SIE_DES_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DES_CTXDAT_drvwr (SIE_DES_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DES_CTXDAT_reset (SIE_DES_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DES_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		DES_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DES_CTXDAT_print(p,    ps8name,hfpErrLOG)		DES_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DES_CTXDAT_cmp   (SIE_DES_CTXDAT *p, SIE_DES_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DES_CTXDAT_import(SIE_DES_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DES_CTXDAT_export(SIE_DES_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DES_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DES3_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_DES3_RODAT
#else
#define	h_DES3_RODAT

#define	\
	AR_DES3_RODAT \
		1
#define	\
	AB_DES3_RODAT \
		2

typedef struct SIE_DES3_RODAT {

	#define	RA_DES3_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_DES3_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DES3_RODAT_drvrd (SIE_DES3_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DES3_RODAT_drvwr (SIE_DES3_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DES3_RODAT_reset (SIE_DES3_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DES3_RODAT_check(p,pie,ps8name,hfpErrLOG)		DES3_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DES3_RODAT_print(p,    ps8name,hfpErrLOG)		DES3_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DES3_RODAT_cmp   (SIE_DES3_RODAT *p, SIE_DES3_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DES3_RODAT_import(SIE_DES3_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DES3_RODAT_export(SIE_DES3_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DES3_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DES3_CTXDAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_DES3_CTXDAT
#else
#define	h_DES3_CTXDAT

#define	\
	AR_DES3_CTXDAT \
		1
#define	\
	AB_DES3_CTXDAT \
		2

typedef struct SIE_DES3_CTXDAT {

	#define	RA_DES3_CTXDAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_DES3_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DES3_CTXDAT_drvrd (SIE_DES3_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DES3_CTXDAT_drvwr (SIE_DES3_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DES3_CTXDAT_reset (SIE_DES3_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DES3_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		DES3_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DES3_CTXDAT_print(p,    ps8name,hfpErrLOG)		DES3_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DES3_CTXDAT_cmp   (SIE_DES3_CTXDAT *p, SIE_DES3_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DES3_CTXDAT_import(SIE_DES3_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DES3_CTXDAT_export(SIE_DES3_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DES3_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: MULT2_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_MULT2_RODAT
#else
#define	h_MULT2_RODAT

#define	\
	AR_MULT2_RODAT \
		1
#define	\
	AB_MULT2_RODAT \
		2

typedef struct SIE_MULT2_RODAT {

	#define	RA_MULT2_RODAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_MULT2_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	MULT2_RODAT_drvrd (SIE_MULT2_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	MULT2_RODAT_drvwr (SIE_MULT2_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	MULT2_RODAT_reset (SIE_MULT2_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	MULT2_RODAT_check(p,pie,ps8name,hfpErrLOG)		MULT2_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	MULT2_RODAT_print(p,    ps8name,hfpErrLOG)		MULT2_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	MULT2_RODAT_cmp   (SIE_MULT2_RODAT *p, SIE_MULT2_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	MULT2_RODAT_import(SIE_MULT2_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	MULT2_RODAT_export(SIE_MULT2_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: MULT2_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: MULT2_CTXDAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_MULT2_CTXDAT
#else
#define	h_MULT2_CTXDAT

#define	\
	AR_MULT2_CTXDAT \
		1
#define	\
	AB_MULT2_CTXDAT \
		2

typedef struct SIE_MULT2_CTXDAT {

	#define	RA_MULT2_CTXDAT_dummy 		0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_MULT2_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	MULT2_CTXDAT_drvrd (SIE_MULT2_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	MULT2_CTXDAT_drvwr (SIE_MULT2_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	MULT2_CTXDAT_reset (SIE_MULT2_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	MULT2_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		MULT2_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	MULT2_CTXDAT_print(p,    ps8name,hfpErrLOG)		MULT2_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	MULT2_CTXDAT_cmp   (SIE_MULT2_CTXDAT *p, SIE_MULT2_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	MULT2_CTXDAT_import(SIE_MULT2_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	MULT2_CTXDAT_export(SIE_MULT2_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: MULT2_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: C2_RODAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_C2_RODAT
#else
#define	h_C2_RODAT

#define	\
	AR_C2_RODAT \
		1
#define	\
	AB_C2_RODAT \
		2

typedef struct SIE_C2_RODAT {

	#define	RA_C2_RODAT_dummy 			0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_C2_RODAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	C2_RODAT_drvrd (SIE_C2_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	C2_RODAT_drvwr (SIE_C2_RODAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	C2_RODAT_reset (SIE_C2_RODAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	C2_RODAT_check(p,pie,ps8name,hfpErrLOG)		C2_RODAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	C2_RODAT_print(p,    ps8name,hfpErrLOG)		C2_RODAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	C2_RODAT_cmp   (SIE_C2_RODAT *p, SIE_C2_RODAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	C2_RODAT_import(SIE_C2_RODAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	C2_RODAT_export(SIE_C2_RODAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: C2_RODAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: C2_CTXDAT
*	@
*		$UINT32  dummy
**********************************************************************************************************************/
#ifdef	h_C2_CTXDAT
#else
#define	h_C2_CTXDAT

#define	\
	AR_C2_CTXDAT \
		1
#define	\
	AB_C2_CTXDAT \
		2

typedef struct SIE_C2_CTXDAT {

	#define	RA_C2_CTXDAT_dummy 			0x00000
	/* @'00000 */	SIE_UINT32 					ie_dummy;

} SIE_C2_CTXDAT;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	C2_CTXDAT_drvrd (SIE_C2_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	C2_CTXDAT_drvwr (SIE_C2_CTXDAT *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	C2_CTXDAT_reset (SIE_C2_CTXDAT *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	C2_CTXDAT_check(p,pie,ps8name,hfpErrLOG)		C2_CTXDAT_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	C2_CTXDAT_print(p,    ps8name,hfpErrLOG)		C2_CTXDAT_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	C2_CTXDAT_cmp   (SIE_C2_CTXDAT *p, SIE_C2_CTXDAT *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	C2_CTXDAT_import(SIE_C2_CTXDAT *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	C2_CTXDAT_export(SIE_C2_CTXDAT *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: C2_CTXDAT
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_CMD_TYPE
*	@
*			:  LD_FIGOIMG  0
*						*  *
*						*  Load and verify FIGO image
*	@
*			:  LD_ARMIMG  1
*						*  *
*						*  Load and verify ARM image
*	@
*		%unsigned  32  dummy
**********************************************************************************************************************/
#ifdef	h_DRMROM_CMD_TYPE
#else
#define	h_DRMROM_CMD_TYPE

#define	\
	AR_DRMROM_CMD_TYPE \
		1
#define	\
	AB_DRMROM_CMD_TYPE \
		2

	#define	DRMROM_CMD_TYPE_LD_FIGOIMG 	0x0
	#define	DRMROM_CMD_TYPE_LD_ARMIMG 	0x1

typedef struct SIE_DRMROM_CMD_TYPE {

	#define	RA_DRMROM_CMD_TYPE_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRMROM_CMD_TYPE_D0th_ 	{										\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32DRMROM_CMD_TYPE_D0th_;

	/* [31: 0] */	#define	  BA_DRMROM_CMD_TYPE_dummy				 0x00000
	/* ---:--- */	#define	    bDRMROM_CMD_TYPE_dummy				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_TYPE_dummy				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_TYPE_dummy				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_TYPE_dummy(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_TYPE_dummy(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_TYPE_dummy(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_TYPE_dummy(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMROM_CMD_TYPE;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_CMD_TYPE_drvrd (SIE_DRMROM_CMD_TYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_CMD_TYPE_drvwr (SIE_DRMROM_CMD_TYPE *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_CMD_TYPE_reset (SIE_DRMROM_CMD_TYPE *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_CMD_TYPE_check(p,pie,ps8name,hfpErrLOG)		DRMROM_CMD_TYPE_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_CMD_TYPE_print(p,    ps8name,hfpErrLOG)		DRMROM_CMD_TYPE_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_CMD_TYPE_cmp   (SIE_DRMROM_CMD_TYPE *p, SIE_DRMROM_CMD_TYPE *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_CMD_TYPE_import(SIE_DRMROM_CMD_TYPE *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_CMD_TYPE_export(SIE_DRMROM_CMD_TYPE *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_CMD_TYPE
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_CMD
*	@  STAT  (R-W-)  0
*		%unsigned  1  en
*						*  *
*						*  1: Indicate command has been issued by ARM. CMD register contains the command body
*						*  0 : Indicate command has been executed by FIGO . RSP register contains the response body
*	@  CMD_CFG  (W)  0
*		%unsigned  8  tag  0
*						*  *
*						*  Command ordinal, LD_FIGOIMG or LD_ARMIMG
*						*  0
*		%unsigned  24  nonce  0
*						*  *
*						*  Command ID
*						*  0
*	@  CMD_DAT0
*		%unsigned  32  crcCmd32  0
*						*  *
*						*  Command CRC32 value
*	@  CMD_DAT1
*		%unsigned  32  imgSz  0
*						*  *
*						*  Image size of instruction
*						*  0
*	@  CMD_DAT2
*		%unsigned  32  imgSrcAddr  0
*						*  *
*						*  Image source address in DDR. To simplfy the FIGO macrocode design and improve the data transfer performance, imgSrcAddr should be aligned to 32 bytes
*	@  CMD_DAT3
*		%unsigned  32  imgDstAddr  0
*						*  *
*						*  Image destination address aligned to 32 bytes
*	@  RSP_CFG  (R)  0
*		%unsigned  8  tag  0
*						*  *
*						*  Response ordinal, LD_FIGOIMG or LD_ARMIMG
*						*  0
*	@  RSP_DAT0
*		%unsigned  32  crcRsp32  0
*						*  *
*						*  Response CRC32 value calculated with corresponding command nonce value
*						*  0
*	@  RSP_DAT1
*		%unsigned  32  error  0
*						*  *
*						*  Response error code. 0 : Succeed
*						*  0
*	@
*		%unsigned  32  reserved  0
**********************************************************************************************************************/
#ifdef	h_DRMROM_CMD
#else
#define	h_DRMROM_CMD

#define	\
	AR_DRMROM_CMD \
		10
#define	\
	AB_DRMROM_CMD \
		6

typedef struct SIE_DRMROM_CMD {

	#define	RA_DRMROM_CMD_STAT 			0x00000
	#define	w32DRMROM_CMD_STAT 			{										\
					UNSG32				uSTAT_en					 :  1;		\
					UNSG32				_x00000	: 31;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRMROM_CMD_STAT;
								struct	w32DRMROM_CMD_STAT;
										};

	/* [ 0: 0] */	#define	  BA_DRMROM_CMD_STAT_en					 0x00000
	/* ---:--- */	#define	    bDRMROM_CMD_STAT_en					    1 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_STAT_en					    0 /*: 0*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_STAT_en					       0x00000001
	/* ---:--- */	#define	GET32DRMROM_CMD_STAT_en(r32)				 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16DRMROM_CMD_STAT_en(r16)				 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32DRMROM_CMD_STAT_en(r32,v)				do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_STAT_en(r16,v)				do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_CFG 		0x00004
	#define	w32DRMROM_CMD_CMD_CFG 		{										\
					UNSG32				uCMD_CFG_tag				 :  8;		\
					UNSG32				uCMD_CFG_nonce				 : 24;		\
										}
	/* @'00004 */	union {	UNSG32		u32DRMROM_CMD_CMD_CFG;
								struct	w32DRMROM_CMD_CMD_CFG;
										};

	/* [ 7: 0] */	#define	  BA_DRMROM_CMD_CMD_CFG_tag				 0x00004
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_CFG_tag				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_CFG_tag				    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_CFG_tag				       0x000000FF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_CFG_tag(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_CFG_tag(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_CFG_tag(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_CFG_tag(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31: 8] */	#define	  BA_DRMROM_CMD_CMD_CFG_nonce			 0x00005
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_CFG_nonce			   24 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_CFG_nonce			    8 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_CFG_nonce			       0xFFFFFF00
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_CFG_nonce(r32)			 (((r32)>> 8)&0xFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_CFG_nonce(r16)			 (((r16)>> 8)&0xFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_CFG_nonce(r32,v)		do{(r32)&=~(0xFFFFFF<< 8);(r32)|=((v)&0xFFFFFF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_CFG_nonce(r16,v)		do{(r16)&=~(0xFFFFFF<< 8);(r16)|=((v)&0xFFFFFF)<< 8;}while(0)

	#define	RA_DRMROM_CMD_CMD_DAT0 		0x00008
	#define	w32DRMROM_CMD_CMD_DAT0 		{										\
					UNSG32				uCMD_DAT0_crcCmd32			 : 32;		\
										}
	/* @'00008 */	union {	UNSG32		u32DRMROM_CMD_CMD_DAT0;
								struct	w32DRMROM_CMD_CMD_DAT0;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_CMD_DAT0_crcCmd32		 0x00008
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_DAT0_crcCmd32		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_DAT0_crcCmd32		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_DAT0_crcCmd32		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_DAT0_crcCmd32(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_DAT0_crcCmd32(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_DAT0_crcCmd32(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_DAT0_crcCmd32(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_DAT1 		0x0000C
	#define	w32DRMROM_CMD_CMD_DAT1 		{										\
					UNSG32				uCMD_DAT1_imgSz				 : 32;		\
										}
	/* @'0000C */	union {	UNSG32		u32DRMROM_CMD_CMD_DAT1;
								struct	w32DRMROM_CMD_CMD_DAT1;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_CMD_DAT1_imgSz			 0x0000C
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_DAT1_imgSz			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_DAT1_imgSz			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_DAT1_imgSz			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_DAT1_imgSz(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_DAT1_imgSz(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_DAT1_imgSz(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_DAT1_imgSz(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_DAT2 		0x00010
	#define	w32DRMROM_CMD_CMD_DAT2 		{										\
					UNSG32				uCMD_DAT2_imgSrcAddr		 : 32;		\
										}
	/* @'00010 */	union {	UNSG32		u32DRMROM_CMD_CMD_DAT2;
								struct	w32DRMROM_CMD_CMD_DAT2;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_CMD_DAT2_imgSrcAddr		 0x00010
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_DAT2_imgSrcAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_DAT2_imgSrcAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_DAT2_imgSrcAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_DAT2_imgSrcAddr(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_DAT2_imgSrcAddr(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_DAT2_imgSrcAddr(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_DAT2_imgSrcAddr(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_CMD_DAT3 		0x00014
	#define	w32DRMROM_CMD_CMD_DAT3 		{										\
					UNSG32				uCMD_DAT3_imgDstAddr		 : 32;		\
										}
	/* @'00014 */	union {	UNSG32		u32DRMROM_CMD_CMD_DAT3;
								struct	w32DRMROM_CMD_CMD_DAT3;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_CMD_DAT3_imgDstAddr		 0x00014
	/* ---:--- */	#define	    bDRMROM_CMD_CMD_DAT3_imgDstAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_CMD_DAT3_imgDstAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_CMD_DAT3_imgDstAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_CMD_DAT3_imgDstAddr(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_CMD_DAT3_imgDstAddr(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_CMD_DAT3_imgDstAddr(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_CMD_DAT3_imgDstAddr(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_RSP_CFG 		0x00018
	#define	w32DRMROM_CMD_RSP_CFG 		{										\
					UNSG32				uRSP_CFG_tag				 :  8;		\
					UNSG32				_x00018	: 24;							\
										}
	/* @'00018 */	union {	UNSG32		u32DRMROM_CMD_RSP_CFG;
								struct	w32DRMROM_CMD_RSP_CFG;
										};

	/* [ 7: 0] */	#define	  BA_DRMROM_CMD_RSP_CFG_tag				 0x00018
	/* ---:--- */	#define	    bDRMROM_CMD_RSP_CFG_tag				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_RSP_CFG_tag				    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_RSP_CFG_tag				       0x000000FF
	/* ---:--- */	#define	GET32DRMROM_CMD_RSP_CFG_tag(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMROM_CMD_RSP_CFG_tag(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMROM_CMD_RSP_CFG_tag(r32,v)			do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_RSP_CFG_tag(r16,v)			do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_RSP_DAT0 		0x0001C
	#define	w32DRMROM_CMD_RSP_DAT0 		{										\
					UNSG32				uRSP_DAT0_crcRsp32			 : 32;		\
										}
	/* @'0001C */	union {	UNSG32		u32DRMROM_CMD_RSP_DAT0;
								struct	w32DRMROM_CMD_RSP_DAT0;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_RSP_DAT0_crcRsp32		 0x0001C
	/* ---:--- */	#define	    bDRMROM_CMD_RSP_DAT0_crcRsp32		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_RSP_DAT0_crcRsp32		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_RSP_DAT0_crcRsp32		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_RSP_DAT0_crcRsp32(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_RSP_DAT0_crcRsp32(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_RSP_DAT0_crcRsp32(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_RSP_DAT0_crcRsp32(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_RSP_DAT1 		0x00020
	#define	w32DRMROM_CMD_RSP_DAT1 		{										\
					UNSG32				uRSP_DAT1_error				 : 32;		\
										}
	/* @'00020 */	union {	UNSG32		u32DRMROM_CMD_RSP_DAT1;
								struct	w32DRMROM_CMD_RSP_DAT1;
										};

	/* [31: 0] */	#define	  BA_DRMROM_CMD_RSP_DAT1_error			 0x00020
	/* ---:--- */	#define	    bDRMROM_CMD_RSP_DAT1_error			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_RSP_DAT1_error			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_RSP_DAT1_error			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_RSP_DAT1_error(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_RSP_DAT1_error(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_RSP_DAT1_error(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_RSP_DAT1_error(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMROM_CMD_D9th_ 		ISC_USE_ONLY	0x00024
	#define	w32DRMROM_CMD_D9th_ 		{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'00024 */				struct	w32DRMROM_CMD_D9th_;

	/* [31: 0] */	#define	  BA_DRMROM_CMD_reserved				 0x00024
	/* ---:--- */	#define	    bDRMROM_CMD_reserved				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_CMD_reserved				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_CMD_reserved				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_CMD_reserved(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_CMD_reserved(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_CMD_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_CMD_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMROM_CMD;

	#define	dftDRMROM_CMD_STAT 			0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_STAT;
										} T32DRMROM_CMD_STAT;
	#define	dftDRMROM_CMD_CMD_CFG 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_CFG;
										} T32DRMROM_CMD_CMD_CFG;
	#define	dftDRMROM_CMD_CMD_DAT0 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_DAT0;
										} T32DRMROM_CMD_CMD_DAT0;
	#define	dftDRMROM_CMD_CMD_DAT1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_DAT1;
										} T32DRMROM_CMD_CMD_DAT1;
	#define	dftDRMROM_CMD_CMD_DAT2 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_DAT2;
										} T32DRMROM_CMD_CMD_DAT2;
	#define	dftDRMROM_CMD_CMD_DAT3 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_CMD_DAT3;
										} T32DRMROM_CMD_CMD_DAT3;
	#define	dftDRMROM_CMD_RSP_CFG 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_RSP_CFG;
										} T32DRMROM_CMD_RSP_CFG;
	#define	dftDRMROM_CMD_RSP_DAT0 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_RSP_DAT0;
										} T32DRMROM_CMD_RSP_DAT0;
	#define	dftDRMROM_CMD_RSP_DAT1 		0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRMROM_CMD_RSP_DAT1;
										} T32DRMROM_CMD_RSP_DAT1;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_CMD_drvrd (SIE_DRMROM_CMD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_CMD_drvwr (SIE_DRMROM_CMD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_CMD_reset (SIE_DRMROM_CMD *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_CMD_check(p,pie,ps8name,hfpErrLOG)		DRMROM_CMD_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_CMD_print(p,    ps8name,hfpErrLOG)		DRMROM_CMD_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_CMD_cmp   (SIE_DRMROM_CMD *p, SIE_DRMROM_CMD *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_CMD_import(SIE_DRMROM_CMD *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_CMD_export(SIE_DRMROM_CMD *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_CMD
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_DROM
*	@
*		$AES128_RODAT  aesROData
*						*  *
*						*  AES 128 bits algorithm specific read only data
*	@
*		$SHA1_RODAT  sha1ROData  SHA1 algorithm specific read only data
*	@
*		$HMAC_RODAT  hmacROData
*						*  *
*						*  HMAC algorithm specific read only data
**********************************************************************************************************************/
#ifdef	h_DRM_DROM
#else
#define	h_DRM_DROM

#define	\
	AR_DRM_DROM \
		3
#define	\
	AB_DRM_DROM \
		4

typedef struct SIE_DRM_DROM {

	#define	RA_DRM_DROM_aesROData 		0x00000
	/* @'00000 */	SIE_AES128_RODAT 			ie_aesROData;

	#define	RA_DRM_DROM_sha1ROData 		0x00004
	/* @'00004 */	SIE_SHA1_RODAT 				ie_sha1ROData;

	#define	RA_DRM_DROM_hmacROData 		0x00008
	/* @'00008 */	SIE_HMAC_RODAT 				ie_hmacROData;

} SIE_DRM_DROM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_DROM_drvrd (SIE_DRM_DROM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_DROM_drvwr (SIE_DRM_DROM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_DROM_reset (SIE_DRM_DROM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_DROM_check(p,pie,ps8name,hfpErrLOG)		DRM_DROM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_DROM_print(p,    ps8name,hfpErrLOG)		DRM_DROM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_DROM_cmp   (SIE_DRM_DROM *p, SIE_DRM_DROM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_DROM_import(SIE_DRM_DROM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_DROM_export(SIE_DRM_DROM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_DROM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_FIFOIDX
*	@
*			:  DS  0
*						*  *
*						*  DS FIFo IDx
*	@
*		%unsigned  32  dummy
**********************************************************************************************************************/
#ifdef	h_DRMROM_FIFOIDX
#else
#define	h_DRMROM_FIFOIDX

#define	\
	AR_DRMROM_FIFOIDX \
		1
#define	\
	AB_DRMROM_FIFOIDX \
		2

	#define	DRMROM_FIFOIDX_DS 			0x0

typedef struct SIE_DRMROM_FIFOIDX {

	#define	RA_DRMROM_FIFOIDX_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRMROM_FIFOIDX_D0th_ 	{										\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32DRMROM_FIFOIDX_D0th_;

	/* [31: 0] */	#define	  BA_DRMROM_FIFOIDX_dummy				 0x00000
	/* ---:--- */	#define	    bDRMROM_FIFOIDX_dummy				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMROM_FIFOIDX_dummy				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMROM_FIFOIDX_dummy				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMROM_FIFOIDX_dummy(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMROM_FIFOIDX_dummy(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMROM_FIFOIDX_dummy(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMROM_FIFOIDX_dummy(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMROM_FIFOIDX;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_FIFOIDX_drvrd (SIE_DRMROM_FIFOIDX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_FIFOIDX_drvwr (SIE_DRMROM_FIFOIDX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_FIFOIDX_reset (SIE_DRMROM_FIFOIDX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_FIFOIDX_check(p,pie,ps8name,hfpErrLOG)		DRMROM_FIFOIDX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_FIFOIDX_print(p,    ps8name,hfpErrLOG)		DRMROM_FIFOIDX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_FIFOIDX_cmp   (SIE_DRMROM_FIFOIDX *p, SIE_DRMROM_FIFOIDX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_FIFOIDX_import(SIE_DRMROM_FIFOIDX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_FIFOIDX_export(SIE_DRMROM_FIFOIDX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_FIFOIDX
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_SRAM_RESERVED
*	@
*		$UINT128  reserved  REG  [128]
*						*  *
*						*  Reserved ROM SRAM
**********************************************************************************************************************/
#ifdef	h_DRMROM_SRAM_RESERVED
#else
#define	h_DRMROM_SRAM_RESERVED

#define	\
	AR_DRMROM_SRAM_RESERVED \
		512
#define	\
	AB_DRMROM_SRAM_RESERVED \
		11

typedef struct SIE_DRMROM_SRAM_RESERVED {

	#define	RA_DRMROM_SRAM_RESERVED_reserved 0x00000
	/* @'00000 */	SIE_UINT128 				ie_reserved			 [128];
					#define	 arr_DRMROM_SRAM_RESERVED_reserved 		  128

} SIE_DRMROM_SRAM_RESERVED;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_SRAM_RESERVED_drvrd (SIE_DRMROM_SRAM_RESERVED *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_SRAM_RESERVED_drvwr (SIE_DRMROM_SRAM_RESERVED *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_SRAM_RESERVED_reset (SIE_DRMROM_SRAM_RESERVED *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_SRAM_RESERVED_check(p,pie,ps8name,hfpErrLOG)		DRMROM_SRAM_RESERVED_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_SRAM_RESERVED_print(p,    ps8name,hfpErrLOG)		DRMROM_SRAM_RESERVED_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_SRAM_RESERVED_cmp   (SIE_DRMROM_SRAM_RESERVED *p, SIE_DRMROM_SRAM_RESERVED *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_SRAM_RESERVED_import(SIE_DRMROM_SRAM_RESERVED *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_SRAM_RESERVED_export(SIE_DRMROM_SRAM_RESERVED *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_SRAM_RESERVED
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMROM_SRAM
*	@
*		$DRMROM_CMD  cmd
*						*  *
*						*  ROM code command and response buffer
*	@
*		$LocalArea  la
*						*  *
*						*  Local data area
*	@
*		$UINT64  dsFifoDat  REG  [16]
*						*  *
*						*  Data streamer fifo data
*	@
*		$DRM_SYMKEYCTX256_IN  symSignKey
*						*  *
*						*  AES128 based symmetric signature key context
*	@
*		$DRM_RSAKEYCTX1024_IN  asymSignKey
*						*  *
*						*  RSA1924 based asymmetric signature key context
*	@
*		$DRM_SYMKEYCTX256_IN  aesRKEK
*						*  *
*						*  AES128 RKEK key context
*	@
*		$DRM_SYMKEYCTX256_IN  aesSubKey
*						*  *
*						*  AES128 sub key context
*	@
*		$UINT128  rndKeyBuf
*						*  *
*						*  Temporary buffer for round keys
*	@  0x7f0
*		$UINT128  stack
*						*  *
*						*  Stack
*	@  0x0800
*		$UINT128  dsTransBuf  REG  [256]
*						*  *
*						*  Transfer memory
**********************************************************************************************************************/
#ifdef	h_DRMROM_SRAM
#else
#define	h_DRMROM_SRAM

#define	\
	AR_DRMROM_SRAM \
		1536
#define	\
	AB_DRMROM_SRAM \
		13

typedef struct SIE_DRMROM_SRAM {

	#define	RA_DRMROM_SRAM_cmd 			0x00000
	/* @'00000 */	SIE_DRMROM_CMD 				ie_cmd;

	#define	RA_DRMROM_SRAM_la 			0x00028
	/* @'00028 */	SIE_LocalArea 				ie_la;

	#define	RA_DRMROM_SRAM_dsFifoDat 	0x001B0
	/* @'001B0 */	SIE_UINT64 					ie_dsFifoDat		 [16];
					#define	 arr_DRMROM_SRAM_dsFifoDat 				  16

	#define	RA_DRMROM_SRAM_symSignKey 	0x00230
	/* @'00230 */	SIE_DRM_SYMKEYCTX256_IN 	ie_symSignKey;

	#define	RA_DRMROM_SRAM_asymSignKey 	0x00290
	/* @'00290 */	SIE_DRM_RSAKEYCTX1024_IN 	ie_asymSignKey;

	#define	RA_DRMROM_SRAM_aesRKEK 		0x002E0
	/* @'002E0 */	SIE_DRM_SYMKEYCTX256_IN 	ie_aesRKEK;

	#define	RA_DRMROM_SRAM_aesSubKey 	0x00340
	/* @'00340 */	SIE_DRM_SYMKEYCTX256_IN 	ie_aesSubKey;

	#define	RA_DRMROM_SRAM_rndKeyBuf 	0x003A0
	/* @'003A0 */	SIE_UINT128 				ie_rndKeyBuf;

	UNSG32	_PAD_000[(0x007F0-0x003B0)/4];
	#define	RA_DRMROM_SRAM_stack 		0x007F0
	/* @'007F0 */	SIE_UINT128 				ie_stack;

	#define	RA_DRMROM_SRAM_dsTransBuf 	0x00800
	/* @'00800 */	SIE_UINT128 				ie_dsTransBuf		 [256];
					#define	 arr_DRMROM_SRAM_dsTransBuf 			  256

} SIE_DRMROM_SRAM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMROM_SRAM_drvrd (SIE_DRMROM_SRAM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMROM_SRAM_drvwr (SIE_DRMROM_SRAM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMROM_SRAM_reset (SIE_DRMROM_SRAM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMROM_SRAM_check(p,pie,ps8name,hfpErrLOG)		DRMROM_SRAM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMROM_SRAM_print(p,    ps8name,hfpErrLOG)		DRMROM_SRAM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMROM_SRAM_cmp   (SIE_DRMROM_SRAM *p, SIE_DRMROM_SRAM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMROM_SRAM_import(SIE_DRMROM_SRAM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMROM_SRAM_export(SIE_DRMROM_SRAM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMROM_SRAM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_CMD
*	@  CMD  (W)  0
*		%unsigned  8  tag  0
*						*  *
*						*  Command ordinal, LD_FIGOIMG or LD_ARMIMG
*						*  0
*		%unsigned  24  nonce  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		%unsigned  32  crcCmd32  0
*						*  *
*						*  Command CRC32 value
*	@
*		$UINT32  RET_BODY  [6]
**********************************************************************************************************************/
#ifdef	h_DRM_CMD
#else
#define	h_DRM_CMD

#define	\
	AR_DRM_CMD \
		3
#define	\
	AB_DRM_CMD \
		4

typedef struct SIE_DRM_CMD {

	#define	RA_DRM_CMD_CMD 				0x00000
	#define	w32DRM_CMD_CMD 				{										\
					UNSG32				uCMD_tag					 :  8;		\
					UNSG32				uCMD_nonce					 : 24;		\
										}
	/* @'00000 */	union {	UNSG32		u32DRM_CMD_CMD;
								struct	w32DRM_CMD_CMD;
										};

	/* [ 7: 0] */	#define	  BA_DRM_CMD_CMD_tag					 0x00000
	/* ---:--- */	#define	    bDRM_CMD_CMD_tag					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CMD_CMD_tag					    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_CMD_CMD_tag					       0x000000FF
	/* ---:--- */	#define	GET32DRM_CMD_CMD_tag(r32)					 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_CMD_CMD_tag(r16)					 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_CMD_CMD_tag(r32,v)					do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CMD_CMD_tag(r16,v)					do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [31: 8] */	#define	  BA_DRM_CMD_CMD_nonce					 0x00001
	/* ---:--- */	#define	    bDRM_CMD_CMD_nonce					   24 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CMD_CMD_nonce					    8 /*:31*/
	/* ---:--- */	#define	MSK32DRM_CMD_CMD_nonce					       0xFFFFFF00
	/* ---:--- */	#define	GET32DRM_CMD_CMD_nonce(r32)					 (((r32)>> 8)&0xFFFFFF)
	/* ---:--- */	#define	GET16DRM_CMD_CMD_nonce(r16)					 (((r16)>> 8)&0xFFFFFF)
	/* ---:--- */	#define	SET32DRM_CMD_CMD_nonce(r32,v)				do{(r32)&=~(0xFFFFFF<< 8);(r32)|=((v)&0xFFFFFF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRM_CMD_CMD_nonce(r16,v)				do{(r16)&=~(0xFFFFFF<< 8);(r16)|=((v)&0xFFFFFF)<< 8;}while(0)

	#define	RA_DRM_CMD_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DRM_CMD_D1th_ 			{										\
					UNSG32				u_crcCmd32					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_CMD_D1th_;

	/* [31: 0] */	#define	  BA_DRM_CMD_crcCmd32					 0x00004
	/* ---:--- */	#define	    bDRM_CMD_crcCmd32					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_CMD_crcCmd32					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_CMD_crcCmd32					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_CMD_crcCmd32(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_CMD_crcCmd32(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_CMD_crcCmd32(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_CMD_crcCmd32(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_CMD_RET_BODY 		0x00008
	/* @'00008 */	SIE_UINT32 					ie_RET_BODY;

} SIE_DRM_CMD;

	#define	dftDRM_CMD_CMD 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_CMD_CMD;
										} T32DRM_CMD_CMD;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_CMD_drvrd (SIE_DRM_CMD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_CMD_drvwr (SIE_DRM_CMD *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_CMD_reset (SIE_DRM_CMD *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_CMD_check(p,pie,ps8name,hfpErrLOG)		DRM_CMD_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_CMD_print(p,    ps8name,hfpErrLOG)		DRM_CMD_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_CMD_cmp   (SIE_DRM_CMD *p, SIE_DRM_CMD *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_CMD_import(SIE_DRM_CMD *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_CMD_export(SIE_DRM_CMD *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_CMD
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRM_RSP
*	@  RSP  (R)  0
*		%unsigned  8  tag  0
*						*  *
*						*  Response ordinal, LD_FIGOIMG or LD_ARMIMG
*						*  0
*	@
*		%unsigned  32  crcRsp32  0
*						*  *
*						*  Response CRC32 value calculated with corresponding command nonce value
*						*  0
*	@
*		%unsigned  32  error  0
*						*  *
*						*  Response error code. 0 : Succeed
*						*  0
*	@
*		%unsigned  32  reserved  0
*						*  *
*						*  reserved
*						*  0
**********************************************************************************************************************/
#ifdef	h_DRM_RSP
#else
#define	h_DRM_RSP

#define	\
	AR_DRM_RSP \
		4
#define	\
	AB_DRM_RSP \
		4

typedef struct SIE_DRM_RSP {

	#define	RA_DRM_RSP_RSP 				0x00000
	#define	w32DRM_RSP_RSP 				{										\
					UNSG32				uRSP_tag					 :  8;		\
					UNSG32				_x00000	: 24;							\
										}
	/* @'00000 */	union {	UNSG32		u32DRM_RSP_RSP;
								struct	w32DRM_RSP_RSP;
										};

	/* [ 7: 0] */	#define	  BA_DRM_RSP_RSP_tag					 0x00000
	/* ---:--- */	#define	    bDRM_RSP_RSP_tag					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSP_RSP_tag					    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRM_RSP_RSP_tag					       0x000000FF
	/* ---:--- */	#define	GET32DRM_RSP_RSP_tag(r32)					 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRM_RSP_RSP_tag(r16)					 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRM_RSP_RSP_tag(r32,v)					do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSP_RSP_tag(r16,v)					do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	#define	RA_DRM_RSP_D1th_ 			ISC_USE_ONLY	0x00004
	#define	w32DRM_RSP_D1th_ 			{										\
					UNSG32				u_crcRsp32					 : 32;		\
										}
	/* @'00004 */				struct	w32DRM_RSP_D1th_;

	/* [31: 0] */	#define	  BA_DRM_RSP_crcRsp32					 0x00004
	/* ---:--- */	#define	    bDRM_RSP_crcRsp32					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSP_crcRsp32					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSP_crcRsp32					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSP_crcRsp32(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSP_crcRsp32(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSP_crcRsp32(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSP_crcRsp32(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_RSP_D2th_ 			ISC_USE_ONLY	0x00008
	#define	w32DRM_RSP_D2th_ 			{										\
					UNSG32				u_error						 : 32;		\
										}
	/* @'00008 */				struct	w32DRM_RSP_D2th_;

	/* [31: 0] */	#define	  BA_DRM_RSP_error						 0x00008
	/* ---:--- */	#define	    bDRM_RSP_error						   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSP_error						    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSP_error						       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSP_error(r32)						 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSP_error(r16)						 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSP_error(r32,v)					do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSP_error(r16,v)					do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRM_RSP_D3th_ 			ISC_USE_ONLY	0x0000C
	#define	w32DRM_RSP_D3th_ 			{										\
					UNSG32				u_reserved					 : 32;		\
										}
	/* @'0000C */				struct	w32DRM_RSP_D3th_;

	/* [31: 0] */	#define	  BA_DRM_RSP_reserved					 0x0000C
	/* ---:--- */	#define	    bDRM_RSP_reserved					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRM_RSP_reserved					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRM_RSP_reserved					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRM_RSP_reserved(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRM_RSP_reserved(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRM_RSP_reserved(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRM_RSP_reserved(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRM_RSP;

	#define	dftDRM_RSP_RSP 				0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DRM_RSP_RSP;
										} T32DRM_RSP_RSP;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRM_RSP_drvrd (SIE_DRM_RSP *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRM_RSP_drvwr (SIE_DRM_RSP *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRM_RSP_reset (SIE_DRM_RSP *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRM_RSP_check(p,pie,ps8name,hfpErrLOG)		DRM_RSP_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRM_RSP_print(p,    ps8name,hfpErrLOG)		DRM_RSP_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRM_RSP_cmp   (SIE_DRM_RSP *p, SIE_DRM_RSP *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRM_RSP_import(SIE_DRM_RSP *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRM_RSP_export(SIE_DRM_RSP *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRM_RSP
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMCMD_HASH
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_SHA1_START
*						*  DRMCMD_SHA1_UPDATE
*						*  DRMCMD_SHA1_END.
*						*  DRMCMD_HMAC_START
*						*  DRMCMD_HMAC_UPDATE
*						*  DRMCMD_HMAC_END
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  hashID  0
*						*  *
*						*  Hash conetxt ID
*						*  0
*	@
*		%unsigned  32  datSz  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  32  keyID  0
*						*  *
*						*  Key context ID
*	@
*		%unsigned  32  authDat  0
*						*  *
*						*  Command authentication data
**********************************************************************************************************************/
#ifdef	h_DRMCMD_HASH
#else
#define	h_DRMCMD_HASH

#define	\
	AR_DRMCMD_HASH \
		6
#define	\
	AB_DRMCMD_HASH \
		5

typedef struct SIE_DRMCMD_HASH {

	#define	RA_DRMCMD_HASH_D0th_ 		ISC_USE_ONLY	0x00000
	#define	w32DRMCMD_HASH_D0th_ 		{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32DRMCMD_HASH_D0th_;

	/* [ 7: 0] */	#define	  BA_DRMCMD_HASH_cmdCode				 0x00000
	/* ---:--- */	#define	    bDRMCMD_HASH_cmdCode				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_cmdCode				    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_cmdCode				       0x000000FF
	/* ---:--- */	#define	GET32DRMCMD_HASH_cmdCode(r32)				 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_cmdCode(r16)				 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_cmdCode(r32,v)				do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_cmdCode(r16,v)				do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_DRMCMD_HASH_cmdID					 0x00001
	/* ---:--- */	#define	    bDRMCMD_HASH_cmdID					    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_cmdID					    8 /*:15*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_cmdID					       0x0000FF00
	/* ---:--- */	#define	GET32DRMCMD_HASH_cmdID(r32)					 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_cmdID(r16)					 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_cmdID(r32,v)				do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_cmdID(r16,v)				do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_DRMCMD_HASH_hashID 		0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_hashID;

	#define	RA_DRMCMD_HASH_D2th_ 		ISC_USE_ONLY	0x00008
	#define	w32DRMCMD_HASH_D2th_ 		{										\
					UNSG32				u_datSz						 : 32;		\
										}
	/* @'00008 */				struct	w32DRMCMD_HASH_D2th_;

	/* [31: 0] */	#define	  BA_DRMCMD_HASH_datSz					 0x00008
	/* ---:--- */	#define	    bDRMCMD_HASH_datSz					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_datSz					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_datSz					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_HASH_datSz(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_datSz(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_datSz(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_datSz(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_HASH_D3th_ 		ISC_USE_ONLY	0x0000C
	#define	w32DRMCMD_HASH_D3th_ 		{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'0000C */				struct	w32DRMCMD_HASH_D3th_;

	/* [31: 0] */	#define	  BA_DRMCMD_HASH_datSrcAddr				 0x0000C
	/* ---:--- */	#define	    bDRMCMD_HASH_datSrcAddr				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_datSrcAddr				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_datSrcAddr				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_HASH_datSrcAddr(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_datSrcAddr(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_datSrcAddr(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_datSrcAddr(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_HASH_D4th_ 		ISC_USE_ONLY	0x00010
	#define	w32DRMCMD_HASH_D4th_ 		{										\
					UNSG32				u_keyID						 : 32;		\
										}
	/* @'00010 */				struct	w32DRMCMD_HASH_D4th_;

	/* [31: 0] */	#define	  BA_DRMCMD_HASH_keyID					 0x00010
	/* ---:--- */	#define	    bDRMCMD_HASH_keyID					   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_keyID					    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_keyID					       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_HASH_keyID(r32)					 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_keyID(r16)					 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_keyID(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_keyID(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_HASH_D5th_ 		ISC_USE_ONLY	0x00014
	#define	w32DRMCMD_HASH_D5th_ 		{										\
					UNSG32				u_authDat					 : 32;		\
										}
	/* @'00014 */				struct	w32DRMCMD_HASH_D5th_;

	/* [31: 0] */	#define	  BA_DRMCMD_HASH_authDat				 0x00014
	/* ---:--- */	#define	    bDRMCMD_HASH_authDat				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_HASH_authDat				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_HASH_authDat				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_HASH_authDat(r32)				 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_HASH_authDat(r16)				 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_HASH_authDat(r32,v)				do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_HASH_authDat(r16,v)				do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMCMD_HASH;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMCMD_HASH_drvrd (SIE_DRMCMD_HASH *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMCMD_HASH_drvwr (SIE_DRMCMD_HASH *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMCMD_HASH_reset (SIE_DRMCMD_HASH *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMCMD_HASH_check(p,pie,ps8name,hfpErrLOG)		DRMCMD_HASH_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMCMD_HASH_print(p,    ps8name,hfpErrLOG)		DRMCMD_HASH_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMCMD_HASH_cmp   (SIE_DRMCMD_HASH *p, SIE_DRMCMD_HASH *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMCMD_HASH_import(SIE_DRMCMD_HASH *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMCMD_HASH_export(SIE_DRMCMD_HASH *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMCMD_HASH
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMCMD_KEY_ENCDEC
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_AES128_ENC
*						*  DRMCMD_AES128_DEC
*						*  DRMCMD_DES_ENC
*						*  DRMCMD_DES_DEC
*						*  DRMCMD_3xDES_ENC
*						*  DRMCMD_3xDES_DEC
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  keyID  0
*						*  *
*						*  Key context ID
*						*  0
*	@
*		%unsigned  32  datSz  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  1  isSRAMAddr  0
*						*  *
*						*  Flag to indicate whether the destination address belongs to SRAM
*		%unsigned  31  datDstAddr  0
*						*  *
*						*  DDR or SRAM address where the data is stored
*	@
*		%unsigned  32  authDat  0
*						*  *
*						*  Command authentication data
**********************************************************************************************************************/
#ifdef	h_DRMCMD_KEY_ENCDEC
#else
#define	h_DRMCMD_KEY_ENCDEC

#define	\
	AR_DRMCMD_KEY_ENCDEC \
		6
#define	\
	AB_DRMCMD_KEY_ENCDEC \
		5

typedef struct SIE_DRMCMD_KEY_ENCDEC {

	#define	RA_DRMCMD_KEY_ENCDEC_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRMCMD_KEY_ENCDEC_D0th_ 	{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32DRMCMD_KEY_ENCDEC_D0th_;

	/* [ 7: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_cmdCode			 0x00000
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_cmdCode			    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_cmdCode			    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_cmdCode			       0x000000FF
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_cmdCode(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_cmdCode(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_cmdCode(r32,v)		do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_cmdCode(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_DRMCMD_KEY_ENCDEC_cmdID			 0x00001
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_cmdID			    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_cmdID			    8 /*:15*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_cmdID			       0x0000FF00
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_cmdID(r32)			 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_cmdID(r16)			 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_cmdID(r32,v)			do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_cmdID(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_DRMCMD_KEY_ENCDEC_keyID 	0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_keyID;

	#define	RA_DRMCMD_KEY_ENCDEC_D2th_ 	ISC_USE_ONLY	0x00008
	#define	w32DRMCMD_KEY_ENCDEC_D2th_ 	{										\
					UNSG32				u_datSz						 : 32;		\
										}
	/* @'00008 */				struct	w32DRMCMD_KEY_ENCDEC_D2th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_datSz			 0x00008
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_datSz			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_datSz			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_datSz			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_datSz(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_datSz(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_datSz(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_datSz(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_KEY_ENCDEC_D3th_ 	ISC_USE_ONLY	0x0000C
	#define	w32DRMCMD_KEY_ENCDEC_D3th_ 	{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'0000C */				struct	w32DRMCMD_KEY_ENCDEC_D3th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_datSrcAddr		 0x0000C
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_datSrcAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_datSrcAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_datSrcAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_datSrcAddr(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_datSrcAddr(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_datSrcAddr(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_datSrcAddr(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_KEY_ENCDEC_D4th_ 	ISC_USE_ONLY	0x00010
	#define	w32DRMCMD_KEY_ENCDEC_D4th_ 	{										\
					UNSG32				u_isSRAMAddr				 :  1;		\
					UNSG32				u_datDstAddr				 : 31;		\
										}
	/* @'00010 */				struct	w32DRMCMD_KEY_ENCDEC_D4th_;

	/* [ 0: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_isSRAMAddr		 0x00010
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_isSRAMAddr		    1 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_isSRAMAddr		    0 /*: 0*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_isSRAMAddr		       0x00000001
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_isSRAMAddr(r32)		 (((r32)>> 0)&0x0001)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_isSRAMAddr(r16)		 (((r16)>> 0)&0x0001)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_isSRAMAddr(r32,v)	do{(r32)&=~(0x0001<< 0);(r32)|=((v)&0x0001)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_isSRAMAddr(r16,v)	do{(r16)&=~(0x0001<< 0);(r16)|=((v)&0x0001)<< 0;}while(0)

	/* [31: 1] */	#define	  BA_DRMCMD_KEY_ENCDEC_datDstAddr		 0x00010
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_datDstAddr		   31 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_datDstAddr		    1 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_datDstAddr		       0xFFFFFFFE
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_datDstAddr(r32)		 (((r32)>> 1)&0x7FFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_datDstAddr(r16)		 (((r16)>> 1)&0x7FFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_datDstAddr(r32,v)	do{(r32)&=~(0x7FFFFFFF<< 1);(r32)|=((v)&0x7FFFFFFF)<< 1;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_datDstAddr(r16,v)	do{(r16)&=~(0x7FFFFFFF<< 1);(r16)|=((v)&0x7FFFFFFF)<< 1;}while(0)

	#define	RA_DRMCMD_KEY_ENCDEC_D5th_ 	ISC_USE_ONLY	0x00014
	#define	w32DRMCMD_KEY_ENCDEC_D5th_ 	{										\
					UNSG32				u_authDat					 : 32;		\
										}
	/* @'00014 */				struct	w32DRMCMD_KEY_ENCDEC_D5th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_ENCDEC_authDat			 0x00014
	/* ---:--- */	#define	    bDRMCMD_KEY_ENCDEC_authDat			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_ENCDEC_authDat			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_ENCDEC_authDat			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_ENCDEC_authDat(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_ENCDEC_authDat(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_ENCDEC_authDat(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_ENCDEC_authDat(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMCMD_KEY_ENCDEC;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMCMD_KEY_ENCDEC_drvrd (SIE_DRMCMD_KEY_ENCDEC *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMCMD_KEY_ENCDEC_drvwr (SIE_DRMCMD_KEY_ENCDEC *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMCMD_KEY_ENCDEC_reset (SIE_DRMCMD_KEY_ENCDEC *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMCMD_KEY_ENCDEC_check(p,pie,ps8name,hfpErrLOG)		DRMCMD_KEY_ENCDEC_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMCMD_KEY_ENCDEC_print(p,    ps8name,hfpErrLOG)		DRMCMD_KEY_ENCDEC_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMCMD_KEY_ENCDEC_cmp   (SIE_DRMCMD_KEY_ENCDEC *p, SIE_DRMCMD_KEY_ENCDEC *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMCMD_KEY_ENCDEC_import(SIE_DRMCMD_KEY_ENCDEC *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMCMD_KEY_ENCDEC_export(SIE_DRMCMD_KEY_ENCDEC *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMCMD_KEY_ENCDEC
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DRMCMD_KEY_TRANS
*	@
*		%unsigned  8  cmdCode  0
*						*  *
*						*  DRMCMD_IMPORT_KEY
*						*  DRMCMD_EXPORT_KEY
*						*  0
*		%unsigned  8  cmdID  0
*						*  *
*						*  Command ID
*						*  0
*	@
*		$DRM_CTXID  parentKeyID  0
*						*  *
*						*  Parent key context ID. For export operation, it MUST be valid key
*						*  0
*	@
*		$DRM_CTXID  keyID  0
*						*  *
*						*  Destination key context ID
*						*  0
*	@
*		%unsigned  32  datSz  0
*						*  *
*						*  The number of bytes in DAT_SRCADDR.
*						*  0
*	@
*		%unsigned  32  datSrcAddr  0
*						*  *
*						*  DDR address where the data is stored
*	@
*		%unsigned  32  authDat  0
*						*  *
*						*  Command authentication data
**********************************************************************************************************************/
#ifdef	h_DRMCMD_KEY_TRANS
#else
#define	h_DRMCMD_KEY_TRANS

#define	\
	AR_DRMCMD_KEY_TRANS \
		6
#define	\
	AB_DRMCMD_KEY_TRANS \
		5

typedef struct SIE_DRMCMD_KEY_TRANS {

	#define	RA_DRMCMD_KEY_TRANS_D0th_ 	ISC_USE_ONLY	0x00000
	#define	w32DRMCMD_KEY_TRANS_D0th_ 	{										\
					UNSG32				u_cmdCode					 :  8;		\
					UNSG32				u_cmdID						 :  8;		\
					UNSG32				_x00000	: 16;							\
										}
	/* @'00000 */				struct	w32DRMCMD_KEY_TRANS_D0th_;

	/* [ 7: 0] */	#define	  BA_DRMCMD_KEY_TRANS_cmdCode			 0x00000
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_cmdCode			    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_cmdCode			    0 /*: 7*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_cmdCode			       0x000000FF
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_cmdCode(r32)			 (((r32)>> 0)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_cmdCode(r16)			 (((r16)>> 0)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_cmdCode(r32,v)		do{(r32)&=~(0x00FF<< 0);(r32)|=((v)&0x00FF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_cmdCode(r16,v)		do{(r16)&=~(0x00FF<< 0);(r16)|=((v)&0x00FF)<< 0;}while(0)

	/* [15: 8] */	#define	  BA_DRMCMD_KEY_TRANS_cmdID				 0x00001
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_cmdID				    8 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_cmdID				    8 /*:15*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_cmdID				       0x0000FF00
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_cmdID(r32)			 (((r32)>> 8)&0x00FF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_cmdID(r16)			 (((r16)>> 8)&0x00FF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_cmdID(r32,v)			do{(r32)&=~(0x00FF<< 8);(r32)|=((v)&0x00FF)<< 8;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_cmdID(r16,v)			do{(r16)&=~(0x00FF<< 8);(r16)|=((v)&0x00FF)<< 8;}while(0)

	#define	RA_DRMCMD_KEY_TRANS_parentKeyID 0x00004
	/* @'00004 */	SIE_DRM_CTXID 				ie_parentKeyID;

	#define	RA_DRMCMD_KEY_TRANS_keyID 	0x00008
	/* @'00008 */	SIE_DRM_CTXID 				ie_keyID;

	#define	RA_DRMCMD_KEY_TRANS_D3th_ 	ISC_USE_ONLY	0x0000C
	#define	w32DRMCMD_KEY_TRANS_D3th_ 	{										\
					UNSG32				u_datSz						 : 32;		\
										}
	/* @'0000C */				struct	w32DRMCMD_KEY_TRANS_D3th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_TRANS_datSz				 0x0000C
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_datSz				   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_datSz				    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_datSz				       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_datSz(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_datSz(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_datSz(r32,v)			do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_datSz(r16,v)			do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_KEY_TRANS_D4th_ 	ISC_USE_ONLY	0x00010
	#define	w32DRMCMD_KEY_TRANS_D4th_ 	{										\
					UNSG32				u_datSrcAddr				 : 32;		\
										}
	/* @'00010 */				struct	w32DRMCMD_KEY_TRANS_D4th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_TRANS_datSrcAddr		 0x00010
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_datSrcAddr		   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_datSrcAddr		    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_datSrcAddr		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_datSrcAddr(r32)		 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_datSrcAddr(r16)		 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_datSrcAddr(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_datSrcAddr(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

	#define	RA_DRMCMD_KEY_TRANS_D5th_ 	ISC_USE_ONLY	0x00014
	#define	w32DRMCMD_KEY_TRANS_D5th_ 	{										\
					UNSG32				u_authDat					 : 32;		\
										}
	/* @'00014 */				struct	w32DRMCMD_KEY_TRANS_D5th_;

	/* [31: 0] */	#define	  BA_DRMCMD_KEY_TRANS_authDat			 0x00014
	/* ---:--- */	#define	    bDRMCMD_KEY_TRANS_authDat			   32 /*bit*/
	/* ---:--- */	#define	LSb32DRMCMD_KEY_TRANS_authDat			    0 /*:31*/
	/* ---:--- */	#define	MSK32DRMCMD_KEY_TRANS_authDat			       0xFFFFFFFF
	/* ---:--- */	#define	GET32DRMCMD_KEY_TRANS_authDat(r32)			 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DRMCMD_KEY_TRANS_authDat(r16)			 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DRMCMD_KEY_TRANS_authDat(r32,v)		do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DRMCMD_KEY_TRANS_authDat(r16,v)		do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DRMCMD_KEY_TRANS;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DRMCMD_KEY_TRANS_drvrd (SIE_DRMCMD_KEY_TRANS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DRMCMD_KEY_TRANS_drvwr (SIE_DRMCMD_KEY_TRANS *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DRMCMD_KEY_TRANS_reset (SIE_DRMCMD_KEY_TRANS *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DRMCMD_KEY_TRANS_check(p,pie,ps8name,hfpErrLOG)		DRMCMD_KEY_TRANS_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DRMCMD_KEY_TRANS_print(p,    ps8name,hfpErrLOG)		DRMCMD_KEY_TRANS_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DRMCMD_KEY_TRANS_cmp   (SIE_DRMCMD_KEY_TRANS *p, SIE_DRMCMD_KEY_TRANS *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DRMCMD_KEY_TRANS_import(SIE_DRMCMD_KEY_TRANS *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DRMCMD_KEY_TRANS_export(SIE_DRMCMD_KEY_TRANS *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DRMCMD_KEY_TRANS
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DIAG_BIUFIRWALL_MAGICNUM
*			:  RD  0x5400
*						*  *
*						*  Read magic value
*			:  WR  0x8900
*						*  *
*						*  Write magic value
*	@
*		%unsigned  32  dummy
*						*  *
*						*  Bytes of the block to be tested
**********************************************************************************************************************/
#ifdef	h_DIAG_BIUFIRWALL_MAGICNUM
#else
#define	h_DIAG_BIUFIRWALL_MAGICNUM

#define	\
	AR_DIAG_BIUFIRWALL_MAGICNUM \
		1
#define	\
	AB_DIAG_BIUFIRWALL_MAGICNUM \
		2

	#define	DIAG_BIUFIRWALL_MAGICNUM_RD 0x5400
	#define	DIAG_BIUFIRWALL_MAGICNUM_WR 0x8900

typedef struct SIE_DIAG_BIUFIRWALL_MAGICNUM {

	#define	RA_DIAG_BIUFIRWALL_MAGICNUM_D0th_ ISC_USE_ONLY	0x00000
	#define	w32DIAG_BIUFIRWALL_MAGICNUM_D0th_ {									\
					UNSG32				u_dummy						 : 32;		\
										}
	/* @'00000 */				struct	w32DIAG_BIUFIRWALL_MAGICNUM_D0th_;

	/* [31: 0] */	#define	  BA_DIAG_BIUFIRWALL_MAGICNUM_dummy		 0x00000
	/* ---:--- */	#define	    bDIAG_BIUFIRWALL_MAGICNUM_dummy		   32 /*bit*/
	/* ---:--- */	#define	LSb32DIAG_BIUFIRWALL_MAGICNUM_dummy		    0 /*:31*/
	/* ---:--- */	#define	MSK32DIAG_BIUFIRWALL_MAGICNUM_dummy		       0xFFFFFFFF
	/* ---:--- */	#define	GET32DIAG_BIUFIRWALL_MAGICNUM_dummy(r32)	 (((r32)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	GET16DIAG_BIUFIRWALL_MAGICNUM_dummy(r16)	 (((r16)>> 0)&0xFFFFFFFF)
	/* ---:--- */	#define	SET32DIAG_BIUFIRWALL_MAGICNUM_dummy(r32,v)	do{(r32)&=~(0xFFFFFFFF<< 0);(r32)|=((v)&0xFFFFFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DIAG_BIUFIRWALL_MAGICNUM_dummy(r16,v)	do{(r16)&=~(0xFFFFFFFF<< 0);(r16)|=((v)&0xFFFFFFFF)<< 0;}while(0)

} SIE_DIAG_BIUFIRWALL_MAGICNUM;


/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DIAG_BIUFIRWALL_MAGICNUM_drvrd (SIE_DIAG_BIUFIRWALL_MAGICNUM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DIAG_BIUFIRWALL_MAGICNUM_drvwr (SIE_DIAG_BIUFIRWALL_MAGICNUM *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DIAG_BIUFIRWALL_MAGICNUM_reset (SIE_DIAG_BIUFIRWALL_MAGICNUM *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DIAG_BIUFIRWALL_MAGICNUM_check(p,pie,ps8name,hfpErrLOG)		DIAG_BIUFIRWALL_MAGICNUM_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DIAG_BIUFIRWALL_MAGICNUM_print(p,    ps8name,hfpErrLOG)		DIAG_BIUFIRWALL_MAGICNUM_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DIAG_BIUFIRWALL_MAGICNUM_cmp   (SIE_DIAG_BIUFIRWALL_MAGICNUM *p, SIE_DIAG_BIUFIRWALL_MAGICNUM *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DIAG_BIUFIRWALL_MAGICNUM_import(SIE_DIAG_BIUFIRWALL_MAGICNUM *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DIAG_BIUFIRWALL_MAGICNUM_export(SIE_DIAG_BIUFIRWALL_MAGICNUM *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DIAG_BIUFIRWALL_MAGICNUM
**********************************************************************************************************************/



/**********************************************************************************************************************
*	INTERFACE: DIAG_BIUFIRWALL_CTX
*	@
*		$DRMROM_SRAM_RESERVED  reserved
*						*  *
*						*  ROM reserved SRAM
*	@  FLAG
*		%unsigned  16  ready
*						*  *
*						*  1: FIGO has already re-initialized the SRAM and BIU firewall
*	@  PARM
*		%unsigned  16  addrStart
*						*  *
*						*  Start of the test BIU address
*		%unsigned  16  blkSize
*						*  *
*						*  Bytes of the block to be tested
**********************************************************************************************************************/
#ifdef	h_DIAG_BIUFIRWALL_CTX
#else
#define	h_DIAG_BIUFIRWALL_CTX

#define	\
	AR_DIAG_BIUFIRWALL_CTX \
		514
#define	\
	AB_DIAG_BIUFIRWALL_CTX \
		12

typedef struct SIE_DIAG_BIUFIRWALL_CTX {

	#define	RA_DIAG_BIUFIRWALL_CTX_reserved 0x00000
	/* @'00000 */	SIE_DRMROM_SRAM_RESERVED 	ie_reserved;

	#define	RA_DIAG_BIUFIRWALL_CTX_FLAG 0x00800
	#define	w32DIAG_BIUFIRWALL_CTX_FLAG {										\
					UNSG32				uFLAG_ready					 : 16;		\
					UNSG32				_x00800	: 16;							\
										}
	/* @'00800 */	union {	UNSG32		u32DIAG_BIUFIRWALL_CTX_FLAG;
								struct	w32DIAG_BIUFIRWALL_CTX_FLAG;
										};

	/* [15: 0] */	#define	  BA_DIAG_BIUFIRWALL_CTX_FLAG_ready		 0x00800
	/* ---:--- */	#define	    bDIAG_BIUFIRWALL_CTX_FLAG_ready		   16 /*bit*/
	/* ---:--- */	#define	LSb32DIAG_BIUFIRWALL_CTX_FLAG_ready		    0 /*:15*/
	/* ---:--- */	#define	MSK32DIAG_BIUFIRWALL_CTX_FLAG_ready		       0x0000FFFF
	/* ---:--- */	#define	GET32DIAG_BIUFIRWALL_CTX_FLAG_ready(r32)	 (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DIAG_BIUFIRWALL_CTX_FLAG_ready(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DIAG_BIUFIRWALL_CTX_FLAG_ready(r32,v)	do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DIAG_BIUFIRWALL_CTX_FLAG_ready(r16,v)	do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	#define	RA_DIAG_BIUFIRWALL_CTX_PARM 0x00804
	#define	w32DIAG_BIUFIRWALL_CTX_PARM {										\
					UNSG32				uPARM_addrStart				 : 16;		\
					UNSG32				uPARM_blkSize				 : 16;		\
										}
	/* @'00804 */	union {	UNSG32		u32DIAG_BIUFIRWALL_CTX_PARM;
								struct	w32DIAG_BIUFIRWALL_CTX_PARM;
										};

	/* [15: 0] */	#define	  BA_DIAG_BIUFIRWALL_CTX_PARM_addrStart	 0x00804
	/* ---:--- */	#define	    bDIAG_BIUFIRWALL_CTX_PARM_addrStart	   16 /*bit*/
	/* ---:--- */	#define	LSb32DIAG_BIUFIRWALL_CTX_PARM_addrStart	    0 /*:15*/
	/* ---:--- */	#define	MSK32DIAG_BIUFIRWALL_CTX_PARM_addrStart	       0x0000FFFF
	/* ---:--- */	#define	GET32DIAG_BIUFIRWALL_CTX_PARM_addrStart(r32) (((r32)>> 0)&0xFFFF)
	/* ---:--- */	#define	GET16DIAG_BIUFIRWALL_CTX_PARM_addrStart(r16) (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DIAG_BIUFIRWALL_CTX_PARM_addrStart(r32,v)do{(r32)&=~(0xFFFF<< 0);(r32)|=((v)&0xFFFF)<< 0;}while(0)
	/* ---:--- */	#define	SET16DIAG_BIUFIRWALL_CTX_PARM_addrStart(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

	/* [31:16] */	#define	  BA_DIAG_BIUFIRWALL_CTX_PARM_blkSize	 0x00806
	/* ---:--- */	#define	    bDIAG_BIUFIRWALL_CTX_PARM_blkSize	   16 /*bit*/
	/* ---:--- */	#define	LSb32DIAG_BIUFIRWALL_CTX_PARM_blkSize	   16 /*:31*/
	/* ---:--- */	#define	MSK32DIAG_BIUFIRWALL_CTX_PARM_blkSize	       0xFFFF0000
	/* ---:--- */	#define	GET32DIAG_BIUFIRWALL_CTX_PARM_blkSize(r32)	 (((r32)>>16)&0xFFFF)
	/* ---:--- */	#define	GET16DIAG_BIUFIRWALL_CTX_PARM_blkSize(r16)	 (((r16)>> 0)&0xFFFF)
	/* ---:--- */	#define	SET32DIAG_BIUFIRWALL_CTX_PARM_blkSize(r32,v)do{(r32)&=~(0xFFFF<<16);(r32)|=((v)&0xFFFF)<<16;}while(0)
	/* ---:--- */	#define	SET16DIAG_BIUFIRWALL_CTX_PARM_blkSize(r16,v)do{(r16)&=~(0xFFFF<< 0);(r16)|=((v)&0xFFFF)<< 0;}while(0)

} SIE_DIAG_BIUFIRWALL_CTX;

	#define	dftDIAG_BIUFIRWALL_CTX_FLAG 0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DIAG_BIUFIRWALL_CTX_FLAG;
										} T32DIAG_BIUFIRWALL_CTX_FLAG;
	#define	dftDIAG_BIUFIRWALL_CTX_PARM 0x00000000
			typedef	union {	UNSG32		u32;
								struct	w32DIAG_BIUFIRWALL_CTX_PARM;
										} T32DIAG_BIUFIRWALL_CTX_PARM;

/* Member function: read (or self test read) from SRAM or flat register interface and return words read */
SIGN32	DIAG_BIUFIRWALL_CTX_drvrd (SIE_DIAG_BIUFIRWALL_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST);

/* Member function: generate write-commands or direct-write (or self test write) and return write count */
SIGN32	DIAG_BIUFIRWALL_CTX_drvwr (SIE_DIAG_BIUFIRWALL_CTX *p, UNSG32 u32base, SIGN32 bMEM, SIGN32 bST, UNSG32 *pu32cmd);

/* Member function: element reset */
void	DIAG_BIUFIRWALL_CTX_reset (SIE_DIAG_BIUFIRWALL_CTX *p);

/* Member function: check elements, return SUCCESS if identical or ERR_MISMATCH */
#define	DIAG_BIUFIRWALL_CTX_check(p,pie,ps8name,hfpErrLOG)		DIAG_BIUFIRWALL_CTX_cmp(p,pie, ps8name,hfpErrLOG,0,0)
#define	DIAG_BIUFIRWALL_CTX_print(p,    ps8name,hfpErrLOG)		DIAG_BIUFIRWALL_CTX_cmp(p,NULL,ps8name,hfpErrLOG,0,0)
SIGN32	DIAG_BIUFIRWALL_CTX_cmp   (SIE_DIAG_BIUFIRWALL_CTX *p, SIE_DIAG_BIUFIRWALL_CTX *pie, char *ps8name, UNSG32 hfpErrLOG, SIGN32 bMEM, SIGN32 bST);

/* Member function: import interface values from a text string of compact all bits */
SIGN32	DIAG_BIUFIRWALL_CTX_import(SIE_DIAG_BIUFIRWALL_CTX *p, char *regs);

/* Member function: export interface values to a text string of compact all bits */
SIGN32	DIAG_BIUFIRWALL_CTX_export(SIE_DIAG_BIUFIRWALL_CTX *p, char *regs);

#endif
/**********************************************************************************************************************
*	ENDOFINTERFACE: DIAG_BIUFIRWALL_CTX
**********************************************************************************************************************/



#pragma	pack()

#ifdef	__cplusplus
	}
#endif

#endif	/* _diag_biu_firewall_spec_h */
/**********************************************************************************************************************
*	ENDOFFILE (by "Interface Specification Compiler" ver-1.0): diag_biu_firewall_spec.h
**********************************************************************************************************************/

